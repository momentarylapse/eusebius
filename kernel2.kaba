#define __OS__
#define __CODE_ORIGIN__ 0x10000
#define __VARIABLE_OFFSET__ 0x200010 // > 2mb, wegen Stack!
#define __ADD_ENTRY_POINT__
//#disasm

int MemorySize


//--------------------------------------------------------------
// Low Level

int _temp_port_no_
int _temp_port_data_

void outportb(int port, char data)
	_temp_port_no_ = port
	_temp_port_data_ = data
	asm{
		mov eax, _temp_port_data_
		mov edx, _temp_port_no_
		out dx, al
	}

void outportd(int port,int data)
	_temp_port_no_ = port
	_temp_port_data_ = data
	asm{
		mov eax, _temp_port_data_
		mov edx, _temp_port_no_
		out dx, eax
	}

char inportb(int port)
	_temp_port_no_ = port
	asm{
		mov edx, _temp_port_no_
		xor eax, eax
		in al, dx
		mov _temp_port_data_, eax
	}
	return _temp_port_data_

int inportd(int port)
	_temp_port_no_ = port
	asm{
		mov edx, _temp_port_no_
		in eax, dx
		mov _temp_port_data_, eax
	}
	return _temp_port_data_



void read_data_from_init()
	asm{
		mov eax, [0x00005100]
		mov MemorySize, eax
	}


void memcpy(cstring *dest, cstring *source, int size)
	for int n, 0, size
		dest[n] = source[n]
	/*if size > 0
		temp_i=size
		temp_p=source
		temp_p2=dest
		asm{
			mov ecx, temp_i
			mov eax, temp_p
			mov ebx, temp_p2
			_mem_cpy_loop:
				mov.b dl, [eax]
				mov.b [ebx], dl
				inc eax
				inc ebx
				loop _mem_cpy_loop
		}*/

void strcpy(cstring *a, cstring *b)
	for int i, 0, 256
		a[i] = b[i]
		if b[i] == 0
			break

int strcmp(cstring *a, cstring *b)
	for int i, 0, 256
		if a[i] > b[i]
			return 1
		else if a[i] < b[i]
			return -1
		if a[i] == 0
			break
	return 0

int __temp_i__, __temp_i2__, __temp_i3__, __temp_i4__
void *__temp_p__, *__temp_p2__, *__temp_p3__, *__temp_p4__
int _p2i(void *p)
	int *i = &p
	return *i
	
void *_i2p(int i)
	model *p = &i
	return *p


//--------------------------------------------------------------
// Speicher-"Verwaltung"	

const int MEM_ALLOC_OFFSET = 0x400000 // (4-2)=2mb Kernel-Variablen
const int MAX_MEM_ALLOCS = 4096

int NumMemAllocs
class mem_alloc_t
	int Offset,End
mem_alloc_t MemAlloc[MAX_MEM_ALLOCS]


// Speicherbloecke bleiben immer so sortiert, dass der Offset monoton mit dem Index steigt!
void *malloc(int size)
	// Anfang
	int offset=MEM_ALLOC_OFFSET
	int a=0
	// suchen
	while a<NumMemAllocs
		if offset+size<MemAlloc[a].Offset
			break
		offset=MemAlloc[a].End
		a ++
	// hintere Allocs verschieben
	int a2=NumMemAllocs-1
	while a2>=a
		MemAlloc[a2+1]=MemAlloc[a2]
		a2--
	// neuen Alloc einfuegen
	MemAlloc[a].Offset=offset
	MemAlloc[a].End=offset+size
	NumMemAllocs++
	return _i2p(offset)

void free(void *mem)
	int mem_i=_p2i(mem)
	int a=0
	int ae=-1
	while (ae<0) or (a<NumMemAllocs)
		if MemAlloc[a].Offset==mem_i
			ae=a
		a++
	if ae>=0
		a=ae
		NumMemAllocs--
		while a<NumMemAllocs
			MemAlloc[a]=MemAlloc[a+1]
			a++
	

//--------------------------------------------------------------
// Text Modus

void *VideoMemory
char TextColor, TextColor2
int TextPos, TextLine
const int SCREEN_WIDTH = 80
const int SCREEN_HEIGHT = 25

void clrscr()
	cstring *d = VideoMemory
	for int i, 0, SCREEN_WIDTH * SCREEN_HEIGHT
		d[i * 2] = ' '
		d[1 * 2 + 1] = 0
	TextLine = 0
	TextPos = 0

void etm_init()
	asm{
		mov eax, 0x000b8000
		mov VideoMemory, eax
	}
	clrscr()
	TextColor = 7

void etm_shift()
	cstring *d = VideoMemory
	cstring *d2 = &d[SCREEN_WIDTH * 2]
	for int i, 0, SCREEN_WIDTH * (SCREEN_HEIGHT - 1) * 2
		d[i] = d2[i]
	d2 = &d[SCREEN_WIDTH * (SCREEN_HEIGHT - 1) * 2]
	for int i, 0, SCREEN_WIDTH
		d2[i * 2] = ' '
		d2[i * 2 + 1] = 0

void prints(cstring str)
	cstring *d = VideoMemory
	d = &d[2*(SCREEN_WIDTH * TextLine + TextPos)]
	int i = 0
	while str[i] != 0
		if str[i] != 0x0a
			d[0] = str[i]
			d[1] = TextColor
			d = &d[2]
			TextPos ++
		if (TextPos >= SCREEN_WIDTH) or (str[i] == 0x0a)
			TextPos = 0
			TextLine ++
			if TextLine >= SCREEN_HEIGHT
				etm_shift()
				TextLine --
			d = VideoMemory
			d = &d[2*(SCREEN_WIDTH * TextLine)]
		i ++
	int position = (TextLine * SCREEN_WIDTH) + TextPos
	// cursor LOW port to vga INDEX register
	outportb(0x3d4, 0x0f)
	outportb(0x3d5, position)
	// cursor HIGH port to vga INDEX register
	outportb(0x3d4, 0x0e)
	outportb(0x3d5, position >> 8)

void _i2s(int i, cstring *s)
	char ttt[16]
	ttt[15] = 0
	int offset = 14
	while true
		ttt[offset] = (i % 10) + 0x30
		i /= 10
		offset --
		if i == 0
			break
	strcpy(s, &ttt[offset + 1])

void printi(int i)
	cstring s
	_i2s(i, &s)
	prints(s)

int printh(cstring *data,int size)
	cstring ttt
	for int i, 0, size
		int d = data[i]
		int d1 = (d>>4)
		int d2 = (d&15)
		if d1 < 10
			ttt[0] = d1+48
		else
			ttt[0] = d1+87
		if d2<10
			ttt[1] = d2+48
		else
			ttt[1] = d2+87
		if i == size-1
			ttt[2] = 0
		else
			ttt[2] = '.'
			ttt[3] = 0
		prints(ttt)

/*void WasteTime()
	int x
	for x, 0, 100000
		nil*/


//--------------------------------------------------------------
// Ata Treiber

#define AtaMaskBusy		0x80
#define AtaMaskReady		0x40
#define AtaMaskData		0x08

class AtaDiskInfo
	bool isAvailable
	bool isAtapi
	int size
	cstring name

class AtaData

	int nAta
	int Status
	int IOBase, IOCtrl, ide_no, ide_ms
	char MSMask

	char Buffer[512]
	int BufferDW[0]*
	int Size

	char atapi_buffer[16]
	
	AtaDiskInfo DiskInfo[4]

	void wait_400_ns()
		for int i, 0, 100
			inportb(IOBase + 7)

	bool wait_status(char mask, char value)
		char AtaStatusChar = inportb(IOBase + 7)
		int n = 1000000000
		while ((AtaStatusChar & mask)!=value) and (n >= 0)
			AtaStatusChar = inportb(IOCtrl)//+7)
			n--
		return n >= 0

	void SetDiskAdd(int disk_no)
		ide_no = (disk_no/2)
		ide_ms = (disk_no%2)
		// Adressierungs-Daten
		IOBase = 0x1f0
		if ide_no == 1
			IOBase = 0x170
		IOCtrl = IOBase + 0x206
		//IOCtrl = 0x3f6
		MSMask = 0x00
		if ide_ms == 1
			MSMask = 0x10

	bool TestDisk(int disk_no)
		SetDiskAdd(disk_no)
		DiskInfo[disk_no].isAvailable = false

		// generell ansprechbar?
		prints("IDE ")
		printi(ide_no)
		prints(":")
		printi(ide_ms)
		TextPos = 20
		outportb(0x1f6, MSMask)
		wait_400_ns()
		outportb(IOBase + 2, 0x55)
		outportb(IOBase + 3, 0xaa)
		outportb(IOBase + 2, 0xaa)
		outportb(IOBase + 3, 0x55)
		outportb(IOBase + 2, 0x55)
		outportb(IOBase + 3, 0xaa)
		char sc = inportb(IOBase + 2)
		char sn = inportb(IOBase + 3)
		if (sc != 0x55) or (sn != 0xaa)
			prints("---\n")
			return false

		// now we think we know which devices, if any are there,
		// so lets try a soft reset (ignoring any errors).

		outportb(IOBase + 6, MSMask)
		wait_400_ns()
		outportb(IOCtrl, 0x0e) // soft reset
		wait_400_ns()
		outportb(IOCtrl, 0x0a)
		wait_400_ns()

		//sub_atapi_delay( 0 )
		wait_status(AtaMaskBusy, 0)
		outportb(IOBase + 6, MSMask)
		wait_400_ns()

		// lets check device 0 again, is device 0 really there?
		// is it ATA or ATAPI?
		sc = inportb(IOBase + 2)
		sn = inportb(IOBase + 3)
		bool fail = true
		if (sc == 0x01) and (sn == 0x01)
			DiskInfo[disk_no].isAtapi = false
			fail = false
			char cl = inportb(IOBase + 4)
			char ch = inportb(IOBase + 5)
			char st = inportb(IOBase + 7)
			if ( cl == 0x14 ) and (ch == 0xeb)
				prints("ATAPI (CD-Rom)")
				DiskInfo[disk_no].isAtapi = true
			else
				if (cl == 0x00) and (ch == 0x00) and (st != 0x00)
					prints("ATA")
				else
					fail = true
		if fail
			prints("---\n")
			return false

		/*outportb( 0x1f6, 0xe0 ) // Master+LBA
		wait_400_ns()
		outportb( 0x3f6, 0x0e ) // ?+SoftReset+NoInt
		wait_400_ns()
		outportb( 0x3f6, 0x0a ) // ?+NoInt
		wait_400_ns()
		ata_wait_busy()*/

		DiskInfo[disk_no].isAvailable = true

		outportb(IOCtrl, 0x0a) // ?+NoInt
		wait_400_ns()
		wait_status(AtaMaskBusy, 0)
		outportb(IOBase+1, 0) //?
		outportb(IOBase+2, 0) // NumSectors
 		outportb(IOBase+3, 0) // S0
 		outportb(IOBase+4, 0) // C0
		outportb(IOBase+5, 0)
		char ata_lba3 = MSMask | 0x60 // ...+LBA
		outportb(IOBase+6, ata_lba3) // H0
		if DiskInfo[disk_no].isAtapi
			outportb(IOBase+7, 0xa1) // IdentifyDrive (ATAPI)
		else
			outportb(IOBase+7, 0xec) // IdentifyDrive
		wait_400_ns()

		wait_status(0x88, AtaMaskData)
		wait_400_ns()

		BufferDW = &Buffer
		int n
		for n, 0, 128
			BufferDW[n] = inportd(IOBase)
		// die Bytes des Namens korregieren
		//for n, 0, 40, 2
		n=0
		while n<40
			DiskInfo[disk_no].name[n  ] = Buffer[55+n]
			DiskInfo[disk_no].name[n+1] = Buffer[54+n]
			n+=2
		DiskInfo[disk_no].name[40] = 0
		prints(DiskInfo[disk_no].name)
		memcpy(&DiskInfo[disk_no].size, &Buffer[120], 4)
		/*temp_i = Ata.DiskInfo[disk_no].size >> 11
		asm{
			mov eax, temp_i
			shr eax, 0xb
			mov temp_i, eax
		}*/
		TextPos = 60
		printi(DiskInfo[disk_no].size >> 11)
	//	TextPos=60
	//	printi(DiskInfo[disk_no].Size)
		prints("mb\n")

		return true

	bool Reset(int disk_no)
		if !DiskInfo[disk_no].isAvailable
			return false
		prints("AtaReset ")
		SetDiskAdd(disk_no)
	
		char status
		status=inportb(IOBase+7)
		printh(&status,1)
		status=inportb(IOBase+1)
		printh(&status,1)
		status=inportb(IOCtrl)
		printh(&status,1)
	
		status=inportb(IOBase+7)
		printh(&status,1)
		status=inportb(IOBase+1)
		printh(&status,1)
		status=inportb(IOCtrl)
		printh(&status,1)
		prints("\n")

	void Init()
		prints("ATA Geraete:\n")
	
		// set up Device Control register
		outportb(0x3f6, 0x0a)
		outportb(0x376, 0x0a)

		for int n, 0, 4
			TestDisk(n)
			
	// 1 Sektor = 512 b
	bool ReadSector(int disk_no, int sector_offset, int num_sectors, char *buf)
		if !DiskInfo[disk_no].isAvailable
			return false
		//DrawString(0,24,"MAtaRead")
		SetDiskAdd(disk_no)
		//printh(&IOBase,2)
		// num_sectors=1...
		outportb(IOBase + 0x206, 0x0a)
	
		char status


		if DiskInfo[disk_no].isAtapi
			nil
			/*
			/*status=inportb(AtaIOBase+7)
			DrawHex(20,24,&status,1)
			status=inportb(AtaIOBase+1)
			DrawHex(23,24,&status,1)
			status=inportb(AtaIOCtrl)
			DrawHex(26,24,&status,1)
			WaitReturn()*/
			
			wait_status(0x88, 0)
			outportb(IOBase + 7, 0x08) // Soft Reset
			wait_400_ns()

			// CommandPacket
			atapi_buffer[0]=0xa8 // Read
			atapi_buffer[1]=0x00
			atapi_buffer[2]=i2c(sector_offset>>24) // LBA 24..31
			atapi_buffer[3]=i2c(sector_offset>>16) // 16..23
			atapi_buffer[4]=i2c(sector_offset>>8) // 8..15
			atapi_buffer[5]=i2c(sector_offset) // 0..7
			atapi_buffer[6]=0x00
			atapi_buffer[7]=0x00
			atapi_buffer[8]=0x00
			atapi_buffer[9]=i2c(num_sectors) // NumSectors
			atapi_buffer[10]=0x00
			atapi_buffer[11]=0x00
		
			//wait_status(AtaMaskBusy | AtaMaskData,0)
			wait_status(0x88,0)

			// dem ATA-Controller sagen, wir wollen ein ATAPI-Paket senden
			outportb(IOBase+1, 0 ) // Features
			outportb(IOBase+2, 0 )
			outportb(IOBase+3, 0 )
			outportb(IOBase+4, 0 )
			outportb(IOBase+5, 0 )
			outportb(IOBase+6, MSMask | 0x40 ) // H0 ...+LBA
			outportb(IOBase+7, 0xa0 ) // Packet
			wait_400_ns()

			//ata_wait_status(AtaMaskBusy,0)

			//ata_wait_status(0x88,AtaMaskData)
			wait_status(MaskData,AtaMaskData)

			/*status=inportb(AtaIOBase+7)
			DrawHex(50,15,&status,1)
			status=inportb(AtaIOBase+1)
			DrawHex(50,16,&status,1)
			status=inportb(AtaIOCtrl)
			DrawHex(50,17,&status,1)*/
		
		
			int abdw[0]*
			abdw=&atapi_buffer
			outportd(AtaIOBase,abdw[0])
			outportd(AtaIOBase,abdw[1])
			outportd(AtaIOBase,abdw[2])*/
		else
			outportb(IOCtrl, 0x0a) // ?+NoInt
			wait_400_ns()
			wait_status(AtaMaskBusy, 0)

			outportb(IOBase+1, 0) // Features
			outportb(IOBase+2, num_sectors) // NumSectors
 			outportb(IOBase+3, sector_offset) // S0
 			outportb(IOBase+4, sector_offset >> 8) // C0
			outportb(IOBase+5, sector_offset >> 16)
			outportb(IOBase+6, sector_offset >> 24 | MSMask | 0x40 ) // H0 ...+LBA
			outportb(IOBase+7, 0x20 ) // ReadSector
		wait_400_ns()

		wait_status(0x88, AtaMaskData)
		//wait_status(AtaMaskData | AtaMaskBusy,AtaMaskData)
		wait_400_ns()

		BufferDW = buf
	
		if DiskInfo[disk_no].isAtapi
			//prints("Lese...")
			status=inportb(IOBase+7)
			//printh(&status,1)
			status=inportb(IOBase+1)
			//printh(&status,1)
			status=inportb(IOCtrl)
			//printh(&status,1)
		
			int read=0
			while read<512 // 2048b
		
				int byte_cnt = inportb(IOBase + 5) * 256 + inportb(IOBase + 4)
				printi(byte_cnt)
				byte_cnt=20
		
				int dw_cnt=byte_cnt/4
				int n
				for n, 0, dw_cnt
					BufferDW[n]=inportd(IOBase)
				printh(buf,20)
				read+=dw_cnt
		else
			for n, 0, 128 // 512b
				BufferDW[n] = inportd(IOBase)

		status=inportb(IOBase+7)
		//printh(&status,1)
		status=inportb(IOBase+1)
		//printh(&status,1)
		status=inportb(IOCtrl)
		//printh(&status,1)

		return true

AtaData Ata


class PartitionData
	int offset, size
	char type
	bool active
	
PartitionData Partition[4]
int CurrentPartition

void ReadPartitions(int disk_no)
	// mbr lesen
	Ata.ReadSector(disk_no,0,1,&Ata.Buffer)
	//MountPartition=false
	for int n, 0, 4
		PartitionData *p = &Partition[n]
		int *offset = &Ata.Buffer[454+n*16]
		p.offset = *offset / 4
		int *size = &Ata.Buffer[458+n*16]
		p.size = *size / 4
		p.type = Ata.Buffer[450+n*16]
		p.active = (Ata.Buffer[446+n*16] == 0x80)
	/*for n, 0, 512
		DrawHex(n*3,2,&AtaBuffer[n],1)*/
		
void ShowPartitions()
	prints("Primaere Partitionen:     Offset   Groesse\n")
	for int n, 0, 4
		PartitionData *p = &Partition[n]
		prints("/dev/hda")
		printi(n + 1)
		if (p.type != 0x00) and (p.size > 0)
			TextPos = 60
			if p.active
				prints("(aktiv)")
			TextPos = 27
			printi(p.offset)
			TextPos = 36
			printi(p.size)
			TextPos = 50
			if p.type == 0x83
				prints("Linux")
			else if p.type == 0x20
				prints("MichiFS")
			else if p.type == 0x0c
				prints("Fat 32")
			else if p.type == 0x0e
				prints("Fat 16")
			else if p.type == 0x07
				prints("NTFS")
			else if p.type == 0x0f
				prints("Erweitert...")
			else
				printh(&p.type, 1)
		else
			TextPos = 50
			prints("---")
		prints("\n")

//--------------------------------------------------------------
// Dateisystem

const int FILE_TYPE_FILE = 0
const int FILE_TYPE_DIR = 1
const int FILE_TYPE_CHAR = 8
const int FILE_TYPE_BLOCK = 16


class FileOperations
	void *_open
	void *_close
	void *_read
	void *_write

class FileEntry
	cstring name
	int type
	int size
	int offset
	int num_clusters
	FileEntry *next
	FileEntry *first_sub
	FileOperations *op
	
	void add(FileEntry *e)
		if first_sub
			FileEntry *i = first_sub
			while i.next
				i = i.next
			i.next = e
		else
			first_sub = e
	void _show()
		printi(type)
		prints(" ")
		printi(size)
		prints(" ")
		prints(name)
		prints("\n")
	
	void show()
		_show()
		FileEntry *e = first_sub
		while e
			prints("    ")
			e._show()
			e = e.next
	FileEntry *get_sub(cstring sname)
		FileEntry *e = first_sub
		while e
			if strcmp(&sname, &e.name) == 0
				return e
			e = e.next
		return nil

class FileSystemData
	FileEntry list[256] // TODO: dynamic memory
	int list_size
	FileEntry *root
	
	char buf[2048]
	int buf_used
	
	FileEntry *add(cstring name, int type, FileEntry *parent)
		FileEntry *e = &list[list_size]
		list_size ++
		strcpy(&e.name, &name)
		e.type = type
		e.next = nil
		e.first_sub = nil
		e.op = nil
		if parent
			parent.add(e)
		return e
	
	void Init()
		list_size = 0
		root = add("-root-", FILE_TYPE_DIR, nil)
	
	FileEntry *get(cstring path)
		if path[0] != '/'
			return nil
		if path[1] == 0
			return root
		FileEntry *e = root
		cstring sub
		int ppos = 1
		bool has_more = true
		while has_more
			strcpy(&sub, &path[ppos])
			cstring name
			for int i, 0, 256
				if (sub[i] == '/') or (sub[i] == 0)
					has_more = (sub[i] == '/')
					ppos += i + 1
					name[i] = 0
					break
				name[i] = sub[i]
			e = e.get_sub(name)
			if !e
				return nil
		return e
		
	void Read(int disk_no, int cluster_offset, char buffer[0]*)
		Ata.ReadSector(disk_no, cluster_offset * 4    , 1, &buffer[0])
		Ata.ReadSector(disk_no, cluster_offset * 4 + 1, 1, &buffer[512])
		Ata.ReadSector(disk_no, cluster_offset * 4 + 2, 1, &buffer[1024])
		Ata.ReadSector(disk_no, cluster_offset * 4 + 3, 1, &buffer[1536])
	
	int read_int()
		int *p = &buf[buf_used]
		buf_used += 4
		return *p
	void read_str(cstring s)
		int l = buf[buf_used] + buf[buf_used+1]*256
		buf_used += 2
		for int i, 0, l
			s[i] = buf[buf_used + i]
		buf_used += l
		s[l] = 0
		
	void Mount(PartitionData p, FileEntry *dir)
		prints("mounte...")
		Read(0, p.offset + 1, &buf)
		buf_used = 0
		int NumFiles = read_int()
		for int n, 0, NumFiles
			cstring name
			read_str(name)
			FileEntry *e = add(name, FILE_TYPE_FILE, dir)
			//e.type =
			read_int()
			e.size = read_int()
			read_int() // NumParts = 1
			e.offset = read_int()
			e.num_clusters = read_int()
		prints(" ok\n")

FileSystemData FileSystem

//--------------------------------------------------------------
// Gerätedateien

FileOperations dev_zero_ops
void dev_zero_open(FileEntry *f)
	nil
void dev_zero_close(FileEntry *f)
	nil
int dev_zero_read(FileEntry *f, cstring *buf, int size)
	for int i, 0, size
		buf[i] = 0
	return size
int dev_zero_write(FileEntry *f, cstring *buf, int size)
	return 0

FileOperations dev_null_ops
void dev_null_open(FileEntry *f)
	nil
void dev_null_close(FileEntry *f)
	nil
int dev_null_read(FileEntry *f, cstring *buf, int size)
	return 0
int dev_null_write(FileEntry *f, cstring *buf, int size)
	return size

FileOperations dev_rand_ops
int dev_rand_state
void dev_rand_open(FileEntry *f)
	nil
void dev_rand_close(FileEntry *f)
	nil
int dev_rand_read(FileEntry *f, cstring *buf, int size)
	for int i, 0, size
		dev_rand_state = (dev_rand_state * 23434 + 82374) % 8623
		buf[i] = dev_rand_state
	return size
int dev_rand_write(FileEntry *f, cstring *buf, int size)
	return 0


FileOperations dev_key_ops
cstring dev_key_buf
int dev_key_num
void dev_key_open(FileEntry *f)
	nil
void dev_key_close(FileEntry *f)
	nil
int dev_key_read(FileEntry *f, cstring *buf, int size)
	if size > dev_key_num
		size = dev_key_num
	for int i, 0, size
		buf[i] = dev_key_buf[i]
		dev_key_num --
		memcpy(&dev_key_buf, &dev_key_buf[1], dev_key_num)
	return size
int dev_key_write(FileEntry *f, cstring *buf, int size)
	return 0

void InitDrivers()
	FileEntry *dev = FileSystem.add("dev", FILE_TYPE_DIR, FileSystem.root)
	
	FileEntry *dev_zero = FileSystem.add("zero", FILE_TYPE_CHAR, dev)
	dev_zero_ops._open = &dev_zero_open
	dev_zero_ops._close = &dev_zero_close
	dev_zero_ops._read = &dev_zero_read
	dev_zero_ops._write = &dev_zero_write
	dev_zero.op = &dev_zero_ops
	
	FileEntry *dev_null = FileSystem.add("null", FILE_TYPE_CHAR, dev)
	dev_null_ops._open = &dev_null_open
	dev_null_ops._close = &dev_null_close
	dev_null_ops._read = &dev_null_read
	dev_null_ops._write = &dev_null_write
	dev_null.op = &dev_null_ops
	
	dev_rand_state = 13
	
	FileEntry *dev_rand = FileSystem.add("random", FILE_TYPE_CHAR, dev)
	dev_rand_ops._open = &dev_rand_open
	dev_rand_ops._close = &dev_rand_close
	dev_rand_ops._read = &dev_rand_read
	dev_rand_ops._write = &dev_rand_write
	dev_rand.op = &dev_rand_ops
	
	dev_key_num = 0
	
	FileEntry *dev_key = FileSystem.add("keyboard", FILE_TYPE_CHAR, dev)
	dev_key_ops._open = &dev_key_open
	dev_key_ops._close = &dev_key_close
	dev_key_ops._read = &dev_key_read
	dev_key_ops._write = &dev_key_write
	dev_key.op = &dev_key_ops
	


//--------------------------------------------------------------
// Dateizugriff

class OpenFileData
	bool used
	FileEntry *entry
	int pos_in_cluster
	int cluster_no
	char buffer[0]*

OpenFileData OpenFile[128]
int num_open_files

int get_handle()
	for int i, 0, num_open_files
		if !OpenFile[i].used
			OpenFile[i].used = true
			return i
	OpenFile[num_open_files].used = true
	num_open_files ++
	return num_open_files - 1
			

int sys_open(cstring filename)
	int index = get_handle()
	OpenFileData *of = &OpenFile[index]
	of.entry = FileSystem.get(filename)
	if !of.entry
		of.used = false
		return -1
	if of.entry.type == FILE_TYPE_FILE
		of.buffer = malloc(2048)
		of.cluster_no = 0
		of.pos_in_cluster = 0
		int p_offset = Partition[CurrentPartition].offset
		FileSystem.Read(0, p_offset + of.entry.offset, of.buffer)
	else if of.entry.type == FILE_TYPE_CHAR
		__temp_p__ = of.entry.op._open
		__temp_p2__ = of.entry
		asm{
			mov eax, __temp_p__
			push __temp_p2__
			call eax
			sub esp, 0x04
		}
	return index

int sys_read(int handle, char buffer[0]*, int size)
	if (handle < 0) or (handle >= num_open_files)
		return -1
	int r=0

	OpenFileData *of = &OpenFile[handle]
	if !of.used
		return -1
		
	if of.entry.type == FILE_TYPE_CHAR
		__temp_p__ = of.entry.op._read
		__temp_p2__ = of.entry
		__temp_p3__ = buffer
		__temp_i__ = size
		asm{
			mov eax, __temp_p__
			push __temp_i__
			push __temp_p3__
			push __temp_p2__
			call eax
			mov __temp_i__, eax
			sub esp, 0x12
		}
		return __temp_i__
		
	if size > of.entry.size - of.cluster_no * 2048 - of.pos_in_cluster
		size = of.entry.size - of.cluster_no * 2048 - of.pos_in_cluster
		
	while size > 0
	
		// wieviel kann aus dem Puffer gelesen werden?
		int cur_size = size
		if cur_size > 2048 - of.pos_in_cluster
			cur_size = 2048 - of.pos_in_cluster

		// direkt lesen (aus dem Lese-Puffer kopieren)
		memcpy(buffer, &of.buffer[of.pos_in_cluster], cur_size)
		buffer = &buffer[cur_size]
		of.pos_in_cluster += cur_size
		r += cur_size
		size -= cur_size
		
		if of.pos_in_cluster >= 2048
			// nächsten Cluster einlesen
			of.pos_in_cluster = 0
			of.cluster_no ++
			int cl = of.entry.offset + of.cluster_no
			int p_offset = Partition[CurrentPartition].offset
			FileSystem.Read(0, p_offset + cl, of.buffer)
		
	return r

/*	// Datei zu Ende?
	int f_rest = of.entry.size - of.cluster_no * 2048 - of.pos_in_cluster
	if size > f_rest
		size = f_rest

	bool done = false
	while !done
		int post_read = 0

		// Cluster zu Ende?
		int c_rest = 2048 - of.pos_in_cluster
		if size > c_rest
			post_read = size - c_rest // später lesen
			size = c_rest // jetzt lesen


		// direkt lesen (aus dem Lese-Puffer kopieren)
		memcpy(buffer, &of.buffer[of.pos_in_cluster], size)
		r += size


		if post_read > 0
			// nächsten Cluster einlesen
			of.pos_in_cluster = 0
			of.cluster_no ++
			//print(of.cluster_no,0,"X")
			//printi(of.cluster_no)
			int cl = of.entry.offset + of.cluster_no
			int p_offset = Partition[CurrentPartition].offset
			FileSystem.Read(0, p_offset + 4*cl, of.buffer)
			buffer = &buffer[size]
			size = post_read // noch zu lesender Rest
		else
			done = true
	return r*/

void sys_close(int handle)
	if (handle < 0) or (handle >= num_open_files)
		return
	OpenFileData *of = &OpenFile[handle]
	if !of.used
		return
	if of.entry.type == FILE_TYPE_FILE
		free(of.buffer)
	else if of.entry.type == FILE_TYPE_CHAR
		__temp_p__ = of.entry.op._close
		__temp_p2__ = of.entry
		asm{
			mov eax, __temp_p__
			push __temp_p2__
			call eax
			sub esp, 0x04
		}
	of.used = false
	of.entry = nil

//--------------------------------------------------------------
// Tasks

const int MAX_TASKS = 256
const int TASK_STACK_SIZE = 40960
const int NUM_PRE_GDT_ENTRIES = 5
const int TASK_SWITCH_DT = 20 // ms

enum
	TASK_STATUS_SLEEPING
	TASK_STATUS_RUNNING
	TASK_STATUS_DEAD

class TaskStateSegment
	int prev
	void *esp0
	int ss0
	void *esp1
	int ss1
	void *esp2
	int ss2
	int cr3 // =PDPR
	void *eip
	int eflags // Iterrupt Flag
	int eax
	int ecx
	int edx
	int ebx
	void *esp
	void *ebp
	int esi
	int edi
	int es, cs, ss, ds, fs, gs
	int x, y
	
	
	void set(void *stack_pos, int _cs, int _ds, int pvl, void *task)
		int _ss = _ds
		prev = 0 // previous TSS (dynamisch)
		esp0 = stack_pos
		ss0 = _ss * 8
		esp1 = stack_pos
		ss1 = _ss * 8
		esp2 = stack_pos
		ss2 = _ss * 8
		cr3 = 0 // (=PDPR)
		eip = task
		eflags = 0x200 + pvl * 0x1000 // IterruptFlag + PVL
		eax = 0
		ecx = 0
		edx = 0
		ebx = 0
		esp = stack_pos
		ebp = stack_pos
		esi = 0
		edi = 0
		es = _ds * 8
		cs = _cs * 8
		ss = _ss * 8
		ds = _ds * 8
		fs = _ds * 8
		gs = _ds * 8
		x = 0
		y = 0


class TaskData
	TaskStateSegment tss
	int stack[0]*
	int desc // Index in GDT
	int pid, status
	cstring name
	void Start()
		status = TASK_STATUS_RUNNING
TaskData Task[MAX_TASKS], *CurTask, *TimerTask, *SysCallTask
int NumTasks,CurPid
int TaskCallData[2]
bool InterruptsEnabled
bool SchedulerEnabled

class GlobalDescriptorData
	int a, b
	void set_base(int base, int limit, bool gran)
		a = (base << 16) + (limit & 0xffff) // base[15..0] limit[15..0]
		b = (base & 0xff000000) + (limit & 0x0f0000) + ((base >> 16) & 0xff)  // base[31..24],..limit[19..16] not busy, base[23..16]
		b += 0x00008000 // present
		if gran
			b += 0x00800000
	void set_data(int base, int limit, bool executable, int pvl)
		set_base(base, limit >> 12, true)
		b += 0x00401200
		if executable
			b += 0x00000800
		b += 0x00002000 * pvl
	void set_task(TaskData *t)
		set_base(_p2i(&t.tss), 103, false)
		b += 0x00000900 // not busy
	void set_busy(bool busy)
		if busy
			b = b | 0x200
		else
			b = b & 0xfffffdff

GlobalDescriptorData GlobalDescriptorTable[NUM_PRE_GDT_ENTRIES + MAX_TASKS]

void *AddTask(cstring name, void *func, int pvl)
	asm{
		cli
	}
	TaskData *t = &Task[NumTasks]
	t.pid = NumTasks

	strcpy(&t.name, &name)
	t.desc = NUM_PRE_GDT_ENTRIES + NumTasks
	t.stack = malloc(TASK_STACK_SIZE)
	t.status = TASK_STATUS_SLEEPING
	if pvl == 0
		t.tss.set(t.stack, 1, 2, pvl, func)
	else
		t.tss.set(t.stack, 3, 4, pvl, func)
	GlobalDescriptorTable[t.desc].set_task(t)
	NumTasks ++

	if InterruptsEnabled
		asm{
			sti
		}
	return t

void RunTaskForced(TaskData *t)
	/*prints("springe in ")
	printi(t.pid)
	prints(t.name)*/
	// "Task Gate Descriptor" ---- falsch, kein gate!
	TaskCallData[0] = 0
	TaskCallData[1] = 8 * t.desc
	//printi(t.desc)
	//prints(":\n")
	__temp_p__ = &TaskCallData[0]

	// in Task springen
	CurTask = t
	//t.status = TASK_STATUS_RUNNING
	asm{
		mov eax, __temp_p__
		//db 0xff
		//db 0x28
		//jmp_far [eax]
		db 0xff
		db 0x18
		//call_far [eax]
		//jmp_far 0x004000000000 //0x0040:0x00000000
	}

int GetNextTask(int pid)
	for int i, pid + 1, NumTasks
		if Task[i].status == TASK_STATUS_RUNNING
			return i
	for int i, 0, pid
		if Task[i].status == TASK_STATUS_RUNNING
			return i
	return pid

void InitTasks()
	prints("init Tasks")
	InterruptsEnabled = false
	SchedulerEnabled = false
	
	// null descriptor
	for int i, 0, NUM_PRE_GDT_ENTRIES + MAX_TASKS
		GlobalDescriptorTable[i].a = 0x00000000
		GlobalDescriptorTable[i].b = 0x00000000
	// kernel code
	GlobalDescriptorTable[1].set_data(0, 0xffffffff, true, 0)
	// kernel data
	GlobalDescriptorTable[2].set_data(0, 0xffffffff, false, 0)
	// user code
	GlobalDescriptorTable[3].set_data(0, 0xffffffff, true, 3)
	// user data
	GlobalDescriptorTable[4].set_data(0, 0xffffffff, false, 3)


	CurPid = 1
	NumTasks = 0

	CurTask = AddTask("kernel", nil, 0)
	
	// GDT laden
	__temp_i__ = sizeof(GlobalDescriptorTable) - 1
	__temp_p__ = &GlobalDescriptorTable
	asm{
		jmp _after_gdt_data
		_gdtr:
		dw 0x0000
		_gdtr_base:
		dd 0x00000000
		_after_gdt_data:
		mov eax, __temp_i__
		mov [_gdtr], eax
		mov eax, __temp_p__
		mov [_gdtr_base], eax
		lgdt [_gdtr]
	}

	//prints("\n  setze Kernel-Task-Register")
	__temp_i__ = CurTask.desc * 8
	asm{
		mov eax, __temp_i__ // Descriptor[n]
		ltr ax
	}
	// markiert das aktuelle TSS als "busy"!

	prints("   ok\n")

//--------------------------------------------------------------
// Interrupts


void int_handler(int i)
	TextColor=0x04
	prints("\nInt ")
	printi(i)
	if i==0
		prints(": Division durch Null")
	if i==1
		prints(": Debug")
	if i==3
		prints(": Breakpoint")
	if i==4
		prints(": Overflow")
	if i==5
		prints(": Bounds Check")
	if i==6
		prints(": Invalider Opcode")
	if i==7
		prints(": kein Ko-Prozessor")
	if i==8
		prints(": System-Fehler")
	if i==9
		prints(": Ko-Prozessor-Segment overrun")
	if i==10
		prints(": Invalides TSS")
	if i==11
		prints(": Segment fehlt")
	if i==12
		prints(": Stack-Fehler")
	if i==13
		prints(": General Protection Fault")
	if i==14
		prints(": Page-Fault")
	if i==16
		prints(": Koprozessor-Fehler")
	prints("  8-P")
	while true
		nil

void int_00()
	int_handler(0)
void int_01()
	int_handler(1)
void int_02()
	int_handler(2)
void int_03()
	int_handler(3)
void int_04()
	int_handler(4)
void int_05()
	int_handler(5)
void int_06()
	int_handler(6)
void int_07()
	int_handler(7)
void int_08()
	int_handler(8)
void int_09()
	int_handler(9)
void int_10()
	int_handler(10)
void int_11()
	int_handler(11)
void int_12()
	int_handler(12)
void int_13()
	int_handler(13)
void int_14()
	int_handler(14)
void int_15()
	int_handler(15)
void int_16()
	int_handler(16)
void int_XX()
	int_handler(2004)

class InterruptDescriptor
	int a, b

	void set(void *func)
		if !func
			a = 0
			b = 0
		else
			int addr = _p2i(func)
			// Interrupt Gate
			a = 0x00080000 + (addr & 0xffff) // desc[1],addr[15..0]
			b = (addr & 0xffff0000) + 0x00008e00 // addr[31..16],typ

	TaskData *set_task(cstring name, void *func)
		if !func
			a = 0
			b = 0
		else
			TaskData *t = AddTask(name, func, 0)
			t.tss.eflags = 0x000 // Iterrupt Flag = 0

			// Interrupt Task Gate
			a = 0x00080000*t.desc // desc,0[15..0]
			b = 0x00008500 // 0[31..16],typ
			return t
		return nil

InterruptDescriptor InterruptDescriptorTable[256]

void irq_1()
	while true
		outportb(0x20, 0x20)
		int k = inportb(0x60)
		/*prints("<IRQ ")
		printi(k)
		prints(">")*/
		if dev_key_num >= 64
			// :P
			dev_key_num = 0
		dev_key_buf[dev_key_num] = k
		dev_key_num ++
		asm{
			iret
		}

void int_timer()
	while true

		if SchedulerEnabled
		
			int last = (TimerTask.tss.prev >> 3) - NUM_PRE_GDT_ENTRIES
			int next = GetNextTask(last)
			GlobalDescriptorTable[Task[last].desc].set_busy(false)
			GlobalDescriptorTable[Task[next].desc].set_busy(true)
			TimerTask.tss.prev = (next + NUM_PRE_GDT_ENTRIES) << 3
			/*prints("<")
			printi(last)
			prints(",")
			printi(next)
			prints(">")*/

		// weitere Aufrufe erlauben
		outportb(0x20,0x20)

		// zurück
		asm{
			iret
		}

void show_pvl()
	asm{
		db 0x9c // pushf
		pop eax
		mov __temp_i__, eax
	}
	int eflags = __temp_i__
	int pvl = (eflags >> 12) & 3
	prints("[PVL:")
	printi(pvl)
	prints("]")
	
void int_syscall()
	asm{
		mov __temp_i__, eax
		mov __temp_i2__, ebx
		mov __temp_i3__, ecx
		mov __temp_i4__, edx
	}
	int index = __temp_i__
	int param1 = __temp_i2__
	int param2 = __temp_i3__
	int param3 = __temp_i4__
	while true
		//show_pvl()
		int r = 0
	
		if index == 3 // read
			cstring *p = _i2p(param2)
			r = sys_read(param1, p, param3)
		else if index == 4 // write
			cstring *p = _i2p(param1)
			prints(*p)
		else if index == 5 // open
			cstring *p = _i2p(param1)
			r = sys_open(*p)
		else if index == 6 // close
			sys_close(param1)
		else
			prints("<<")
			printi(index)
			prints(">>")

		// zurück
		__temp_i__ = r
		asm{
			leave
			//pop eax
			//pop eax
			mov eax, __temp_i__
			iret
			mov __temp_i__, eax
			mov __temp_i2__, ebx
			mov __temp_i3__, ecx
			mov __temp_i4__, edx
			push ebp
			mov ebp, esp
		}
		index = __temp_i__
		param1 = __temp_i2__
		param2 = __temp_i3__
		param3 = __temp_i4__

void InitInterrupts()
	prints("lade Iterrupt-Tabelle")

	for int i, 0, 256
		InterruptDescriptorTable[i].set(nil)

	InterruptDescriptorTable[ 0].set(&int_00)
	InterruptDescriptorTable[ 1].set(&int_01)
	InterruptDescriptorTable[ 2].set(&int_02)
	InterruptDescriptorTable[ 3].set(&int_03)
	InterruptDescriptorTable[ 4].set(&int_04)
	InterruptDescriptorTable[ 5].set(&int_05)
	InterruptDescriptorTable[ 6].set(&int_06)
	InterruptDescriptorTable[ 7].set(&int_07)
	InterruptDescriptorTable[ 8].set(&int_08)
	InterruptDescriptorTable[ 9].set(&int_09)
	InterruptDescriptorTable[10].set(&int_10)
	InterruptDescriptorTable[11].set(&int_11)
	InterruptDescriptorTable[12].set(&int_12)
	InterruptDescriptorTable[13].set(&int_13)
	InterruptDescriptorTable[14].set(&int_14)
	InterruptDescriptorTable[15].set(&int_15)
	InterruptDescriptorTable[16].set(&int_16)
	TimerTask = InterruptDescriptorTable[32].set_task("timer", &int_timer)
	InterruptDescriptorTable[33].set_task("irq", &irq_1)
	//InterruptDescriptorTable[0x80].set_task("syscall", &int_syscall)
	InterruptDescriptorTable[0x80].set(&int_syscall)

	// IRQs auf höhere Interrupts legen
	outportb(0x20,0x11)
	outportb(0xa0,0x11)
	outportb(0x21,0x20)
	outportb(0xa1,0x28)
	outportb(0x21,0x04)
	outportb(0xa1,0x02)
	outportb(0x21,0x01)
	outportb(0xa1,0x01)
	outportb(0x21,0x00)
	outportb(0xa1,0x00)
	
	__temp_p__ = &InterruptDescriptorTable

	asm{
		jmp _after_idt_data
		_idtr:
		dw 0x07ff
		_idtr_base:
		dd 0x00000000
		_after_idt_data:
		mov eax, __temp_p__
		mov [_idtr_base], eax
		cli
		lidt [_idtr]
		sti
	}

	/*outportb(0x70,0x08)
	char c=inportb(0x71)
	outportb(0x71,c|0x40)*/

	/*prints("versuche boese Speicher-Operation...")

	int i = 0
	1/i
	asm{
		mov [0x00000000], eax
	}*/
	
	InterruptsEnabled = true
	prints("   ok\n")

void user_prints(cstring s)
	__temp_p__ = &s
	asm{
		mov eax, 0x00000004
		mov ebx, __temp_p__
		int 0x80
	}

void second_task()
	user_prints(" == Task2!!! ==\n")
	show_pvl()
	//int ii = 0
	//4 / ii
	int counter_j=1
	while true
		cstring s
		_i2s(counter_j, &s)
		user_prints(s)
		user_prints(" ")

		for int i, 0, 200000
			nil

		/*if (counter_j % 50)==0
			user_prints("versuche, zurueck zu springen...\n")
			asm{
				iret
			}*/
		counter_j++

void InitTimer()
	// ticks/s: 1193180
	// 100Hz:   11932 = 0x2e9c
	int ticks_per_sec = 1193180
	int ticks_till_irq = (ticks_per_sec >> 10) * TASK_SWITCH_DT
	if ticks_till_irq > 0xffff
		ticks_till_irq = 0xffff
	//1/0
	outportb(0x43, 0x34)
	outportb(0x40, ticks_till_irq) //0x9c)
	outportb(0x40, ticks_till_irq >> 8) //0x2e)

void StartScheduler()
	prints("starte Scheduler\n")
	InitTimer()
	SchedulerEnabled = true
	RunTaskForced(TimerTask)

void TaskTest()
	prints("teste Task-Faehigkeit:\n")

	TaskData *a = AddTask("test", &second_task, 0)//3)
	TaskData *b = AddTask("test", &second_task, 0)//3)
	a.Start()
	b.Start()

	/*RunTask(t)

	prints("fahre fort...\n")
	for int i, 0, 40000
		nil

	RunTask(t)

	asm{
		cli
	}

	prints("   ok\n")
	char tc=TextColor
	TextColor=0x04
	prints("fertig")
	TextColor=tc
	//while true
	//	NULL*/

	

void Execute(cstring filename)
	int h = sys_open(filename)
	if h < 0
		prints("## kann Prozess-Datei nicht lesen! ##\n")
		return
	cstring *p = _i2p(0x500000)
	cstring *pp = p
	while true
		int r = sys_read(h, pp, 1024)
		if r <= 0
			break
		pp = &pp[r]
	sys_close(h)
	
	TaskData *t = AddTask(filename, p, 0)
	t.Start()

void FileTest()
	int h = sys_open("/test.txt")
	if h < 0
		prints("## kann Datei nicht lesen! ##\n")
		return
	cstring s
	int r = sys_read(h, &s, 256)
	s[r] = 0
	prints(s)
	sys_close(h)

void DriverTest()
	prints("Treiber Test\n")
	int h = sys_open("/dev/keyboard")
	if h < 0
		prints("## kann Datei nicht lesen! ##\n")
		return
	while true
		cstring s
		int r = sys_read(h, &s, 64)
		if r > 0
			printh(&s, r)
			prints(" ")
	sys_close(h)


void main()
	read_data_from_init()
	etm_init()
	NumMemAllocs=0
	
	prints("Willkommen zu Eusebius 0.2.0   (c) by MichiSoft TM 2013\n")
	prints("Speicher: ")
	printi(MemorySize)
	prints("k\n")
	
	Ata.Init()
	ReadPartitions(0)
	ShowPartitions()
	
	FileSystem.Init()
	FileSystem.Mount(Partition[0], FileSystem.root)
	/*FileEntry *e = FileSystem.get("/dev/b")
	if e
		e.show()
	FileSystem.root.show()*/
	
	InitTasks()
	
	InitInterrupts()
	
	InitDrivers()

	//TaskTest()
	//FileTest()
	//DriverTest()
	
	Execute("/shell")
	
	StartScheduler()
	
	asm{
		cli
	}
	TextColor = 4
	prints("\n------ keine Tasks => halte Kernel -----\n")
	
	while true
		nil

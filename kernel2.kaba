#define __OS__
#define __CODE_ORIGIN__ 0x9000
#define __VARIABLE_OFFSET__ 0x200010 // > 2mb, wegen Stack!
#define __ADD_ENTRY_POINT__
//#disasm

int MemorySize


//--------------------------------------------------------------
// Low Level

int _temp_port_no_
int _temp_port_data_

void outportb(int port, char data)
	_temp_port_no_ = port
	_temp_port_data_ = data
	asm{
		mov eax, _temp_port_data_
		mov edx, _temp_port_no_
		out dx, al
	}

void outportd(int port,int data)
	_temp_port_no_ = port
	_temp_port_data_ = data
	asm{
		mov eax, _temp_port_data_
		mov edx, _temp_port_no_
		out dx, eax
	}

char inportb(int port)
	_temp_port_no_ = port
	asm{
		mov edx, _temp_port_no_
		xor eax, eax
		in al, dx
		mov _temp_port_data_, eax
	}
	return _temp_port_data_

int inportd(int port)
	_temp_port_no_ = port
	asm{
		mov edx, _temp_port_no_
		in eax, dx
		mov _temp_port_data_, eax
	}
	return _temp_port_data_



void read_data_from_init()
	asm{
		mov eax, [0x00005100]
		mov MemorySize, eax
	}


void memcpy(cstring *dest, cstring *source, int size)
	for int n, 0, size
		dest[n] = source[n]
	/*if size > 0
		temp_i=size
		temp_p=source
		temp_p2=dest
		asm{
			mov ecx, temp_i
			mov eax, temp_p
			mov ebx, temp_p2
			_mem_cpy_loop:
				mov.b dl, [eax]
				mov.b [ebx], dl
				inc eax
				inc ebx
				loop _mem_cpy_loop
		}*/

void strcpy(cstring *a, cstring *b)
	for int i, 0, 256
		a[i] = b[i]
		if b[i] == 0
			break

int strcmp(cstring *a, cstring *b)
	for int i, 0, 256
		if a[i] > b[i]
			return 1
		else if a[i] > b[i]
			return -1
		if a[i] == 0
			break
	return 0

//--------------------------------------------------------------
// Text Modus

void *VideoMemory
char TextColor, TextColor2
int TextPos, TextLine
const int SCREEN_WIDTH = 80
const int SCREEN_HEIGHT = 25

void clrscr()
	cstring *d = VideoMemory
	for int i, 0, SCREEN_WIDTH * SCREEN_HEIGHT
		d[i * 2] = ' '
		d[1 * 2 + 1] = 0
	TextLine = 0
	TextPos = 0

void etm_init()
	asm{
		mov eax, 0x000b8000
		mov VideoMemory, eax
	}
	clrscr()
	TextColor = 7

void etm_shift()
	cstring *d = VideoMemory
	cstring *d2 = &d[SCREEN_WIDTH * 2]
	for int i, 0, SCREEN_WIDTH * (SCREEN_HEIGHT - 1) * 2
		d[i] = d2[i]
	d2 = &d[SCREEN_WIDTH * (SCREEN_HEIGHT - 1) * 2]
	for int i, 0, SCREEN_WIDTH
		d2[i * 2] = ' '
		d2[i * 2 + 1] = 0

void prints(cstring str)
	cstring *d = VideoMemory
	d = &d[2*(SCREEN_WIDTH * TextLine + TextPos)]
	int i = 0
	while str[i] != 0
		if str[i] != 0x0a
			d[0] = str[i]
			d[1] = TextColor
			d = &d[2]
			TextPos ++
		if (TextPos >= SCREEN_WIDTH) or (str[i] == 0x0a)
			TextPos = 0
			TextLine ++
			if TextLine >= SCREEN_HEIGHT
				etm_shift()
				TextLine --
			d = VideoMemory
			d = &d[2*(SCREEN_WIDTH * TextLine)]
		i ++
	int position = (TextLine * SCREEN_WIDTH) + TextPos
	// cursor LOW port to vga INDEX register
	outportb(0x3d4, 0x0f)
	outportb(0x3d5, position)
	// cursor HIGH port to vga INDEX register
	outportb(0x3d4, 0x0e)
	outportb(0x3d5, position >> 8)

void printi(int i)
	char ttt[16]
	ttt[15]=0
	int s=14
	while true
		ttt[s]=i2c(i%10)+0x30
		i/=10
		s--
		if i == 0
			break
	cstring *p
	p = &ttt[s+1]
	prints(*p)

int printh(cstring *data,int size)
	cstring ttt
	for int i, 0, size
		int d = data[i]
		int d1 = (d>>4)
		int d2 = (d&15)
		if d1 < 10
			ttt[0] = d1+48
		else
			ttt[0] = d1+87
		if d2<10
			ttt[1] = d2+48
		else
			ttt[1] = d2+87
		if i == size-1
			ttt[2] = 0
		else
			ttt[2] = '.'
			ttt[3] = 0
		prints(ttt)

/*void WasteTime()
	int x
	for x, 0, 100000
		nil*/


//--------------------------------------------------------------
// Ata Treiber

#define AtaMaskBusy		0x80
#define AtaMaskReady		0x40
#define AtaMaskData		0x08

class AtaDiskInfo
	bool isAvailable
	bool isAtapi
	int size
	cstring name

class AtaData

	int nAta
	int Status
	int IOBase, IOCtrl, ide_no, ide_ms
	char MSMask

	char Buffer[512]
	int BufferDW[0]*
	int Size

	char atapi_buffer[16]
	
	AtaDiskInfo DiskInfo[4]

	void wait_400_ns()
		for int i, 0, 100
			inportb(IOBase + 7)

	bool wait_status(char mask, char value)
		char AtaStatusChar = inportb(IOBase + 7)
		int n = 1000000000
		while ((AtaStatusChar & mask)!=value) and (n >= 0)
			AtaStatusChar = inportb(IOCtrl)//+7)
			n--
		return n >= 0

	void SetDiskAdd(int disk_no)
		ide_no = (disk_no/2)
		ide_ms = (disk_no%2)
		// Adressierungs-Daten
		IOBase = 0x1f0
		if ide_no == 1
			IOBase = 0x170
		IOCtrl = IOBase + 0x206
		//IOCtrl = 0x3f6
		MSMask = 0x00
		if ide_ms == 1
			MSMask = 0x10

	bool TestDisk(int disk_no)
		SetDiskAdd(disk_no)
		DiskInfo[disk_no].isAvailable = false

		// generell ansprechbar?
		prints("IDE ")
		printi(ide_no)
		prints(":")
		printi(ide_ms)
		TextPos = 20
		outportb(0x1f6, MSMask)
		wait_400_ns()
		outportb(IOBase + 2, 0x55)
		outportb(IOBase + 3, 0xaa)
		outportb(IOBase + 2, 0xaa)
		outportb(IOBase + 3, 0x55)
		outportb(IOBase + 2, 0x55)
		outportb(IOBase + 3, 0xaa)
		char sc = inportb(IOBase + 2)
		char sn = inportb(IOBase + 3)
		if (sc != 0x55) or (sn != 0xaa)
			prints("---\n")
			return false

		// now we think we know which devices, if any are there,
		// so lets try a soft reset (ignoring any errors).

		outportb(IOBase + 6, MSMask)
		wait_400_ns()
		outportb(IOCtrl, 0x0e) // soft reset
		wait_400_ns()
		outportb(IOCtrl, 0x0a)
		wait_400_ns()

		//sub_atapi_delay( 0 )
		wait_status(AtaMaskBusy, 0)
		outportb(IOBase + 6, MSMask)
		wait_400_ns()

		// lets check device 0 again, is device 0 really there?
		// is it ATA or ATAPI?
		sc = inportb(IOBase + 2)
		sn = inportb(IOBase + 3)
		bool fail = true
		if (sc == 0x01) and (sn == 0x01)
			DiskInfo[disk_no].isAtapi = false
			fail = false
			char cl = inportb(IOBase + 4)
			char ch = inportb(IOBase + 5)
			char st = inportb(IOBase + 7)
			if ( cl == 0x14 ) and (ch == 0xeb)
				prints("ATAPI (CD-Rom)")
				DiskInfo[disk_no].isAtapi = true
			else
				if (cl == 0x00) and (ch == 0x00) and (st != 0x00)
					prints("ATA")
				else
					fail = true
		if fail
			prints("---\n")
			return false

		/*outportb( 0x1f6, 0xe0 ) // Master+LBA
		wait_400_ns()
		outportb( 0x3f6, 0x0e ) // ?+SoftReset+NoInt
		wait_400_ns()
		outportb( 0x3f6, 0x0a ) // ?+NoInt
		wait_400_ns()
		ata_wait_busy()*/

		DiskInfo[disk_no].isAvailable = true

		outportb(IOCtrl, 0x0a) // ?+NoInt
		wait_400_ns()
		wait_status(AtaMaskBusy, 0)
		outportb(IOBase+1, 0) //?
		outportb(IOBase+2, 0) // NumSectors
 		outportb(IOBase+3, 0) // S0
 		outportb(IOBase+4, 0) // C0
		outportb(IOBase+5, 0)
		char ata_lba3 = MSMask | 0x60 // ...+LBA
		outportb(IOBase+6, ata_lba3) // H0
		if DiskInfo[disk_no].isAtapi
			outportb(IOBase+7, 0xa1) // IdentifyDrive (ATAPI)
		else
			outportb(IOBase+7, 0xec) // IdentifyDrive
		wait_400_ns()

		wait_status(0x88, AtaMaskData)
		wait_400_ns()

		BufferDW = &Buffer
		int n
		for n, 0, 128
			BufferDW[n] = inportd(IOBase)
		// die Bytes des Namens korregieren
		//for n, 0, 40, 2
		n=0
		while n<40
			DiskInfo[disk_no].name[n  ] = Buffer[55+n]
			DiskInfo[disk_no].name[n+1] = Buffer[54+n]
			n+=2
		DiskInfo[disk_no].name[40] = 0
		prints(DiskInfo[disk_no].name)
		memcpy(&DiskInfo[disk_no].size, &Buffer[120], 4)
		/*temp_i = Ata.DiskInfo[disk_no].size >> 11
		asm{
			mov eax, temp_i
			shr eax, 0xb
			mov temp_i, eax
		}*/
		TextPos = 60
		printi(DiskInfo[disk_no].size >> 11)
	//	TextPos=60
	//	printi(DiskInfo[disk_no].Size)
		prints("mb\n")

		return true

	bool Reset(int disk_no)
		if !DiskInfo[disk_no].isAvailable
			return false
		prints("AtaReset ")
		SetDiskAdd(disk_no)
	
		char status
		status=inportb(IOBase+7)
		printh(&status,1)
		status=inportb(IOBase+1)
		printh(&status,1)
		status=inportb(IOCtrl)
		printh(&status,1)
	
		status=inportb(IOBase+7)
		printh(&status,1)
		status=inportb(IOBase+1)
		printh(&status,1)
		status=inportb(IOCtrl)
		printh(&status,1)
		prints("\n")

	void Init()
		prints("ATA Geraete:\n")
	
		// set up Device Control register
		outportb(0x3f6, 0x0a)
		outportb(0x376, 0x0a)

		for int n, 0, 4
			TestDisk(n)
			
	
	bool Read(int disk_no, int sector_offset, int num_sectors, char *buf)
		if !DiskInfo[disk_no].isAvailable
			return false
		//DrawString(0,24,"MAtaRead")
		SetDiskAdd(disk_no)
		//printh(&IOBase,2)
		// num_sectors=1...
		outportb(IOBase + 0x206, 0x0a)
	
		char status


		if DiskInfo[disk_no].isAtapi
			nil
			/*
			/*status=inportb(AtaIOBase+7)
			DrawHex(20,24,&status,1)
			status=inportb(AtaIOBase+1)
			DrawHex(23,24,&status,1)
			status=inportb(AtaIOCtrl)
			DrawHex(26,24,&status,1)
			WaitReturn()*/
			
			wait_status(0x88, 0)
			outportb(IOBase + 7, 0x08) // Soft Reset
			wait_400_ns()

			// CommandPacket
			atapi_buffer[0]=0xa8 // Read
			atapi_buffer[1]=0x00
			atapi_buffer[2]=i2c(sector_offset>>24) // LBA 24..31
			atapi_buffer[3]=i2c(sector_offset>>16) // 16..23
			atapi_buffer[4]=i2c(sector_offset>>8) // 8..15
			atapi_buffer[5]=i2c(sector_offset) // 0..7
			atapi_buffer[6]=0x00
			atapi_buffer[7]=0x00
			atapi_buffer[8]=0x00
			atapi_buffer[9]=i2c(num_sectors) // NumSectors
			atapi_buffer[10]=0x00
			atapi_buffer[11]=0x00
		
			//wait_status(AtaMaskBusy | AtaMaskData,0)
			wait_status(0x88,0)

			// dem ATA-Controller sagen, wir wollen ein ATAPI-Paket senden
			outportb(IOBase+1, 0 ) // Features
			outportb(IOBase+2, 0 )
			outportb(IOBase+3, 0 )
			outportb(IOBase+4, 0 )
			outportb(IOBase+5, 0 )
			outportb(IOBase+6, MSMask | 0x40 ) // H0 ...+LBA
			outportb(IOBase+7, 0xa0 ) // Packet
			wait_400_ns()

			//ata_wait_status(AtaMaskBusy,0)

			//ata_wait_status(0x88,AtaMaskData)
			wait_status(MaskData,AtaMaskData)

			/*status=inportb(AtaIOBase+7)
			DrawHex(50,15,&status,1)
			status=inportb(AtaIOBase+1)
			DrawHex(50,16,&status,1)
			status=inportb(AtaIOCtrl)
			DrawHex(50,17,&status,1)*/
		
		
			int abdw[0]*
			abdw=&atapi_buffer
			outportd(AtaIOBase,abdw[0])
			outportd(AtaIOBase,abdw[1])
			outportd(AtaIOBase,abdw[2])*/
		else
			outportb(IOCtrl, 0x0a) // ?+NoInt
			wait_400_ns()
			wait_status(AtaMaskBusy, 0)

			outportb(IOBase+1, 0) // Features
			outportb(IOBase+2, num_sectors) // NumSectors
 			outportb(IOBase+3, sector_offset) // S0
 			outportb(IOBase+4, sector_offset >> 8) // C0
			outportb(IOBase+5, sector_offset >> 16)
			outportb(IOBase+6, sector_offset >> 24 | MSMask | 0x40 ) // H0 ...+LBA
			outportb(IOBase+7, 0x20 ) // ReadSector
		wait_400_ns()

		wait_status(0x88, AtaMaskData)
		//wait_status(AtaMaskData | AtaMaskBusy,AtaMaskData)
		wait_400_ns()

		BufferDW = buf
	
		if DiskInfo[disk_no].isAtapi
			//prints("Lese...")
			status=inportb(IOBase+7)
			//printh(&status,1)
			status=inportb(IOBase+1)
			//printh(&status,1)
			status=inportb(IOCtrl)
			//printh(&status,1)
		
			int read=0
			while read<512 // 2048b
		
				int byte_cnt = inportb(IOBase + 5) * 256 + inportb(IOBase + 4)
				printi(byte_cnt)
				byte_cnt=20
		
				int dw_cnt=byte_cnt/4
				int n
				for n, 0, dw_cnt
					BufferDW[n]=inportd(IOBase)
				printh(buf,20)
				read+=dw_cnt
		else
			for n, 0, 128 // 512b
				BufferDW[n] = inportd(IOBase)

		status=inportb(IOBase+7)
		//printh(&status,1)
		status=inportb(IOBase+1)
		//printh(&status,1)
		status=inportb(IOCtrl)
		//printh(&status,1)

		return true

AtaData Ata


class PartitionData
	int offset, size
	char type
	bool active
	
PartitionData Partition[4]
int CurrentPartition

void ReadPartitions(int disk_no)
	// mbr lesen
	Ata.Read(disk_no,0,1,&Ata.Buffer)
	//MountPartition=false
	for int n, 0, 4
		PartitionData *p = &Partition[n]
		int *offset = &Ata.Buffer[454+n*16]
		p.offset = *offset
		int *size = &Ata.Buffer[458+n*16]
		p.size = *size
		p.type = Ata.Buffer[450+n*16]
		p.active = (Ata.Buffer[446+n*16] == 0x80)
	/*for n, 0, 512
		DrawHex(n*3,2,&AtaBuffer[n],1)*/
		
void ShowPartitions()
	prints("Primaere Partitionen:     Offset   Groesse\n")
	for int n, 0, 4
		PartitionData *p = &Partition[n]
		prints("/dev/hda")
		printi(n + 1)
		if (p.type != 0x00) and (p.size > 0)
			TextPos = 60
			if p.active
				prints("(aktiv)")
			TextPos = 27
			printi(p.offset)
			TextPos = 36
			printi(p.size)
			TextPos = 50
			if p.type == 0x83
				prints("Linux")
			else if p.type == 0x20
				prints("MichiFS")
			else if p.type == 0x0c
				prints("Fat 32")
			else if p.type == 0x0e
				prints("Fat 16")
			else if p.type == 0x07
				prints("NTFS")
			else if p.type == 0x0f
				prints("Erweitert...")
			else
				printh(&p.type, 1)
		else
			TextPos = 50
			prints("---")
		prints("\n")

//--------------------------------------------------------------
// Dateisystem

const int FILE_TYPE_FILE = 0
const int FILE_TYPE_DIR = 1
const int FILE_TYPE_DEVICE = 8

class FileEntry
	cstring name
	int type
	int size
	int offset
	FileEntry *next
	FileEntry *first_sub
	
	void add(FileEntry *e)
		if first_sub
			prints("add nx ")
			prints(e.name)
			prints("-")
			prints(name)
			FileEntry *i = first_sub
			while i.next
				i = i.next
			prints("-")
			prints(i.name)
			prints("\n")
			i.next = e
		else
			prints("add fs ")
			prints(e.name)
			prints("-")
			prints(name)
			prints("\n")
			first_sub = e
	
	void show()
		printi(type)
		prints(" ")
		prints(name)
		prints("\n")
		FileEntry *e = first_sub
		while e
			prints("    ")
			printi(e.type)
			prints(" ")
			prints(e.name)
			prints("\n")
			e = e.next
	FileEntry *get_sub(cstring sname)
		FileEntry *e = first_sub
		while e
			if strcmp(&sname, &e.name) == 0
				return e
			e = e.next
		return nil

class FileSystemData
	FileEntry list[256] // TODO: dynamic memory
	int list_size
	FileEntry *root
	
	FileEntry *add(cstring name, int type, FileEntry *parent)
		FileEntry *e = &list[list_size]
		list_size ++
		strcpy(&e.name, &name)
		e.type = type
		e.next = nil
		e.first_sub = nil
		if parent
			parent.add(e)
		return e
	
	void Init()
		list_size = 0
		root = add("-root-", FILE_TYPE_DIR, nil)
		FileEntry *dev = add("dev", FILE_TYPE_DIR, root)
		add("a", FILE_TYPE_FILE, root)
		add("b", FILE_TYPE_DEVICE, dev)
	
	FileEntry *get(cstring path)
		if path[0] != '/'
			return nil
		if path[1] == 0
			return root
		strcpy(&path, &path[1])
		cstring name
		for int i, 0, 256
			if (path[i] == '/') or (path[i] == 0)
				name[i] = 0
				break
			name[i] = path[i]
		FileEntry *e = root
		return e

FileSystemData FileSystem

void main()
	read_data_from_init()
	etm_init()
	
	prints("Willkommen zu Eusebius 0.2.0   (c) by MichiSoft TM 2013\n")
	prints("Speicher: ")
	printi(MemorySize)
	prints("k\n")
	
	Ata.Init()
	ReadPartitions(0)
	ShowPartitions()
	
	FileSystem.Init()
	FileEntry *e = FileSystem.root.get_sub("a")//("/a")
	printh(&e, 4)
	if e
		e.show()
	//FileSystem.root.show()
	
	while true
		nil

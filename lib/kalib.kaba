const int MALLOC_OFFSET = 0x00b00000
const int MALLOC_STOPPER = 8
const int MALLOC_SMALL_SIZE = 8
const int MALLOC_SMALL_NUM = 4096*16

const int O_RDONLY = 1
const int O_WRONLY = 2
const int O_RDWR = 3
const int O_APPEND = 16
const int O_CREATE = 32
const int O_NONBLOCK = 64
const int O_TRUNC = 128
const int EWOULDBLOCK = 128

const int SEEK_SET = 1
const int SEEK_CUR = 2
const int SEEK_END = 3

int stdin, stdout

int lib_error
bool __free_error__
bool lib_mem_debug
bool lib_print_endl

int __temp_i__, __temp_i2__, __temp_i3__
float __temp_f__
void* __temp_p__, __temp_p2__

int _p2i(void *p)
	int* i = &p
	return *i

//class PointerWrapper
//	void *p
	
void *_i2p(int i)
//	PointerWrapper *p = &i
//	return p.p
	__temp_i__ = i
	asm{
		mov eax, __temp_i__
		mov __temp_p__, eax
	}
	return __temp_p__


void _s2cs(string s, cstring cs)
	for i in 0:s.num
		cs[i] = s[i]
	cs[s.num] = 0

void _cs2s(cstring cs, lib__string s)
	s.clear()
	for i in 0:255
		if cs[i] == 0
			return
		s.add(cs[i])

lib__string cs2s(cstring cs)
	lib__string s
	_cs2s(cs, s)
	return s

// ["aa", "bb"] -> "aa\0bb\0\0"
void sa2cs(string[] a, cstring cs)
	int n = 0
	for k in 0:a.num
		for i in 0:a[k].num
			cs[n] = a[k][i]
			n ++
		cs[n] = 0
		n ++
	cs[n] = 0


//--------------------------------------------------------------------------
// system calls

bool exit(int r)
	__temp_i__ = r
	asm{
		mov eax, 0x00000001
		mov ebx, __temp_i__
		int 0x80
		mov lib_error, eax
	}
	return lib_error == 0

int brk(int size)
	__temp_i__ = size
	asm{
		mov eax, 0x0000002d
		mov ebx, __temp_i__
		int 0x80
		mov __temp_i__, eax
	}
	return __temp_i__
	
int fork()
	asm{
		mov eax, 0x00000002
		int 0x80
		mov __temp_i__, eax
	}
	if __temp_i__ == 0
		stdout = open("/dev/tty", O_RDONLY)
	return __temp_i__

int open(string filename, int flags)
	cstring tt
	_s2cs(filename, tt)
	__temp_p__ = &tt
	__temp_i__ = flags
	asm{
		mov eax, 0x00000005
		mov ebx, __temp_p__
		mov ecx, __temp_i__
		int 0x80
		mov __temp_i__, eax
	}
	return __temp_i__

int create(string filename)
	cstring tt
	_s2cs(filename, tt)
	__temp_p__ = &tt
	asm{
		mov eax, 0x00000008
		mov ebx, __temp_p__
		mov ecx, 0x00000000
		int 0x80
		mov __temp_i__, eax
	}
	return __temp_i__
	
bool close(int h)
	__temp_i__ = h
	asm{
		mov eax, 0x00000006
		mov ebx, __temp_i__
		int 0x80
		mov lib_error, eax
	}
	return lib_error == 0

int read(int h, void *buf, int size)
	__temp_i__ = h
	__temp_i2__ = size
	__temp_p__ = buf
	asm{
		mov eax, 0x00000003
		mov ebx, __temp_i__
		mov ecx, __temp_p__
		mov edx, __temp_i2__
		int 0x80
		mov __temp_i3__, eax
	}
	return __temp_i3__
	
int write(int h, void *buf, int size)
	__temp_i__ = h
	__temp_i2__ = size
	__temp_p__ = buf
	asm{
		mov eax, 0x00000004
		mov ebx, __temp_i__
		mov ecx, __temp_p__
		mov edx, __temp_i2__
		int 0x80
		mov __temp_i3__, eax
	}
	return __temp_i3__

int seek(int h, int pos, int mode)
	__temp_i__ = h
	__temp_i2__ = pos
	__temp_i3__ = mode
	asm{
		mov eax, 0x00000013
		mov ebx, __temp_i__
		mov ecx, __temp_i2__
		mov edx, __temp_i3__
		int 0x80
		mov __temp_i3__, eax
	}
	return __temp_i3__


bool mkdir(string filename)
	cstring tt
	_s2cs(filename, tt)
	__temp_p__ = &tt
	asm{
		mov eax, 0x00000027
		mov ebx, __temp_p__
		int 0x80
		mov lib_error, eax
	}
	return lib_error == 0

bool rmdir(string filename)
	cstring tt
	_s2cs(filename, tt)
	__temp_p__ = &tt
	asm{
		mov eax, 0x00000028
		mov ebx, __temp_p__
		int 0x80
		mov lib_error, eax
	}
	return lib_error == 0

bool getdents(int h, void *buf)//lib__DirEntry)
	__temp_i__ = h
	__temp_i2__ = 1
	__temp_p__ = buf
	asm{
		mov eax, 0x0000008d
		mov ebx, __temp_i__
		mov ecx, __temp_p__
		mov edx, __temp_i2__
		int 0x80
		mov lib_error, eax
	}
	return lib_error > 0

int dup(int h)
	__temp_i__ = h
	asm{
		mov eax, 0x00000029
		mov ebx, __temp_i__
		int 0x80
		mov __temp_i__, eax
	}
	return __temp_i__

bool pipe(int[2] h)
	__temp_p__ = &h
	asm{
		mov eax, 0x0000002a
		mov ebx, __temp_p__
		int 0x80
		mov lib_error, eax
	}
	return lib_error == 0

int fcntl(int h, int op, int param)
	__temp_i__ = h
	__temp_i2__ = op
	__temp_i3__ = param
	asm{
		mov eax, 0x00000033
		mov ebx, __temp_i__
		mov ecx, __temp_i2__
		mov edx, __temp_i3__
		int 0x80
		mov __temp_i__, eax
	}
	return __temp_i__

bool mkfifo(string filename)
	cstring tt
	_s2cs(filename, tt)
	__temp_p__ = &tt
	asm{
		mov eax, 0x0000000e
		mov ebx, __temp_p__
		int 0x80
		mov lib_error, eax
	}
	return lib_error == 0

bool unlink(string filename)
	cstring tt
	_s2cs(filename, tt)
	__temp_p__ = &tt
	asm{
		mov eax, 0x0000000a
		mov ebx, __temp_p__
		int 0x80
		mov lib_error, eax
	}
	return lib_error == 0

int getpid()
	asm{
		mov eax, 0x00000014
		int 0x80
		mov __temp_i__, eax
	}
	return __temp_i__

bool sigaction(int sig, void *f)
	__temp_i__ = sig
	__temp_p__ = f
	asm{
		mov eax, 0x00000043
		mov ebx, __temp_i__
		mov ecx, __temp_p__
		int 0x80
		mov lib_error, eax
	}
	return lib_error == 0
	
int waitpid(int pid, void *status, bool block)
	__temp_i__ = pid
	__temp_p__ = status
	__temp_i2__ = 0
	if !block
		__temp_i2__ = 1
	asm{
		mov eax, 0x00000007
		mov ebx, __temp_i__
		mov ecx, __temp_p__
		mov edx, __temp_i2__
		int 0x80
		mov __temp_i3__, eax
	}
	return __temp_i3__
	
bool kill(int pid, int signal)
	__temp_i__ = pid
	__temp_i2__ = signal
	asm{
		mov eax, 0x00000025
		mov ebx, __temp_i__
		mov ecx, __temp_i2__
		int 0x80
		mov lib_error, eax
	}
	return lib_error == 0

bool chdir(string dir)
	cstring tt
	_s2cs(dir, tt)
	__temp_p__ = &tt
	asm{
		mov eax, 0x0000000c
		mov ebx, __temp_p__
		int 0x80
		mov lib_error, eax
	}
	return lib_error == 0

lib__string getcwd()
	cstring tt
	__temp_p__ = &tt
	asm{
		mov eax, 0x000000b7
		mov ebx, __temp_p__
		mov ecx, 0x00000100
		int 0x80
		mov lib_error, eax
	}
	lib__string r
	_cs2s(tt, r)
	return r

int execute(string[] arg, int fd_in, int fd_out)
	cstring tt_arg
	sa2cs(arg, tt_arg)
	__temp_p__ = &tt_arg
	__temp_i__ = fd_in
	__temp_i2__ = fd_out
	asm{
		mov eax, 0x0000000b
		mov ebx, __temp_p__
		mov ecx, __temp_i__
		mov edx, __temp_i2__
		int 0x80
		mov lib_error, eax
	}
	return lib_error

int shmget(int key, int size, int flags)
	__temp_i__ = key
	__temp_i2__ = size
	__temp_i3__ = flags
	asm{
		mov eax, 0x00000075 // ipc
		mov ebx, 0x0000000b
		mov ecx, __temp_i__
		mov edx, __temp_i2__
		mov esi, __temp_i3__
		int 0x80
		mov __temp_i3__, eax
	}
	return __temp_i3__

void* shmat(int id, int flags)
	void *p
	__temp_i__ = id
	__temp_p__ = &p
	__temp_i2__ = flags
	asm{
		mov eax, 0x00000075 // ipc
		mov ebx, 0x00000009
		mov ecx, __temp_i__
		mov edx, __temp_p__
		mov esi, __temp_i2__
		int 0x80
		mov lib_error, eax
	}
	if lib_error < 0 and lib_error > - 1024
		return nil
	return p
	
bool shmdt(void* addr)
	__temp_p__ = addr
	asm{
		mov eax, 0x00000075 // ipc
		mov ebx, 0x0000000a
		mov ecx, __temp_p__
		int 0x80
		mov lib_error, eax
	}
	return lib_error == 0
	
bool waitmsg()
	asm{
		mov eax, 0x00000075 // ipc
		mov ebx, 0x000003e9 // 1001 = wait-msg
		int 0x80
		mov lib_error, eax
	}
	return lib_error == 0
	
bool yield(int pid)
	__temp_i__ = pid
	asm{
		mov eax, 0x00000075 // ipc
		mov ebx, 0x000003ea // 1002 = yield
		mov ecx, __temp_i__
		int 0x80
		mov lib_error, eax
	}
	return lib_error == 0

bool sysinfo(void *buf)
	__temp_p__ = buf
	asm{
		mov eax, 0x00000074
		mov ebx, __temp_p__
		int 0x80
		mov lib_error, eax
	}
	return lib_error == 0

bool taskinfo(int pid, void *buf)
	__temp_i__ = pid
	__temp_p__ = buf
	asm{
		mov eax, 0x00002005
		mov ebx, __temp_i__
		mov ecx, __temp_p__
		int 0x80
		mov lib_error, eax
	}
	return lib_error == 0

bool uname(void *buf)
	__temp_p__ = buf
	asm{
		mov eax, 0x0000007a
		mov ebx, __temp_p__
		int 0x80
		mov lib_error, eax
	}
	return lib_error == 0

bool time(void *buf)
	__temp_p__ = buf
	asm{
		mov eax, 0x00000019
		mov ebx, __temp_p__
		int 0x80
		mov lib_error, eax
	}
	return lib_error == 0

bool nanosleep(void *buf, void *buf2)
	__temp_p__ = buf
	asm{
		mov eax, 0x000000a2
		mov ebx, __temp_p__
		int 0x80
		mov lib_error, eax
	}
	return lib_error == 0

bool sleep(int sec)
	int[2] tv
	tv[0] = sec
	tv[1] = 0
	return nanosleep(&tv, nil)

bool usleep(int usec)
	int[2] tv
	tv[0] = usec / 1000000
	tv[1] = (usec % 1000000) * 1000
	return nanosleep(&tv, nil)

bool sched_yield(int pid)
	__temp_i__ = pid
	asm{
		mov eax, 0x0000009e
		mov ebx, __temp_i__
		int 0x80
		mov lib_error, eax
	}
	return lib_error == 0
	
void kprint(string s)
	__temp_p__ = &s[0]
	__temp_i__ = s.num
	asm{
		mov eax, 0x00002002
		mov ebx, __temp_p__
		mov ecx, __temp_i__
		int 0x80
	}
	
void kprinti(int i)
	__temp_i__ = i
	asm{
		mov eax, 0x00002003
		mov ebx, __temp_i__
		int 0x80
	}
	
bool mapirq(int irq, int signal)
	__temp_i__ = irq
	__temp_i2__ = signal
	asm{
		mov eax, 0x00002007
		mov ebx, __temp_i__
		mov ecx, __temp_i2__
		int 0x80
		mov lib_error, eax
	}
	return lib_error == 0


int sys_socket(int cmd, int p1, int p2)
	__temp_i__ = cmd
	__temp_i2__ = p1
	__temp_i3__ = p2
	asm{
		mov eax, 0x00000066
		mov ebx, __temp_i__
		mov ecx, __temp_i2__
		mov edx, __temp_i3__
		int 0x80
		mov lib_error, eax
	}
	return lib_error

int socket(int type)
	return sys_socket(1, type, 0)

bool bind(int fd, int port)
	return sys_socket(2, fd, port) == 0

bool connect(int fd, int port)
	return sys_socket(3, fd, port) == 0

bool listen(int fd)
	return sys_socket(4, fd, 0) == 0

int accept(int fd)
	return sys_socket(5, fd, 0)

void get_args(lib__string@list arg)
	cstring cs
	__temp_p__ = &cs
	asm{
		mov eax, 0x00002001
		mov ebx, __temp_p__
		int 0x80
	}
	lib__string s
	
	int p = 0
	for i in 0:250
		if cs[i] == 0
			if s.num == 0
				break
			arg.add(s)
			s.clear()
			p = i + 1
		else
			s.add(cs[i])


//--------------------------------------------------------------------------
// lib

int lib__clampi(int i, int min, int max)
	if i > max
		return max
	if i < min
		return min
	return i

int lib__loopi(int i, int min, int max)
	int d = max - min + 1
	if i < min
		int n = ( (min-i-1) / d ) + 1
		return i + d * n
	if i > max
		int n = ( (i-max-1) / d ) + 1
		return i - d * n
	return i

float lib__max(float a, float b)
	if a > b
		return a
	return b

//--------------------------------------------------------------------------
// memory management


void memcpy(void* _dest, void* _source, int size)
	char[0]* dest = _dest
	char[0]* source = _source
	for i in 0:size
		dest[i] = source[i]
		
void prints(cstring s)
	__temp_p__ = &s
	asm{
		mov eax, 0x00002002
		mov ebx, __temp_p__
		int 0x80
	}


int MemHeapAllocated // includes overhead of all headers

class MallocHeader
	int size // header + payload
	int magic
	MallocHeader *next
	MallocHeader *prev
	void *after()
		char[0]* pp = self
		return &pp[size]
	void *payload()
		char[0]* pp = self
		return &pp[sizeof(MallocHeader)]
MallocHeader *malloc_first_free
MallocHeader *malloc_end_marker
int cur_break_value

// heap is split into a (hole-free) list of blocks
// blocks are either free or allocated
// free blocks form a doubly-linked list (no loop)
// allocated blocks are not linked

int _align8_(int size)
	if (size & 0x00000007) == 0
		return size
	return (size & 0xfffffff8) + 8


void* lib__@malloc(int size)
	if size <= MALLOC_SMALL_SIZE
		void *ppp = small_malloc()
		if ppp
			return ppp

	size = _align8_(size)
	if lib_mem_debug
		kprint(" [+")
		kprinti(size)
		kprint("] ")
	
	// account for the allocation header
	size += sizeof(MallocHeader)
	
	// find a free block big enough
	MallocHeader *cur = malloc_first_free
	while cur.next
		if size <= cur.size - sizeof(MallocHeader)
		
			// shrink free block
			cur.size -= size
			
			// create allocated block at (former) end of free block
			MallocHeader *hh = cur.after()
			hh.magic = 0x12345678
			hh.size = size
			hh.next = nil
			hh.prev = nil
			
			MemHeapAllocated += size
			if lib_mem_debug
				kprint(" ")
				kprinti(_p2i(hh.payload()))
			memcheck()
			/*if lib_mem_debug
				kprint(">")
				kprinti(_p2i(hh.payload()))*/
			return hh.payload()
		cur = cur.next

	
	MallocHeader *last_before_end_new = _i2p(cur_break_value - sizeof(MallocHeader) - MALLOC_STOPPER)
 	
	// request more memory from kernel
	int new_break_value = cur_break_value + size + sizeof(MallocHeader) + 1024
	if lib_mem_debug
		kprint("  BREAK ")
		kprinti(cur_break_value)
		kprint(" - ")
		kprinti(new_break_value)
		kprint("  ")
	int r = brk(new_break_value)
	if r < 0
		__lib_fatal__("malloc/brk()")
	cur_break_value = r
	
	// get the pointer now... we might overwrite the end marker...
	MallocHeader *last_before_end_old = malloc_end_marker.prev
	last_before_end_old.next = last_before_end_new
	last_before_end_new.prev = last_before_end_old
	last_before_end_new.magic = 0x1234567
	
	
	// add allocated block
	MallocHeader *hh = _i2p(cur_break_value - size - sizeof(MallocHeader) - MALLOC_STOPPER)
	hh.size = size
	hh.next = nil
	hh.prev = nil
	
	// resize last free block
	last_before_end_new.size = _p2i(hh) - _p2i(last_before_end_new)
	
	// create new end marker
	malloc_end_marker = _i2p(cur_break_value - sizeof(MallocHeader))
	malloc_end_marker.size = sizeof(MallocHeader)
	malloc_end_marker.next = nil
	malloc_end_marker.prev = last_before_end_new
	last_before_end_new.next = malloc_end_marker
	
	return hh.payload()

void _cleanup(MallocHeader *h)
	if h.after() == h.next
		MemHeapAllocated -= sizeof(MallocHeader)
		if lib_mem_debug
			kprint(" merge after ")
		h.size += h.next.size
		h.next = h.next.next
		h.next.prev = h
	if h.prev.after() == h
		MemHeapAllocated -= sizeof(MallocHeader)
		if lib_mem_debug
			kprint(" merge before ")
		h.prev.size += h.size
		h.next.prev = h.prev
		h.prev.next = h.next

void lib__@free(void *p)
	if !p
		return
	int index = small_malloc_no(p)
	if index >= 0
		small_free(index)
		return
	int ip = _p2i(p)
	if lib_mem_debug
		kprint(" free ")
		kprinti(ip)
	
	MallocHeader *hh = _i2p(ip - sizeof(MallocHeader))
	if hh.magic != 0x12345678
		kprint(" free___:  ")
		kprinti(ip)
		__lib_fatal__("evil free(1)")
	
	if lib_mem_debug
		kprint(" ")
		kprinti(hh.size)
	
	// find last free window before p
	MallocHeader *cur = malloc_first_free
	while cur.next
		if (ip >= _p2i(cur)) and (ip < _p2i(cur) + cur.size)
			/*prints("\n")
			printi(_p2i(cur))
			prints("  ")
			printi(cur.size)
			
			panic("double free")*/
		//	__lib_free_error__()
			__lib_fatal__("double free()")
		if ip < _p2i(cur.next)
			// turn allocated block into a free one
			hh.magic = 0
			
			if lib_mem_debug
				kprinti(hh.size)
			MemHeapAllocated -= hh.size - sizeof(MallocHeader)
			
			// ..by linking it to its neighbors
			hh.next = cur.next
			cur.next.prev = hh
			hh.prev = cur
			cur.next = hh
			
			_cleanup(hh)
			memcheck()
			if lib_mem_debug
				kprint(">")
			return
		cur = cur.next
	__lib_fatal__( "invalid call to free()")



void memcheck()
	MallocHeader *h = malloc_first_free
	while h.next
		if _p2i(h.next) < _p2i(h) + h.size
			__lib_fatal__("memcheck: h.next<h+size")
		if h != h.next.prev
			__lib_fatal__("memcheck: h!=h.next.prev")
		h = h.next

/*void* realloc(void* po, int old_size, int new_size)
	void *pn = malloc(new_size)
	int n = old_size
	if new_size < n
		n = new_size
	memcpy(pn, po, n)
	free(po)
	return pn*/
// double-linked list of free fields


void __lib_fatal__(string s)
	lib__print("\n\nkalib: ")
	lib__print(s)
	exit(-1)

void __lib_free_error__()
	__free_error__ = true
	lib__print("\n\nkalib: invalid call to free()")
	exit(-1)


void *lib__@realloc(void *p, int size)
	MallocHeader[0]* hp = p
	MallocHeader *h = &hp[-1]
	int old_size
	int sm_index = small_malloc_no(p)
	if sm_index >= 0
		old_size = MALLOC_SMALL_SIZE
	else
		old_size = h.size - sizeof(MallocHeader)
	void *pp = lib__@malloc(size)
	
	if size < old_size
		old_size = size
	
	memcpy(pp, p, old_size)
	lib__@free(p)
	return pp

class MallocSmallBlock
	int[MALLOC_SMALL_NUM / 32] mask
	char[MALLOC_SMALL_SIZE * MALLOC_SMALL_NUM] buf
	int delta // address translation...
	int full_below // #masks
	
	
	void init()
		for i in 0:(MALLOC_SMALL_NUM/32)
			mask[i] = 0
		delta = _p2i(&buf)
		full_below = 0
	
	void* alloc()
		//kprint " +sm "
		for i in full_below:(MALLOC_SMALL_NUM/32)
			if mask[i] == 0xffffffff
				continue
			for j in 0:32
				int m = 1 << j
				if (mask[i] & m) == 0
					full_below = i
					mask[i] = mask[i] | m
					int n = i * 32 + j
					//kprinti(n)
					//kprint(" : ")
					void *p = &buf[n * MALLOC_SMALL_SIZE]
					//kprinti _p2i(p)
					return p
		//kprint " --[XXX]--"
		return nil
	
	int to_index(void *p)
		int ip = _p2i(p)
		/*kprint(" - ")
		kprinti(ip)
		kprint(" : ")
		kprinti((ip - delta) / MALLOC_SMALL_SIZE)*/
		return (ip - delta) / MALLOC_SMALL_SIZE
	
	void free(int index)
		//kprint " -sm "
		int _mask = 1 << (index & 31)
		int mn = index >> 5
		if (mask[mn] & _mask) != 0
			mask[mn] -= _mask
		if mn < full_below
			full_below = mn

MallocSmallBlock *malloc_small_block

void* small_malloc()
	return malloc_small_block.alloc()

void small_free(int n)
	malloc_small_block.free(n)

int small_malloc_no(void *p)
	int index = malloc_small_block.to_index(p)
	if index < 0 or index >= MALLOC_SMALL_NUM
		return -1
	return index

//--------------------------------------------------------------------------
// arrays

class lib__@DynamicArray
	cstring *data
	int num
	int allocated
	int element_size
	void __mem_init__(int _element_size)
		data = nil
		num = 0
		allocated = 0
		element_size = _element_size
	void __mem_clear__()
		if allocated > 0
			lib__@free(data)
		data = nil
		allocated = 0
		num = 0

	void reserve(int size)
		if allocated == 0
			if size > 0
				allocated = size * element_size
					data = lib__@malloc(allocated)
		else if size * element_size > allocated
			allocated = size * element_size * 2
			void *data0 = data
			data = lib__@realloc(data, allocated)
		else if size == 0
			__mem_clear__()

	void __mem_resize__(int size)
		if size > num
			reserve(size)
			//memset((char*)data + num * element_size, 0, (size - num) * element_size);
		num = size

	void __mem_remove__(int index)
		if index < 0 or index >= num
			return
		for i in index*element_size : (num-1)*element_size
			data[i] = data[i+element_size]
		__mem_resize__(num - 1)
		
	void __assign__(lib__@DynamicArray a)
		__mem_resize__(a.num)
		memcpy(data, a.data, num * element_size)
		num = 0

class lib__string extends lib__@DynamicArray
	override char[0]* data
	override void __init__()
		__mem_init__(1)
	override void __delete__()
		__mem_clear__()
	void resize(int size)
		__mem_resize__(size)
	void clear()
		__mem_clear__()
	void add(char c)
		__mem_resize__(num + 1)
		data[num - 1] = c
	/*void insert(int index, char c)
		__mem_resize__(num + 1)
		for i in 1:num-index-1
			data[num - i] = data[num - i - 1]
		data[index] = c*/
	void remove(int index)
		__mem_remove__(index)
	void __assign__(lib__string o)
		__mem_resize__(o.num)
		memcpy(data, o.data, num)
	void __iadd__(lib__string o)
		int n0 = num
		__mem_resize__(num + o.num)
		memcpy(&data[n0], o.data, o.num)
	lib__string __add__(lib__string o)
		lib__string r
		r = *self
		r += o
		return r
			
	lib__string substr(int start, int length)
		lib__string r
		if start >= num
			return r
		if start < 0
			// start from the end
			start = num + start
			if start < 0
				return r
		if length < 0
			length = num - start + length + 1
		if start + length > num
			length = num - start
		if length > 0
			r.resize(length)
			memcpy(r.data, &data[start], length)
		return r

	lib__string head(int size)
		return substr(0, size)

	lib__string tail(int size)
		return substr(num - size, size)

	int find(lib__string s, int start)
		for i in start : num - s.num
			bool ok = true
			for j in 0:s.num
				if data[i + j] != s.data[j]
					ok = false
					break
			if ok
				return i
		return -1
		
	int compare(lib__string s)
		int n = num
		if s.num < num
			n = s.num
		for i in 0:n
			int a = data[i]
			int b = s.data[i]
			if a != b
				return a - b
		return num - s.num
		
	bool __eq__(lib__string s)
		return compare(s) == 0
	bool __neq__(lib__string s)
		return compare(s) != 0
	bool __ne__(lib__string s)
		return compare(s) != 0
	bool __lt__(lib__string s)
		return compare(s) < 0
	bool __gt__(lib__string s)
		return compare(s) > 0

/*int string::rfind(const string &s, int start) const
{
	char *b = (char*)data;
	char *aa = (char*)s.data;
	if (start < 0)
		start = num - 1;
	for (int i=start;i>=0;i--){
		bool ok = true;
		for (int j=0;j<s.num;j++)
			if (b[i + j] != aa[j]){
				ok = false;
				break;
			}
		if (ok)
			return i;
	}
	return -1;
}

int string::compare(const string &s) const
{
	char *a = (char*)data;
	int n = num;
	if (num > s.num)
		n = s.num;
	for (int i=0;i<n;i++){
		if (s[i] != a[i])
			return (int)(unsigned char)a[i] - (int)(unsigned char)s[i];
	}
	return num - s.num;
}

inline int ichar(char a)
{
	if ((a >= 'A') && (a <= 'Z'))
		return (int)(unsigned char)a - (int)(unsigned char)'A' + (int)(unsigned char)'a';
	return (int)(unsigned char)a;
}

int string::icompare(const string &s) const
{
	char *a = (char*)data;
	int n = num;
	if (num > s.num)
		n = s.num;
	for (int i=0;i<n;i++){
		if (ichar(s[i]) != ichar(a[i]))
			return ichar(a[i]) - ichar(s[i]);
	}
	return num - s.num;
}*/

	lib__string reverse()
		lib__string r
		r.resize(num)
		for i in 0:num
			r.data[num - i - 1] = data[i]
		return r

	void replace0(int start, int length, lib__string str)
		if start + length > num
			return
		int d = str.num - length
		if d > 0
			resize(num + d)
			//for (int i=num-1;i>=start+length;i--)
			int j = num-1
			while j >= start+length
				data[j] = data[j - d]
				j --
		memcpy(&data[start], str.data, str.num)
		if d < 0
			for i in start + str.num : num + d
				data[i] = data[i - d]
			resize(num + d)

	lib__string replace(lib__string sub, lib__string by)
		lib__string r = *self
		int i = r.find(sub, 0)
		while i >= 0
			r.replace0(i, sub.num, by)
			i = r.find(sub, i + by.num)
		return r

	lib__string lower()
		lib__string r = *self
		for i in 0:num
			if (data[i] >= 'A') and (data[i] <= 'Z')
				r.data[i] += 'a' - 'A'
		return r

	lib__string upper()
		lib__string r = *self
		for i in 0:num
			if (data[i] >= 'a') and (data[i] <= 'z')
				r.data[i] += 'A' - 'a'
		return r
		

	lib__string@list explode(lib__string s)
		lib__string@list r

		int pos = 0
		while true
			int pos2 = find(s, pos)
			if pos2 < 0
				break

			r.add(substr(pos, pos2 - pos))

			pos = s.num + pos2
		if (r.num > 0) or (pos < num)
			r.add(substr(pos, num - pos))
		return r
		
	lib__string hex(bool inverted)
		lib__string ttt
		for i in 0:num
			int d = data[i]
			int d1 = (d>>4)
			int d2 = (d&15)
			if d1 < 10
				ttt.add(d1+48)
			else
				ttt.add(d1+87)
			if d2<10
				ttt.add(d2+48)
			else
				ttt.add(d2+87)
			if i == num-1
				ttt.add(' ')
			else
				ttt.add('.')
		return ttt
	
	int int()
		if num == 0
			return 0
		bool sign = (data[0] != '-')
		int r = 0
		int i0 = 0
		if !sign
			i0 = 1
		for i in i0:num
			int c = data[i]
			r = r * 10 + (c - 48)
		if !sign
			return -r
		return r
	
	float float()
		if num == 0
			return 0.0
		bool sign = (data[0] != '-')
		float r = 0.0
		int i0 = 0
		if !sign
			i0 = 1
		for i in i0:num
			int c = data[i]
			if c == '.'
				i0 = i + 1
				break
			r = r * 10.0 + (c - 48)
		float factor = 0.1
		for i in i0:num
			int c = data[i]
			r += (c - 48) * factor
			factor /= 10.0
		if !sign
			return -r
		return r

lib__string binary(void *p, int num)
	lib__string s
	s.num = num
	s.data = p
	return s

class lib__int@list extends lib__@DynamicArray
	override int[0]* data
	override void __init__()
		__mem_init__(sizeof(int))
	override void __delete__()
		clear()
	void clear()
		__mem_clear__()
	void resize(int size)
		if size > num
			reserve(size)
		num = size
	void add(int i)
		resize(num + 1)
		data[num - 1] = i
	void remove(int index)
		if (index < 0) or (index >= num)
			return
		for i in index : num - 1
			data[i] = data[i+1]
		resize(num - 1)
	void __assign__(lib__int@list o)
		resize(o.num)
		for i in 0:num
			data[i] = o.data[i]
	void sort()
		for i in 0:num
			for j in i:num
				if data[i]>data[j]
					int t = data[i]
					data[i] = data[j]
					data[j] = t

class lib__float@list extends lib__@DynamicArray
	override float[0]* data
	override void __init__()
		__mem_init__(sizeof(float))
	override void __delete__()
		clear()
	void clear()
		__mem_clear__()
	void resize(int size)
		if size > num
			reserve(size)
		num = size
	void add(int i)
		resize(num + 1)
		data[num - 1] = i
	void remove(int index)
		if (index < 0) or (index >= num)
			return
		for i in index : num - 1
			data[i] = data[i+1]
		resize(num - 1)
	void __assign__(lib__float@list o)
		resize(o.num)
		for i in 0:num
			data[i] = o.data[i]
	void sort()
		for i in 0:num
			for j in i:num
				if data[i]>data[j]
					int t = data[i]
					data[i] = data[j]
					data[j] = t

class lib__bool@list extends lib__@DynamicArray
	override bool[0]* data
	override void __init__()
		__mem_init__(sizeof(bool))
	override void __delete__()
		clear()
	void clear()
		__mem_clear__()
	void resize(int size)
		if size > num
			reserve(size)
		num = size
	void add(bool b)
		resize(num + 1)
		data[num - 1] = b
	void remove(int index)
		if (index < 0) or (index >= num)
			return
		for i in index : num - 1
			data[i] = data[i+1]
		resize(num - 1)
	void __assign__(lib__bool@list o)
		resize(o.num)
		for i in 0:num
			data[i] = o.data[i]

class lib__string@list extends lib__@DynamicArray
	override lib__string[0]* data
	override void __init__()
		__mem_init__(sizeof(lib__string))
	override void __delete__()
		for i in 0:num
			data[i].__delete__()
		//clear()
	void resize(int size)
		if size < num
			// shrink -> destruct
			for i in size:num
				data[i].__delete__()
		else if size > num
			reserve(size)
			for i in num:size
				data[i].__init__()
		num = size
	void add(lib__string s)
		resize(num + 1)
		data[num - 1] = s
	void __assign__(lib__string@list o)
		resize(o.num)
		for i in 0:num
			data[i] = o.data[i]
	void remove(int index)
		if (index < 0) or (index >= num)
			return
		for i in index : num - 1
			data[i] = data[i+1]
		resize(num - 1)
		//data[index].__clear__()
		//__mem_remove__(index)

	lib__string join(lib__string glue)
		lib__string r
		for i in 0:num
			if i > 0
				r += glue
			r += data[i]
		return r
	lib__string str()
		return lib__@sa2s(*self)

lib__string lib__@sa2s(lib__string@list a)
	lib__string r
	r.add('[')
	for i in 0:a.num
		if i > 0
			r.add(',')
		r.add('"')
		r += a.data[i]
		r.add('"')
	r.add(']')
	return r

lib__string lib__@i2s(int i)
	bool sign = i >= 0
	if !sign
		i = -i
	lib__string s
	while true
		s.add((i % 10) + 0x30)
		i /= 10
		if i == 0
			break
	if !sign
		s.add('-')
	return s.reverse()

int rand_state

int rand_next()
	rand_state = rand_state * 1664525 + 1013904223
	return rand_state & 0x00ffffff

void lib__rand_seed(int s)
	rand_state = s

float lib__rand(float m)
	return rand_next() * m / i2f(0x01000000)

int lib__randi(int m)
	return lib__rand(m)

class lib__int
	int i
	lib__string str()
		return lib__@i2s(i)

class lib__float
	float f
	lib__string str()
		return lib__@f2s(f, 6)

float lib__sin(float f)
	__temp_f__ = f
	asm{
		fld __temp_f__
		fsin
		fst __temp_f__
	}
	return __temp_f__

float lib__cos(float f)
	__temp_f__ = f
	asm{
		fld __temp_f__
		fcos
		fst __temp_f__
	}
	return __temp_f__

float lib__min(float a, float b)
	if a < b
		return a
	return b

float lib__max(float a, float b)
	if a > b
		return a
	return b

float lib__abs(float x)
	if x < 0
		return -x
	return x
	

int lib__clampi(int i, int min, int max)
	if max <= min
		return min
	if i > max
		return max
	if i < min
		return min
	return i

int lib_loopi(int i, int min, int max)
	if max <= min
		return min
	int d = max - min + 1
	if i < min
		int n= ( (min-i-1) / d ) + 1
		return i + d * n
	if i > max
		int n= ( (i-max-1) / d ) + 1
		return i - d * n
	return i



float lib__sqr(float f)
	return f * f

float lib__sqrt(float f)
	__temp_f__ = f
	asm{
		sqrtss xmm0, __temp_f__
		movss __temp_f__, xmm0
	}
	return __temp_f__

float lib__clamp(float f, float min, float max)
	if max < min
		return min
	if f > max
		return max
	if f < min
		return min
	return f

float lib__loop(float f, float min, float max)
	float d = max - min
	if f < min
		int n = i2f( (min-f) / d ) + 1
		return f + d * i2f(n)
	if f >= max
		int n= i2f( (f-max) / d ) + 1
		return f - d * i2f(n)
	return f

lib__string lib__@f2s(float f, int n)
	lib__string s
	
	if f < 0.0
		s.add('-')
		f = -f
	s += lib__@i2s(f)
	if n > 0
		s.add('.')
		int e = 1
		float fe = 1.0
		for i in 0:n
			e = e *10
			fe *= 10.0
		int after = f2i(f*fe) % e
		for i in 0:n
			e /= 10
			s.add(((after / e) % 10) + 0x30)
	return s

lib__string lib__p2s(void *p)
	lib__string r
	r.resize(sizeof(p))
	void *pp = &p
	memcpy(r.data, pp, sizeof(p))
	return r.hex(true)

lib__string lib__@b2s(bool b)
	lib__string r
	if b
		r.add('1')
	else
		r.add('0')
	return r

class lib__bool
	bool b
	lib__string str()
		return lib__@b2s(b)

lib__string lib__@ia2s(lib__int@list a)
	lib__string r
	r.add('[')
	for i in 0:a.num
		if i > 0
			r.add(',')
			r.add(' ')
		r += lib__@i2s(a.data[i])
	r.add(']')
	return r

lib__string lib__@fa2s(lib__float@list a)
	lib__string r
	r.add('[')
	for i in 0:a.num
		if i > 0
			r.add(',')
			r.add(' ')
		r += lib__@f2s(a.data[i], 6)
	r.add(']')
	return r

class lib__complex
	float x, y
	
	lib__string str()
		return _complex2s(*self)

lib__string _complex2s(lib__complex c)
	lib__string r
	r.add('(')
	r += lib__@f2s(c.x, 6)
	r.add(',')
	r.add(' ')
	r += lib__@f2s(c.y, 6)
	r.add(')')
	return r


class lib__complex@list extends lib__@DynamicArray
	override complex[0]* data
	override void __init__()
		__mem_init__(sizeof(complex))
	override void __delete__()
		clear()
	void clear()
		__mem_clear__()
	void resize(int size)
		if size > num
			reserve(size)
		num = size
	void add(complex c)
		resize(num + 1)
		data[num - 1] = c
	void remove(int index)
		if (index < 0) or (index >= num)
			return
		for i in index : num - 1
			data[i] = data[i+1]
		resize(num - 1)
	void __assign__(lib__complex@list o)
		resize(o.num)
		for i in 0:num
			data[i] = o.data[i]

void lib__print(string s)
	int done = 0
	while done < s.num
		int r = write(stdout, &s[done], s.num - done)
		if r == -EWOULDBLOCK
			continue
		if r > 0
			done += r
	if lib_print_endl
		int r = write(stdout, &0x0000000a, 1)



//--------------------------------------------------------------------------
// dir entry


class lib__DirEntry
	lib__string name
	int dddd, eee
	int size
	bool is_dir
	void __init__()
		name.__init__()
	void __assign__(lib__DirEntry o)
		name = o.name
		size = o.size
		is_dir = o.is_dir


class lib__DirEntry@list extends lib__@DynamicArray
	override lib__DirEntry[0]* data
	override void __init__()
		__mem_init__(sizeof(lib__DirEntry))
	override void __delete__()
		for i in 0:num
			data[i].__delete__()
		//clear()
	void resize(int size)
		if size < num
			// shrink -> destruct
			for i in size:num
				data[i].__delete__()
		else if size > num
			reserve(size)
			for i in num:size
				data[i].__init__()
		num = size
	void add(lib__DirEntry s)
		resize(num + 1)
		data[num - 1] = s
	void __assign__(lib__DirEntry@list o)
		resize(o.num)
		for i in 0:num
			data[i] = o.data[i]
	void swap(int i, int j)
		lib__DirEntry e = data[i]
		data[i] = data[j]
		data[j] = e
		



class dirent_struct
	int struct_size
	int size
	int type
	cstring name
	void fill(lib__DirEntry e)
		_cs2s(name, e.name)
		e.size = size
		e.is_dir = (type == 1)

lib__DirEntry@list lib__DirSearch(string dirname, string filter, bool allow_dirs)
	lib__DirEntry@list l
	lib__print("") // ?!?!?!? FIXME
	int h = open(dirname, O_RDONLY)
	if h < 0
		lib_error = -1
		return l
	dirent_struct d
	lib__DirEntry e
	while getdents(h, &d)
		lib__string s
		_cs2s(d.name, s)
		d.fill(e)
		l.add(e)
	close(h)
	lib_error = 0
	
	for i in 0:l.num-1
		for j in i+1:l.num
			if !l.data[i].is_dir and l.data[j].is_dir
				l.swap(i, j)
	for i in 0:l.num-1
		for j in i+1:l.num
			if l.data[i].is_dir != l.data[j].is_dir
				nil
			else if (l.data[i].name.compare(l.data[j].name) > 0)
				l.swap(i, j)
	return l

class lib__File
	int h
	int buf_pos
	int pos
	
	void __init__()
		h = -1
	
	void __delete__()
		close()
	
	bool open(string filename)
		h = xxx_open(filename, O_RDONLY)
		pos = 0
		return h >= 0
	
	void close()
		if h < 0
			return
		xxx_close(h)
		h = -1
	
	void setBinaryMode(bool b)
	
	lib__string read(int size)
		lib__string s
		s.resize(size)
		int r = xxx_read(h, s.data, size)
		if r < 0
			r = 0
		s.resize(r)
		
		pos += r
		return s
	
	int getPos()
		return pos
		//return xxx_seek(h, 0, SEEK_CUR)
	
	void seek(int _pos, bool absolute)
		if absolute
			pos = _pos
			xxx_seek(h, pos, SEEK_SET)
		else
			xxx_seek(h, pos, SEEK_CUR)

bool xxx_close(int h)
	return close(h)

int xxx_open(string filename, int flags)
	return open(filename, flags)

int xxx_read(int h, void* buf, int size)
	return read(h, buf, size)

int xxx_seek(int h, int pos, int mode)
	seek(h, pos, mode)

lib__File* lib__FileOpen(string filename)
	lib__File* f = lib__@malloc(sizeof(lib__File))
	f.__init__()
	if !f.open(filename)
		lib__@free(f)
		return nil
	return f

lib__string lib__FileRead(string filename)
	lib__string content
	int h = open(filename, O_RDONLY)
	if h < 0
		lib__print("kann Datei nicht oeffnen: ")
		lib__print(filename)
		lib__print("\n")
		return content
	int size = 0
	while true
		content.resize(size + 1024)
		int r = read(h, &content.data[size], 1024)
		if r < 0
			lib__print("Fehler beim Lesen...\n")
		if r <= 0
			break
		size += r
	content.resize(size)
	close(h)
	return content

//--------------------------------------------------------------------------
// images

class lib__color
	float a, r, g, b
	lib__string str()
		lib__string s
		return s

class lib__Image
	int width, height
	int mode, __align__
	lib__int@list data
	bool alpha_used
	bool error
	void __init__(int w, int h, color c)
		data.resize(w * h)
		int ic = 0xff000000 + f2i(255.0 * c.b) + (f2i(255.0 * c.g) << 8) + (f2i(255.0 * c.r) << 16)
		for i in 0:data.num
			data.data[i] = ic
		width = w
		height = h
		error = false

lib__Image* lib__LoadImage(string filename)
	lib__string temp
	int h = open(filename, O_RDONLY)
	if h < 0
		return nil
	temp.resize(32)
	int r = read(h, &temp.data[0], 18)
	if r < 0
		close(h)
		return nil
	lib__Image* im = lib__@malloc(sizeof(Image))
	int offset = temp.data[0]
	int ww = temp.data[13]
	int width = temp.data[12]
	width += (ww*256)
	int hh = temp.data[15]
	int height = temp.data[14]
	height += (hh*256)
	
	im.__init__(width, height, Red)
	
	for i in 0:offset
		read(h, &temp.data[0], 1)
	
	for y in 0:height
		read(h, &im.data.data[y * width], 4*width)
				
	/*for y in 0:height
		for x in 0:width
			int c
			if read(h, &c, 4) == 4
				im.data.data[x + y * width] = c
			else
				im.data.data[x + y * width] = 0xffff0000*/
			
	close(h)
	return im


class lib__Exception
	lib__string msg
	void __init__(lib__string _msg)
		msg = _msg
	virtual lib__string message()
		return msg

void lib__raise(lib__Exception* e)
	string* msg = &e.msg
	lib_print_endl = true
	lib__print(*msg)
	exit(0)	

//--------------------------------------------------------------------------
// start

void signal_handler_segv()
	lib_print_endl = true
	lib__print("  -- Segmentation Fault --")
	exit(0)
	

void init_lib()
	__free_error__ = false
	lib_mem_debug = false
	lib_print_endl = true
	
	int malloc_begin = 0x00b00000
	cur_break_value = brk(-1)
	int malloc_size_all = cur_break_value - malloc_begin // 0x00200000
	
	// intentionally leave a 8b gap to prevent merging
	malloc_first_free = _i2p(malloc_begin)
	malloc_first_free.size = malloc_size_all - sizeof(MallocHeader) - MALLOC_STOPPER
	malloc_first_free.prev = nil
	malloc_end_marker = _i2p(cur_break_value - sizeof(MallocHeader))
	malloc_end_marker.size = sizeof(MallocHeader)
	malloc_end_marker.next = nil
	malloc_end_marker.prev = malloc_first_free
	malloc_first_free.next = malloc_end_marker
	
	malloc_small_block = lib__@malloc(sizeof(MallocSmallBlock))
	malloc_small_block.init()
	
	rand_state = 0
	
	sigaction(11, &signal_handler_segv)
	
	stdin = 0
	stdout = 1
	


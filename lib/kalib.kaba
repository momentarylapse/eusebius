#define __FUNCTION_POINTER_AS_CODE__
use image
use "base.kaba"
use "syscalls.kaba"


void _s2cs(string s, out cstring cs)
	for i in 0:s.num
		cs[i] = s[i]
	cs[s.num] = 0

void _cs2s(cstring cs, out lib__string s)
	s.clear()
	for i in 0:255
		if cs[i] == 0
			return
		s.add(cs[i])

lib__string cs2s(cstring cs)
	lib__string s
	_cs2s(cs, s)
	return s

# ["aa", "bb"] -> "aa\0bb\0\0"
void sa2cs(string[] a, out cstring cs)
	int n = 0
	for k in 0:a.num
		for i in 0:a[k].num
			cs[n] = a[k][i]
			n ++
		cs[n] = 0
		n ++
	cs[n] = 0


int open(string filename, int flags)
	cstring tt
	_s2cs(filename, tt)
	__temp_p__ = &tt
	__temp_i__ = flags
	asm{
		mov eax, 0x00000005
		mov ebx, __temp_p__
		mov ecx, __temp_i__
		int 0x80
		mov __temp_i__, eax
	}
	return __temp_i__

int create(string filename)
	cstring tt
	_s2cs(filename, tt)
	__temp_p__ = &tt
	asm{
		mov eax, 0x00000008
		mov ebx, __temp_p__
		mov ecx, 0x00000000
		int 0x80
		mov __temp_i__, eax
	}
	return __temp_i__

int fork()
	asm{
		mov eax, 0x00000002
		int 0x80
		mov __temp_i__, eax
	}
	if __temp_i__ == 0
		stdout = open("/dev/tty", O_RDONLY)
	return __temp_i__

bool mkdir(string filename)
	cstring tt
	_s2cs(filename, tt)
	__temp_p__ = &tt
	asm{
		mov eax, 0x00000027
		mov ebx, __temp_p__
		int 0x80
		mov lib_error, eax
	}
	return lib_error == 0

bool rmdir(string filename)
	cstring tt
	_s2cs(filename, tt)
	__temp_p__ = &tt
	asm{
		mov eax, 0x00000028
		mov ebx, __temp_p__
		int 0x80
		mov lib_error, eax
	}
	return lib_error == 0


bool mkfifo(string filename)
	cstring tt
	_s2cs(filename, tt)
	__temp_p__ = &tt
	asm{
		mov eax, 0x0000000e
		mov ebx, __temp_p__
		int 0x80
		mov lib_error, eax
	}
	return lib_error == 0

bool unlink(string filename)
	cstring tt
	_s2cs(filename, tt)
	__temp_p__ = &tt
	asm{
		mov eax, 0x0000000a
		mov ebx, __temp_p__
		int 0x80
		mov lib_error, eax
	}
	return lib_error == 0

bool chdir(string dir)
	cstring tt
	_s2cs(dir, tt)
	__temp_p__ = &tt
	asm{
		mov eax, 0x0000000c
		mov ebx, __temp_p__
		int 0x80
		mov lib_error, eax
	}
	return lib_error == 0

lib__string getcwd()
	cstring tt
	__temp_p__ = &tt
	asm{
		mov eax, 0x000000b7
		mov ebx, __temp_p__
		mov ecx, 0x00000100
		int 0x80
		mov lib_error, eax
	}
	lib__string r
	_cs2s(tt, r)
	return r

int execute(string[] arg, int fd_in, int fd_out)
	cstring tt_arg
	sa2cs(arg, tt_arg)
	__temp_p__ = &tt_arg
	__temp_i__ = fd_in
	__temp_i2__ = fd_out
	asm{
		mov eax, 0x0000000b
		mov ebx, __temp_p__
		mov ecx, __temp_i__
		mov edx, __temp_i2__
		int 0x80
		mov lib_error, eax
	}
	return lib_error


int socket(int type)
	return sys_socket(1, type, 0)

bool bind(int fd, int port)
	return sys_socket(2, fd, port) == 0

bool connect(int fd, int port)
	return sys_socket(3, fd, port) == 0

bool listen(int fd)
	return sys_socket(4, fd, 0) == 0

int accept(int fd)
	return sys_socket(5, fd, 0)

void get_args(out lib__string@list arg)
	cstring cs
	__temp_p__ = &cs
	asm{
		mov eax, 0x00002001
		mov ebx, __temp_p__
		int 0x80
	}
	lib__string s
	
	int p = 0
	for i in 0:250
		if cs[i] == 0
			if s.num == 0
				break
			arg.add(s)
			s.clear()
			p = i + 1
		else
			s.add(cs[i])


#--------------------------------------------------------------------------
# lib

int lib__clampi(int i, int min, int max)
	if i > max
		return max
	if i < min
		return min
	return i

int lib__loopi(int i, int min, int max)
	int d = max - min + 1
	if i < min
		int n = ( (min-i-1) / d ) + 1
		return i + d * n
	if i > max
		int n = ( (i-max-1) / d ) + 1
		return i - d * n
	return i

#--------------------------------------------------------------------------
# memory management


void memcpy(void* _dest, void* _source, int size)
	char[0]* dest = _dest
	char[0]* source = _source
	for i in 0:size
		dest[i] = source[i]
		
void prints(cstring s)
	__temp_p__ = &s
	asm{
		mov eax, 0x00002002
		mov ebx, __temp_p__
		int 0x80
	}


int MemHeapAllocated # includes overhead of all headers

class MallocHeader
	int size # header + payload
	int magic
	MallocHeader *next
	MallocHeader *prev
	void *after()
		char[0]* pp = &self
		return &pp[size]
	void *payload()
		char[0]* pp = &self
		return &pp[sizeof(MallocHeader)]
MallocHeader *malloc_first_free
MallocHeader *malloc_end_marker
int cur_break_value

# heap is split into a (hole-free) list of blocks
# blocks are either free or allocated
# free blocks form a doubly-linked list (no loop)
# allocated blocks are not linked

int _align8_(int size)
	if (size & 0x00000007) == 0
		return size
	return (size & 0xfffffff8) + 8


void* lib__@malloc(int _size)
	if _size <= MALLOC_SMALL_SIZE
		void *ppp = small_malloc()
		if ppp
			return ppp

	int size = _align8_(_size)
	if lib_mem_debug
		kprint(" [+")
		kprinti(size)
		kprint("] ")
	
	# account for the allocation header
	size += sizeof(MallocHeader)
	
	# find a free block big enough
	MallocHeader *cur = malloc_first_free
	while cur.next
		if size <= cur.size - sizeof(MallocHeader)
		
			# shrink free block
			cur.size -= size
			
			# create allocated block at (former) end of free block
			MallocHeader *hh = cur.after()
			hh.magic = 0x12345678
			hh.size = size
			hh.next = nil
			hh.prev = nil
			
			MemHeapAllocated += size
			if lib_mem_debug
				kprint(" ")
				kprinti(_p2i(hh.payload()))
			memcheck()
			#if lib_mem_debug
#				kprint(">")
#				kprinti(_p2i(hh.payload()))
			return hh.payload()
		cur = cur.next

	
	MallocHeader *last_before_end_new = _i2p(cur_break_value - sizeof(MallocHeader) - MALLOC_STOPPER)
 	
	# request more memory from kernel
	int new_break_value = cur_break_value + size + sizeof(MallocHeader) + 1024
	if lib_mem_debug
		kprint("  BREAK ")
		kprinti(cur_break_value)
		kprint(" - ")
		kprinti(new_break_value)
		kprint("  ")
	int r = brk(new_break_value)
	if r < 0
		__lib_fatal__("malloc/brk()")
	cur_break_value = r
	
	# get the pointer now... we might overwrite the end marker...
	MallocHeader *last_before_end_old = malloc_end_marker.prev
	last_before_end_old.next = last_before_end_new
	last_before_end_new.prev = last_before_end_old
	last_before_end_new.magic = 0x1234567
	
	
	# add allocated block
	MallocHeader *hh = _i2p(cur_break_value - size - sizeof(MallocHeader) - MALLOC_STOPPER)
	hh.size = size
	hh.next = nil
	hh.prev = nil
	
	# resize last free block
	last_before_end_new.size = _p2i(hh) - _p2i(last_before_end_new)
	
	# create new end marker
	malloc_end_marker = _i2p(cur_break_value - sizeof(MallocHeader))
	malloc_end_marker.size = sizeof(MallocHeader)
	malloc_end_marker.next = nil
	malloc_end_marker.prev = last_before_end_new
	last_before_end_new.next = malloc_end_marker
	
	return hh.payload()

void _cleanup(out MallocHeader *h)
	if h.after() == h.next
		MemHeapAllocated -= sizeof(MallocHeader)
		if lib_mem_debug
			kprint(" merge after ")
		h.size += h.next.size
		h.next = h.next.next
		h.next.prev = h
	if h.prev.after() == h
		MemHeapAllocated -= sizeof(MallocHeader)
		if lib_mem_debug
			kprint(" merge before ")
		h.prev.size += h.size
		h.next.prev = h.prev
		h.prev.next = h.next

void lib__@free(void *p)
	if !p
		return
	int index = small_malloc_no(p)
	if index >= 0
		small_free(index)
		return
	int ip = _p2i(p)
	if lib_mem_debug
		kprint(" free ")
		kprinti(ip)
	
	MallocHeader *hh = _i2p(ip - sizeof(MallocHeader))
	if hh.magic != 0x12345678
		kprint(" free___:  ")
		kprinti(ip)
		__lib_fatal__("evil free(1)")
	
	if lib_mem_debug
		kprint(" ")
		kprinti(hh.size)
	
	# find last free window before p
	MallocHeader *cur = malloc_first_free
	while cur.next
		if (ip >= _p2i(cur)) and (ip < _p2i(cur) + cur.size)
			#prints("\n")
#			printi(_p2i(cur))
#			prints("  ")
#			printi(cur.size)
#			
#			panic("double free")
		#	__lib_free_error__()
			__lib_fatal__("double free()")
		if ip < _p2i(cur.next)
			# turn allocated block into a free one
			hh.magic = 0
			
			if lib_mem_debug
				kprinti(hh.size)
			MemHeapAllocated -= hh.size - sizeof(MallocHeader)
			
			# ..by linking it to its neighbors
			hh.next = cur.next
			cur.next.prev = hh
			hh.prev = cur
			cur.next = hh
			
			_cleanup(hh)
			memcheck()
			if lib_mem_debug
				kprint(">")
			return
		cur = cur.next
	__lib_fatal__( "invalid call to free()")



void memcheck()
	MallocHeader *h = malloc_first_free
	while h.next
		if _p2i(h.next) < _p2i(h) + h.size
			__lib_fatal__("memcheck: h.next<h+size")
		if h != h.next.prev
			__lib_fatal__("memcheck: h!=h.next.prev")
		h = h.next

#void* realloc(void* po, int old_size, int new_size)
#	void *pn = malloc(new_size)
#	int n = old_size
#	if new_size < n
#		n = new_size
#	memcpy(pn, po, n)
#	free(po)
#	return pn
# double-linked list of free fields


void __lib_fatal__(string s)
	lib__print("\n\nkalib: ")
	lib__print(s)
	exit(-1)

void __lib_free_error__()
	__free_error__ = true
	lib__print("\n\nkalib: invalid call to free()")
	exit(-1)


void *lib__@realloc(void *p, int size)
	MallocHeader[0]* hp = p
	MallocHeader *h = &hp[-1]
	int old_size
	int sm_index = small_malloc_no(p)
	if sm_index >= 0
		old_size = MALLOC_SMALL_SIZE
	else
		old_size = h.size - sizeof(MallocHeader)
	void *pp = lib__@malloc(size)
	
	if size < old_size
		old_size = size
	
	memcpy(pp, p, old_size)
	lib__@free(p)
	return pp

class MallocSmallBlock
	int[MALLOC_SMALL_NUM / 32] mask
	char[MALLOC_SMALL_SIZE * MALLOC_SMALL_NUM] buf
	int delta # address translation...
	int full_below # #masks
	
	
	void init()
		for i in 0:(MALLOC_SMALL_NUM/32)
			mask[i] = 0
		delta = _p2i(&buf)
		full_below = 0
	
	void* alloc()
		#kprint " +sm "
		for i in full_below:(MALLOC_SMALL_NUM/32)
			if mask[i] == 0xffffffff
				continue
			for j in 0:32
				int m = 1 << j
				if (mask[i] & m) == 0
					full_below = i
					mask[i] = mask[i] | m
					int n = i * 32 + j
					#kprinti(n)
					#kprint(" : ")
					void *p = &buf[n * MALLOC_SMALL_SIZE]
					#kprinti _p2i(p)
					return p
		#kprint " --[XXX]--"
		return nil
	
	int to_index(void *p)
		int ip = _p2i(p)
		#kprint(" - ")
#		kprinti(ip)
#		kprint(" : ")
#		kprinti((ip - delta) / MALLOC_SMALL_SIZE)
		return (ip - delta) / MALLOC_SMALL_SIZE
	
	void free(int index)
		#kprint " -sm "
		int _mask = 1 << (index & 31)
		int mn = index >> 5
		if (mask[mn] & _mask) != 0
			mask[mn] -= _mask
		if mn < full_below
			full_below = mn

MallocSmallBlock *malloc_small_block

void* small_malloc()
	return malloc_small_block.alloc()

void small_free(int n)
	malloc_small_block.free(n)

int small_malloc_no(void *p)
	int index = malloc_small_block.to_index(p)
	if index < 0 or index >= MALLOC_SMALL_NUM
		return -1
	return index

#--------------------------------------------------------------------------
# arrays

class lib__@DynamicArray
	cstring *data
	int num
	int allocated
	int element_size
	void __mem_init__(int _element_size)
		data = nil
		num = 0
		allocated = 0
		element_size = _element_size
	void __mem_clear__()
		if allocated > 0
			lib__@free(data)
		data = nil
		allocated = 0
		num = 0

	void reserve(int size)
		if allocated == 0
			if size > 0
				allocated = size * element_size
					data = lib__@malloc(allocated)
		else if size * element_size > allocated
			allocated = size * element_size * 2
			void *data0 = data
			data = lib__@realloc(data, allocated)
		else if size == 0
			__mem_clear__()

	void __mem_resize__(int size)
		if size > num
			reserve(size)
			#memset((char*)data + num * element_size, 0, (size - num) * element_size);
		num = size

	void __mem_remove__(int index)
		if index < 0 or index >= num
			return
		for i in index*element_size : (num-1)*element_size
			data[i] = data[i+element_size]
		__mem_resize__(num - 1)
		
	void __assign__(lib__@DynamicArray a)
		__mem_resize__(a.num)
		memcpy(data, a.data, num * element_size)
		num = 0

class lib__string extends lib__@DynamicArray
	override char[0]* data
	void __init__()
		__mem_init__(1)
	void __delete__()
		__mem_clear__()
	void resize(int size)
		__mem_resize__(size)
	void clear()
		__mem_clear__()
	void add(char c)
		__mem_resize__(num + 1)
		data[num - 1] = c
	#void insert(int index, char c)
#		__mem_resize__(num + 1)
#		for i in 1:num-index-1
#			data[num - i] = data[num - i - 1]
#		data[index] = c
	void remove(int index)
		__mem_remove__(index)
	void __assign__(lib__string o)
		__mem_resize__(o.num)
		memcpy(data, o.data, num)
	void __iadd__(lib__string o)
		int n0 = num
		__mem_resize__(num + o.num)
		memcpy(&data[n0], o.data, o.num)
	lib__string __add__(lib__string o)
		lib__string r
		r = self
		r += o
		return r
			
	lib__string substr(int _start, int _length)
		lib__string r
		int start = _start
		int length = _length
		if start >= num
			return r
		if start < 0
			# start from the end
			start = num + start
			if start < 0
				return r
		if length < 0
			length = num - start + length + 1
		if start + length > num
			length = num - start
		if length > 0
			r.resize(length)
			memcpy(r.data, &data[start], length)
		return r

	lib__string head(int size)
		return substr(0, size)

	lib__string tail(int size)
		return substr(num - size, size)

	int find(lib__string s, int start)
		for i in start : num - s.num
			bool ok = true
			for j in 0:s.num
				if data[i + j] != s.data[j]
					ok = false
					break
			if ok
				return i
		return -1
		
	int compare(lib__string s)
		int n = num
		if s.num < num
			n = s.num
		for i in 0:n
			int a = data[i]
			int b = s.data[i]
			if a != b
				return a - b
		return num - s.num
		
	bool __eq__(lib__string s)
		return compare(s) == 0
	bool __neq__(lib__string s)
		return compare(s) != 0
	bool __ne__(lib__string s)
		return compare(s) != 0
	bool __lt__(lib__string s)
		return compare(s) < 0
	bool __gt__(lib__string s)
		return compare(s) > 0

#int string::rfind(const string &s, int start) const
#{
#	char *b = (char*)data;
#	char *aa = (char*)s.data;
#	if (start < 0)
#		start = num - 1;
#	for (int i=start;i>=0;i--){
#		bool ok = true;
#		for (int j=0;j<s.num;j++)
#			if (b[i + j] != aa[j]){
#				ok = false;
#				break;
#			}
#		if (ok)
#			return i;
#	}
#	return -1;
#}
#
#int string::compare(const string &s) const
#{
#	char *a = (char*)data;
#	int n = num;
#	if (num > s.num)
#		n = s.num;
#	for (int i=0;i<n;i++){
#		if (s[i] != a[i])
#			return (int)(unsigned char)a[i] - (int)(unsigned char)s[i];
#	}
#	return num - s.num;
#}
#
#inline int ichar(char a)
#{
#	if ((a >= 'A') && (a <= 'Z'))
#		return (int)(unsigned char)a - (int)(unsigned char)'A' + (int)(unsigned char)'a';
#	return (int)(unsigned char)a;
#}
#
#int string::icompare(const string &s) const
#{
#	char *a = (char*)data;
#	int n = num;
#	if (num > s.num)
#		n = s.num;
#	for (int i=0;i<n;i++){
#		if (ichar(s[i]) != ichar(a[i]))
#			return ichar(a[i]) - ichar(s[i]);
#	}
#	return num - s.num;
#}

	lib__string reverse()
		lib__string r
		r.resize(num)
		for i in 0:num
			r.data[num - i - 1] = data[i]
		return r

	void replace0(int start, int length, lib__string str)
		if start + length > num
			return
		int d = str.num - length
		if d > 0
			resize(num + d)
			#for (int i=num-1;i>=start+length;i--)
			int j = num-1
			while j >= start+length
				data[j] = data[j - d]
				j --
		memcpy(&data[start], str.data, str.num)
		if d < 0
			for i in start + str.num : num + d
				data[i] = data[i - d]
			resize(num + d)

	lib__string replace(lib__string sub, lib__string by)
		lib__string r = self
		int i = r.find(sub, 0)
		while i >= 0
			r.replace0(i, sub.num, by)
			i = r.find(sub, i + by.num)
		return r

	lib__string lower()
		lib__string r = self
		for i in 0:num
			if (data[i] >= 'A') and (data[i] <= 'Z')
				r.data[i] += 'a' - 'A'
		return r

	lib__string upper()
		lib__string r = self
		for i in 0:num
			if (data[i] >= 'a') and (data[i] <= 'z')
				r.data[i] += 'A' - 'a'
		return r
		

	lib__string@list explode(lib__string s)
		lib__string@list r

		int pos = 0
		while true
			int pos2 = find(s, pos)
			if pos2 < 0
				break

			r.add(substr(pos, pos2 - pos))

			pos = s.num + pos2
		if (r.num > 0) or (pos < num)
			r.add(substr(pos, num - pos))
		return r
		
	lib__string hex()
		lib__string ttt
		for i in 0:num
			int j = i
			int d = data[j]
			int d1 = (d>>4)
			int d2 = (d&15)
			if d1 < 10
				ttt.add(d1+48)
			else
				ttt.add(d1+87)
			if d2<10
				ttt.add(d2+48)
			else
				ttt.add(d2+87)
			if i == num-1
				ttt.add(' ')
			else
				ttt.add('.')
		return ttt
	
	int __int__()
		if num == 0
			return 0
		bool sign = (data[0] != '-')
		int r = 0
		int i0 = 0
		if !sign
			i0 = 1
		for i in i0:num
			int c = data[i]
			r = r * 10 + (c - 48)
		if !sign
			return -r
		return r
	
	float __float__()
		if num == 0
			return 0.0
		bool sign = (data[0] != '-')
		float r = 0.0
		int i0 = 0
		if !sign
			i0 = 1
		for i in i0:num
			int c = data[i]
			if c == '.'
				i0 = i + 1
				break
			r = r * 10.0 + (c - 48)
		float factor = 0.1
		for i in i0:num
			int c = data[i]
			r += (c - 48) * factor
			factor /= 10.0
		if !sign
			return -r
		return r

lib__string binary(void *p, int num)
	lib__string s
	s.num = num
	s.data = p
	return s

class lib__int@list extends lib__@DynamicArray
	override int[0]* data
	void __init__()
		__mem_init__(sizeof(int))
	void __delete__()
		clear()
	void clear()
		__mem_clear__()
	void resize(int size)
		if size > num
			reserve(size)
		num = size
	void add(int i)
		resize(num + 1)
		data[num - 1] = i
	void remove(int index)
		if (index < 0) or (index >= num)
			return
		for i in index : num - 1
			data[i] = data[i+1]
		resize(num - 1)
	void __assign__(lib__int@list o)
		resize(o.num)
		for i in 0:num
			data[i] = o.data[i]
	void sort()
		for i in 0:num
			for j in i:num
				if data[i]>data[j]
					int t = data[i]
					data[i] = data[j]
					data[j] = t

class lib__float@list extends lib__@DynamicArray
	override float[0]* data
	void __init__()
		__mem_init__(sizeof(float))
	void __delete__()
		clear()
	void clear()
		__mem_clear__()
	void resize(int size)
		if size > num
			reserve(size)
		num = size
	void add(int i)
		resize(num + 1)
		data[num - 1] = i
	void remove(int index)
		if (index < 0) or (index >= num)
			return
		for i in index : num - 1
			data[i] = data[i+1]
		resize(num - 1)
	void __assign__(lib__float@list o)
		resize(o.num)
		for i in 0:num
			data[i] = o.data[i]
	void sort()
		for i in 0:num
			for j in i:num
				if data[i]>data[j]
					int t = data[i]
					data[i] = data[j]
					data[j] = t

class lib__bool@list extends lib__@DynamicArray
	override bool[0]* data
	void __init__()
		__mem_init__(sizeof(bool))
	void __delete__()
		clear()
	void clear()
		__mem_clear__()
	void resize(int size)
		if size > num
			reserve(size)
		num = size
	void add(bool b)
		resize(num + 1)
		data[num - 1] = b
	void remove(int index)
		if (index < 0) or (index >= num)
			return
		for i in index : num - 1
			data[i] = data[i+1]
		resize(num - 1)
	void __assign__(lib__bool@list o)
		resize(o.num)
		for i in 0:num
			data[i] = o.data[i]

class lib__string@list extends lib__@DynamicArray
	override lib__string[0]* data
	void __init__()
		__mem_init__(sizeof(lib__string))
	void __delete__()
		for i in 0:num
			data[i].__delete__()
		#clear()
	void resize(int size)
		if size < num
			# shrink -> destruct
			for i in size:num
				data[i].__delete__()
		else if size > num
			reserve(size)
			for i in num:size
				data[i].__init__()
		num = size
	void add(lib__string s)
		resize(num + 1)
		data[num - 1] = s
	void __assign__(lib__string@list o)
		resize(o.num)
		for i in 0:num
			data[i] = o.data[i]
	void remove(int index)
		if (index < 0) or (index >= num)
			return
		for i in index : num - 1
			data[i] = data[i+1]
		resize(num - 1)
		#data[index].__clear__()
		#__mem_remove__(index)

	lib__string join(lib__string glue)
		lib__string r
		for i in 0:num
			if i > 0
				r += glue
			r += data[i]
		return r
	lib__string __str__()
		return lib__@sa2s(self)
	void swap(int i, int j)
		let t = data[i]
		data[i] = data[j]
		data[j] = t
	lib__string@list __add__(lib__string@list o)
		lib__string@list r = self
		r += o
		return r
	void __iadd__(lib__string@list o)
		for i in 0:len(o)
			add(o.data[i])

lib__string lib__@sa2s(lib__string@list a)
	lib__string r
	r.add('[')
	for i in 0:a.num
		if i > 0
			r.add(',')
		r.add('"')
		r += a.data[i]
		r.add('"')
	r.add(']')
	return r

lib__string i2s(int _i)
	int i = _i
	bool sign = i >= 0
	if !sign
		i = -i
	lib__string s
	while true
		s.add((i % 10) + 0x30)
		i /= 10
		if i == 0
			break
	if !sign
		s.add('-')
	return s.reverse()

int rand_state

int rand_next()
	rand_state = rand_state * 1664525 + 1013904223
	return rand_state & 0x00ffffff

void lib__rand_seed(int s)
	rand_state = s

float lib__rand(float m)
	return rand_next() * m / float(0x01000000)

int lib__randi(int m)
	return lib__rand(m)

class lib__int
	static lib__string __str__(int i)
		return i2s(i)

class lib__float
	static lib__string __str__(float f)
		return f2s(f, 6)

float lib__sin(float f)
	__temp_f__ = f
	asm{
		fld __temp_f__
		fsin
		fst __temp_f__
	}
	return __temp_f__

float lib__cos(float f)
	__temp_f__ = f
	asm{
		fld __temp_f__
		fcos
		fst __temp_f__
	}
	return __temp_f__

float lib__min(float a, float b)
	if a < b
		return a
	return b

float lib__max(float a, float b)
	if a > b
		return a
	return b

float lib__abs(float x)
	if x < 0
		return -x
	return x
	

int lib__clampi(int i, int min, int max)
	if max <= min
		return min
	if i > max
		return max
	if i < min
		return min
	return i

int lib_loopi(int i, int min, int max)
	if max <= min
		return min
	int d = max - min + 1
	if i < min
		int n= ( (min-i-1) / d ) + 1
		return i + d * n
	if i > max
		int n= ( (i-max-1) / d ) + 1
		return i - d * n
	return i



float lib__sqr(float f)
	return f * f

float lib__sqrt(float f)
	__temp_f__ = f
	asm{
		sqrtss xmm0, __temp_f__
		movss __temp_f__, xmm0
	}
	return __temp_f__

float lib__clamp(float f, float min, float max)
	if max < min
		return min
	if f > max
		return max
	if f < min
		return min
	return f

float lib__loop(float f, float min, float max)
	float d = max - min
	if f < min
		int n = int( (min-f) / d ) + 1
		return f + d * float(n)
	if f >= max
		int n= int( (f-max) / d ) + 1
		return f - d * float(n)
	return f

lib__string f2s(float _f, int n)
	float f = _f
	lib__string s
	
	if f < 0.0
		s.add('-')
		f = -f
	s += i2s(f)
	if n > 0
		s.add('.')
		int e = 1
		float fe = 1.0
		for i in 0:n
			e = e *10
			fe *= 10.0
		int after = int(f*fe) % e
		for i in 0:n
			e /= 10
			s.add(((after / e) % 10) + 0x30)
	return s

lib__string lib__p2s(void *p)
	lib__string r
	r.resize(sizeof(p))
	void *pp = &p
	memcpy(r.data, pp, sizeof(p))
	return r.hex()

lib__string b2s(bool b)
	lib__string r
	if b
		r.add('1')
	else
		r.add('0')
	return r

class lib__bool
	static lib__string __str__(bool b)
		return b2s(b)

lib__string lib__@ia2s(lib__int@list a)
	lib__string r
	r.add('[')
	for i in 0:a.num
		if i > 0
			r.add(',')
			r.add(' ')
		r += i2s(a.data[i])
	r.add(']')
	return r

lib__string lib__@fa2s(lib__float@list a)
	lib__string r
	r.add('[')
	for i in 0:a.num
		if i > 0
			r.add(',')
			r.add(' ')
		r += f2s(a.data[i], 6)
	r.add(']')
	return r

class lib__complex
	float x, y
	
	lib__string __str__()
		return _complex2s(self)

lib__string _complex2s(lib__complex c)
	lib__string r
	r.add('(')
	r += f2s(c.x, 6)
	r.add(',')
	r.add(' ')
	r += f2s(c.y, 6)
	r.add(')')
	return r


class lib__complex@list extends lib__@DynamicArray
	override complex[0]* data
	void __init__()
		__mem_init__(sizeof(complex))
	void __delete__()
		clear()
	void clear()
		__mem_clear__()
	void resize(int size)
		if size > num
			reserve(size)
		num = size
	void add(complex c)
		resize(num + 1)
		data[num - 1] = c
	void remove(int index)
		if (index < 0) or (index >= num)
			return
		for i in index : num - 1
			data[i] = data[i+1]
		resize(num - 1)
	void __assign__(lib__complex@list o)
		resize(o.num)
		for i in 0:num
			data[i] = o.data[i]

void lib__print(string s)
	int done = 0
	while done < s.num
		int r = write(stdout, &s[done], s.num - done)
		if r == -EWOULDBLOCK
			continue
		if r > 0
			done += r
	if lib_print_endl
		int r = write(stdout, &0x0000000a, 1)



#--------------------------------------------------------------------------
# dir entry




class dirent_struct
	int struct_size
	int size
	int type
	cstring name
	void __assign__(dirent_struct o)
		pass
	#void fill(out lib__DirEntry e)
	#	_cs2s(name, e.name)
	#	e.size = size
	#	e.is_dir = (type == 1)

lib__string@list lib__Filesystem@@search(string dirname, string filter, bool allow_dirs)
	lib__string@list list_dirs, list_files
	lib__print("") # ?!?!?!? FIXME
	int h = open(dirname, O_RDONLY)
	if h < 0
		lib_error = -1
		return list_files
	dirent_struct d
	while getdents(h, &d)
		lib__string s
		_cs2s(d.name, s)
		if d.type == 1
			list_dirs.add(s)
		else
			list_files.add(s)
	close(h)
	lib_error = 0
	
	for i in 0:list_dirs.num-1
		for j in i+1:list_dirs.num
			if list_dirs.data[i].compare(list_dirs.data[j]) > 0
				list_dirs.swap(i, j)
	for i in 0:list_files.num-1
		for j in i+1:list_files.num
			if list_files.data[i].compare(list_files.data[j]) > 0
				list_files.swap(i, j)
	return list_dirs + list_files

class lib__File
	int h
	int buf_pos
	int pos
	
	void __init__()
		h = -1
	
	void __delete__()
		close()
	
	bool open(string filename)
		h = xxx_open(filename, O_RDONLY)
		pos = 0
		return h >= 0
	
	bool create(string filename)
		h = xxx_create(filename)
		pos = 0
		return h >= 0
	
	void close()
		if h < 0
			return
		xxx_close(h)
		h = -1
	
	void setBinaryMode(bool b)
	
	lib__string read(int size)
		lib__string s
		s.resize(size)
		int r = xxx_read(h, s.data, size)
		if r < 0
			r = 0
		s.resize(r)
		
		pos += r
		return s
	
	int write(lib__string s)
		int r = xxx_write(h, s.data, s.num)
		if r > 0
			pos += r
		return r
	
	int getPos()
		return pos
		#return xxx_seek(h, 0, SEEK_CUR)
	
	void seek(int _pos, bool absolute)
		if absolute
			pos = _pos
			xxx_seek(h, pos, SEEK_SET)
		else
			xxx_seek(h, pos, SEEK_CUR)

bool xxx_close(int h)
	return close(h)

int xxx_open(string filename, int flags)
	return open(filename, flags)

int xxx_create(string filename)
	return create(filename)

int xxx_read(int h, void* buf, int size)
	return read(h, buf, size)

int xxx_write(int h, void* buf, int size)
	return write(h, buf, size)

int xxx_seek(int h, int pos, int mode)
	seek(h, pos, mode)

lib__File* lib__Filesystem@@open(string filename)
	lib__File* f = lib__@malloc(sizeof(lib__File))
	f.__init__()
	if !f.open(filename)
		lib__@free(f)
		return nil
	return f

lib__File* lib__Filesystem@@create(string filename)
	lib__File* f = lib__@malloc(sizeof(lib__File))
	f.__init__()
	if !f.create(filename)
		lib__@free(f)
		return nil
	return f

lib__string lib__Filesystem@@read(string filename)
	lib__string content
	int h = open(filename, O_RDONLY)
	if h < 0
		lib__print("kann Datei nicht oeffnen: ")
		lib__print(filename)
		lib__print("\n")
		return content
	int size = 0
	while true
		content.resize(size + 1024)
		int r = read(h, &content.data[size], 1024)
		if r < 0
			lib__print("Fehler beim Lesen...\n")
		if r <= 0
			break
		size += r
	content.resize(size)
	close(h)
	return content

bool lib__Filesystem@@is_directory(string filename)
	return false

int64 lib__Filesystem@@size(string filename)
	pass
#	return 0

int Filesystem_size32(string filename)
	return 0

#--------------------------------------------------------------------------
# images

class lib__color
	float a, r, g, b
	lib__string __str__()
		lib__string s
		return s

class lib__Image
	int width, height
	int mode, __align__
	lib__int@list data
	bool alpha_used
	bool error
	void __init__(int w, int h, color c)
		data.resize(w * h)
		int ic = 0xff000000 + int(255.0 * c.b) + (int(255.0 * c.g) << 8) + (int(255.0 * c.r) << 16)
		for i in 0:data.num
			data.data[i] = ic
		width = w
		height = h
		error = false

	static lib__Image* load(string filename)
		lib__string temp
		int h = open(filename, O_RDONLY)
		if h < 0
			return nil
		temp.resize(32)
		int r = read(h, &temp.data[0], 18)
		if r < 0
			close(h)
			return nil
		lib__Image* im = lib__@malloc(sizeof(Image))
		int offset = temp.data[0]
		int ww = temp.data[13]
		int width = temp.data[12]
		width += (ww*256)
		int hh = temp.data[15]
		int height = temp.data[14]
		height += (hh*256)
	
		im.__init__(width, height, Red)
	
		for i in 0:offset
			read(h, &temp.data[0], 1)
	
		for y in 0:height
			read(h, &im.data.data[y * width], 4*width)
				
		#for y in 0:height
#			for x in 0:width
#				int c
#				if read(h, &c, 4) == 4
#					im.data.data[x + y * width] = c
#				else
#					im.data.data[x + y * width] = 0xffff0000
			
		close(h)
		return im


class lib__Exception
	lib__string msg
	void __init__(lib__string _msg)
		msg = _msg
	virtual lib__string __str__()
		return msg

void lib__raise(lib__Exception* e)
	string* msg = &e.msg
	lib_print_endl = true
	lib__print(*msg)
	exit(0)	

#--------------------------------------------------------------------------
# start

void signal_handler_segv()
	#kprint("--->SEGFAULT<--")
	lib_print_endl = true
	lib__print("  -- Segmentation Fault --\n")
	exit(0)
	

void init_lib()
	__free_error__ = false
	lib_mem_debug = false
	lib_print_endl = true
	
	int malloc_begin = 0x00b00000
	cur_break_value = brk(-1)
	int malloc_size_all = cur_break_value - malloc_begin # 0x00200000
	
	# intentionally leave a 8b gap to prevent merging
	malloc_first_free = _i2p(malloc_begin)
	malloc_first_free.size = malloc_size_all - sizeof(MallocHeader) - MALLOC_STOPPER
	malloc_first_free.prev = nil
	malloc_end_marker = _i2p(cur_break_value - sizeof(MallocHeader))
	malloc_end_marker.size = sizeof(MallocHeader)
	malloc_end_marker.next = nil
	malloc_end_marker.prev = malloc_first_free
	malloc_first_free.next = malloc_end_marker
	
	malloc_small_block = lib__@malloc(sizeof(MallocSmallBlock))
	malloc_small_block.init()
	
	rand_state = 0
	
	sigaction(11, signal_handler_segv)
	
	stdin = 0
	stdout = 1
	


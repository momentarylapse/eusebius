#define __OS__
use "base.kaba"
use "io/text.kaba"
use "fs/fs.kaba"
use "fs/access.kaba"
use "mem/heap.kaba"
use "mem/paging.kaba"
use "mem/shared.kaba"
use "task/task.kaba"
use "task/scheduler.kaba"
use "time/timevalue.kaba"
use "time/timer.kaba"
use "irq/irq.kaba"
#define __STRING_CONST_AS_CSTRING__

class SysInfo
	int uptime
	int[3] loads
	int totalram, freeram, sharedram, bufferram
	int totalswap, freeswap
	int procs
	int totalhigh, freehigh
	int mem_unit
	int[2] pad
	int totalheap, freeheap
	void get()
		kernel_timer.update()
		uptime = kernel_timer.tv.sec
		for l in loads
			l = 0
		mem_unit = 1024 //PAGE_SIZE
		totalram = MemorySize / mem_unit
		freeram = (MemorySize - paging.get_used()) / mem_unit
		sharedram = SharedMem.get_used() / mem_unit
		bufferram = 0
		totalswap = 0
		freeswap = 0
		procs = 0
		for t in Tasks
			if t.status != TASK_STATUS_UNUSED
				procs ++
		totalhigh = 0
		freehigh = 0
		totalheap = MEM_HEAP_SIZE / mem_unit
		freeheap = MemHeapAllocated / mem_unit

SysInfo _sys_info

class UTSName
	cstring sysname
	cstring nodename
	cstring release
	cstring version
	cstring machine
	cstring domainname
	void get()
		strcpy(&sysname, &KERNEL_NAME)
		strcpy(&nodename, &"???")
		strcpy(&release, &KERNEL_VERSION)
		strcpy(&version, &KERNEL_VERSION)
		strcpy(&machine, &MACHINE_TYPE)
		strcpy(&domainname, &"-no domain-")

UTSName _uts_name

class TaskInfo
	cstring name
	int pid, mode, status
	int mem
	int cpu
	TimeValue life
	int get(int _pid)
		Task* t = get_task(_pid)
		if !t
			return -1
		strcpy(&name, &t.name)
		pid = t.pid
		status = t.status
		mode = 1
		if t.kernel_mode
			mode = 0
		mem = t.pages_alloced()
		cpu = t.load
		life = t.time_all
		return 0

TaskInfo _task_info

	
void int_syscall()
	while true
		//show_pvl()
		int r = 0
		
		//int pid = (SysCallTask.tss.prev >> 3) - NUM_PRE_GDT_ENTRIES
		Task* caller = &Tasks[RunningPid]
		//printi(pid)
		int index = caller.tss.eax
		int param1 = caller.tss.ebx
		int param2 = caller.tss.ecx
		int param3 = caller.tss.edx
		int param4 = caller.tss.esi
		/*printi(RunningPid)
		prints(" ")
		printi(index)
		prints(" ")*/
	
		if index == 1 // exit
			caller.sys_exit(param1)
		else if index == 2 // fork
			r = caller.sys_fork()
		else if index == 3 // read
			r = caller.sys_read(param1, param2, param3)
		else if index == 4 // write
			r = caller.sys_write(param1, param2, param3)
		else if index == 5 // open
			cstring filename
			caller.page_dir.memcpy2kernel(&filename, param1, sizeof(cstring))
			r = caller.sys_open(filename, param2)
		else if index == 6 // close
			r = caller.sys_close(param1)
		else if index == 7 // waitpid
			r = caller.sys_waitpid(param1, param2, param3)
		else if index == 8 // create
			caller.page_dir.memcpy2kernel(&filename, param1, sizeof(cstring))
			r = caller.sys_open(filename, O_CREATE | O_WRONLY | O_TRUNC)
		else if index == 11 // exec
			caller.page_dir.memcpy2kernel(&filename, param1, sizeof(cstring))
			r = caller.sys_execute(filename, param2, param3)
		else if index == 12 // chdir
			caller.page_dir.memcpy2kernel(&filename, param1, sizeof(cstring))
			r = caller.set_cur_dir(filename)
		else if index == 14 // mknod
			caller.page_dir.memcpy2kernel(&filename, param1, sizeof(cstring))
			r = caller.sys_mknod(filename, param2)
		else if index == 20 // getpid
			r = RunningPid
		else if index == 25 // stime
			kernel_timer.update()
			caller.page_dir.memcpy2task(param1, &kernel_timer.tv, sizeof(TimeValue))
		else if index == 37 // kill
			r = caller.sys_kill(param1, param2)
		else if index == 39 // mkdir
			caller.page_dir.memcpy2kernel(&filename, param1, sizeof(cstring))
			r = caller.sys_mkdir(filename)
		else if index == 41 // dup
			r = caller.sys_dup(param1)
		else if index == 42 // pipe
			r = caller.sys_pipe(param1)
		else if index == 45 // brk
			r = caller.sys_brk(param1)
		else if index == 51 // fcntl
			r = caller.sys_fcntl(param1, param2, param3)
		else if index == 88 // reboot
			nil
		else if index == 116 // sysinfo
			_sys_info.get()
			caller.page_dir.memcpy2task(param1, &_sys_info, sizeof(_sys_info))
		else if index == 117 // ipc
			r = caller.sys_ipc(param1, param2, param3, param4)
		else if index == 122 // uname
			_uts_name.get()
			caller.page_dir.memcpy2task(param1, &_uts_name, sizeof(_uts_name))
		else if index == 141 // getdents
			r = caller.sys_getdents(param1, param2, param3)
		else if index == 158 // sched_yield
			int pid_next = GetNextTask(RunningPid)
			ReconnectTasks(pid_next, SysCallTask)
		else if index == 162 // nanosleep
			caller.sys_nanosleep(param1, param2)
			// p1 = &duration
			// p2 = &duration_more
		else if index == 183 // getcwd
			FileSystem.get_name(filename, caller.cur_dir)
			caller.page_dir.memcpy2task(param1, &filename, sizeof(cstring))
		else if index == 0x2001 // getarg
			caller.page_dir.memcpy2task(param1, &caller.arg, sizeof(cstring))
		else if index == 0x2002 // kprints
			if param2 < sizeof(filename)
				caller.page_dir.memcpy2kernel(&filename, param1, param2)
				filename[param2] = 0
				prints(filename)
		else if index == 0x2003 // kprinti
			printi(param1)
		else if index == 0x2005 // taskinfo
			r = _task_info.get(param1)
			if r == 0
				caller.page_dir.memcpy2task(param2, &_task_info, sizeof(_task_info))
		else
			r = -ENOSYS
		/*TextColor = 4
		prints("<<")
		prints(caller.name)
		prints(":")
		printi(index)
		prints(">>")
		TextColor = 7*/
		//while true
		//	nil
		
		// task switch?
		if caller.status != TASK_STATUS_RUNNING
			//prints("S")
			pid_next = GetNextTask(RunningPid)
			ReconnectTasks(pid_next, SysCallTask)
			//printi(pid_next)

		// zurÃ¼ck
		caller.tss.eax = r
		
		//prints(">")
		asm{
			iret
		}
		//prints("<")
	
Task *SysCallTask

void InitSysCall()
	SysCallTask = AddTaskKernel("irq-syscall", &int_syscall, KernelTask)
	irq.set_task(0x80, SysCallTask)

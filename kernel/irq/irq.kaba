use "../base.kaba"
use "../io/text.kaba"
use "../io/io.kaba"
use "../task/task.kaba"


const int HARDWARE_IRQ_SHIFT = 32

void int_ignore()
	//prints("[ignore irq]")
	asm{
		iret
	}
Task *IgnoreTask

void int_task_irq()
	asm{
		mov __temp_i__, esi
	}
	int irq_no = __temp_i__
	InterruptToSignalMap *m = &irq.task_maps[irq_no]
	Task *t = m.utask
	while true
		
		if t.puid == m.puid
			t.handle_signal(m.signal)
		
		// allow more
		if irq_no >= 8
			outportb(0xa0, 0x20)
		outportb(0x20, 0x20)
		asm{
			iret
		}



class InterruptDescriptor
	int a, b

	void set(void* func)
		a = 0
		b = 0
		if func
			int addr = _p2i(func)
			// Interrupt Gate
			a = 0x00080000 + (addr & 0xffff) // desc[1],addr[15..0]
			b = (addr & 0xffff0000) + 0x00008e00 // addr[31..16],typ


	// interrupt tasks don't need the cli/sti... we use the IF bit
	void set_task(Task* t)
		a = 0
		b = 0
		if t
			t.tss.eflags = 0x000 // Iterrupt Flag = 0
			t.status = TASK_STATUS_INTERRUPT

			// Interrupt Task Gate
			a = 0x00080000*t.desc // desc,0[15..0]
			b = 0x00008500 // 0[31..16],typ

class InterruptToSignalMap
	int irq // hardware IRQ  (!= shifted version...)
	int pid, puid
	int signal
	Task *ktask
	Task *utask

class InterruptController
	InterruptDescriptor[256] idt
	InterruptToSignalMap[16] task_maps
	
	void deny_user_map(int id)
		if id < 0 and id >= 256
			return
		task_maps[id].pid = 666666
		
	
	void set(int id, void* func)
		idt[id].set(func)
		if func
			deny_user_map(id)
	
	void set_task(int id, Task* t)
		idt[id].set_task(t)
		if t
			deny_user_map(id)

	void init()
		prints("loading interrupt table...")

		for i in idt
			i.set(nil)
		for m,i in task_maps
			m.pid = -1
			m.irq = i
			m.ktask = nil
			m.utask = nil
		
	
		IgnoreTask = AddTaskKernel("irq-ignore", &int_ignore, 128, KernelTask)
		irq.set_task(32, IgnoreTask) // IRQ 0

		// move IRQs to higher interrupts
		outportb(0x20,0x11) // init
		outportb(0xa0,0x11)
		outportb(0x21,HARDWARE_IRQ_SHIFT) // offset
		outportb(0xa1,0x28)
		outportb(0x21,0x04) // master/slave identity stuff?
		outportb(0xa1,0x02)
		outportb(0x21,0x01) // 8086
		outportb(0xa1,0x01)
		outportb(0x21,0x00) // masks
		outportb(0xa1,0x00)
	
		__temp_p__ = &idt

		asm{
			jmp _after_idt_data
			_idtr:
			dw 0x07ff
			_idtr_base:
			dd 0x00000000
			_after_idt_data:
			mov eax, __temp_p__
			mov [_idtr_base], eax
			cli
			lidt [_idtr]
			sti
		}
	
		prints("   ok\n")
	
	int sys_map_irq(int hw_irq, Task *t, int signal)
		if hw_irq < 0 or hw_irq >= 16
			return -EINVAL
		if signal < 0 or signal >= 32
			return -EINVAL
		InterruptToSignalMap* m = &task_maps[hw_irq]
		if m.pid >= 0
			return -EEXIST
		if !m.ktask
			m.ktask = AddTaskKernel("irq-task", &int_task_irq, 4096, KernelTask)
			set_task(hw_irq + HARDWARE_IRQ_SHIFT, m.ktask)
			m.ktask.tss.esi = hw_irq
		m.pid = t.pid
		m.puid = t.puid
		m.signal = signal
		m.utask = t
		return 0
		

InterruptController irq

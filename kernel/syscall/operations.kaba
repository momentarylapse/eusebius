use common
use mem.memory
use mem.paging
use mem.heap
use task.task
use task.manager
use fs.fs
use fs.access
use time.timevalue
use time.timer

func sys_nanosleep(out t: Task, p1: int64, p2: int64) -> int
	var tv = _i642p(p1) as TimeValue&
	tv.add(KernelTimer.tv)
	t.set_wait(WaitingMode.TIME, tv.sec, tv.nanosec, 0)
	return 0

func sys_stime(addr: int64) -> int
	KernelTimer.update()
	var tv = _i642p(addr) as TimeValue&
	tv = KernelTimer.tv
	#return -EFAULT
	return 0

func sys_exit(out t: Task, r: int)
	TaskManager.die(t, r)


func sys_execute(out t: Task, faddr: int64, fd_in: int, fd_out: int) -> int
	let h = t.sys_open(faddr, O_RDONLY)
	if h < 0
		return -ENOENT
	for of in t.handles[h]
		var filename: cstring
		of.entry.get_path(filename)
		var addr = TASK_IMAGE_POS # task space...
		for tt in TaskManager.add_user_task(filename, addr, &t)
			var code = tt.page_root_dir.virtual_to_physical(TASK_MEMORY_OFFSET)
			while true
				let r = of.read(code, 1024)
				if r <= 0
					break
				code += r
			t.sys_close(h)
			
		#	var of_in = get_handle(fd_in)
		#	var of_out = get_handle(fd_out)
		#	tt.add_handle(of_in)
		#	tt.add_handle(of_out)
	
			#tt.activate()
			return tt.pid
		else
			t.sys_close(h)
			return -ENOMEM
	t.sys_close(h)
	return -1

class SysInfo as @noauto
	var uptime: int
	var loads: int[3]
	var totalram, freeram, sharedram, bufferram: int
	var totalswap, freeswap: int
	var procs: int
	var totalhigh, freehigh: int
	var mem_unit: int
	var pad: int[2]
	var totalheap, freeheap: int
	func mut get()
		KernelTimer.update()
		uptime = KernelTimer.tv.sec
		for l in loads
			l = 0
		mem_unit = 1024 #PAGE_SIZE
		totalram = memory_size / mem_unit
		freeram = (memory_size - Paging.get_used()) / mem_unit
		sharedram = 0 #SharedMemory.get_used() / mem_unit
		bufferram = 0
		totalswap = 0
		freeswap = 0
		procs = 0
		for t in TaskManager.tasks
			if t.status != TaskStatus.UNUSED
				procs ++
		totalhigh = 0
		freehigh = 0
		totalheap = MEM_HEAP_SIZE / mem_unit
		freeheap = (MEM_HEAP_SIZE - Heap.allocated) / mem_unit

#var _sys_info: SysInfo

class UTSName as @noauto
	var sysname: cstring
	var nodename: cstring
	var release: cstring
	var version: cstring
	var machine: cstring
	var domainname: cstring
	func mut get()
		strcpy(sysname, KERNEL_NAME)
		strcpy(nodename, "???")
		strcpy(release, KERNEL_VERSION)
		strcpy(version, KERNEL_VERSION)
		strcpy(machine, MACHINE_TYPE)
		strcpy(domainname, "-no domain-")

class TaskInfo as @noauto
	var name: cstring
	var pid, ppid, mode: int
	var status: TaskStatus
	var mem: int
	var cpu: int
	var life: TimeValue
	func mut get(_pid: int) -> int
		for t in TaskManager.get_task(_pid)
			strcpy(name, t.name)
			pid = t.pid
			ppid = -1
			for p in t.parent
				ppid = p.pid
			status = t.status
			mode = 1
		#	if t.kernel_mode
		#		mode = 0
			mem = 0 #t.pages_alloced()
			cpu = 0 #t.cpu_load
			#life = t.time_all
			return 0
		return -1

#class MountInfo as @noauto
#	var major, minor: int
#	var dir: cstring
#	func get(_index: int) -> int
#		var m = &FileSystem.mounts[_index]
#		if !m.dev
#			return -1
#		major = m.dev.major
#		minor = m.dev.minor
#		m.dest.get_path(dir)
#		return 0
#
#var _mount_info: MountInfo


class StatData as @noauto
	var name: cstring
	var type: int
	var size: int
	var inode: int
	var mp_inode: int
	var time: int
	func mut get(filename: cstring, cur_dir: FileEntry) -> int
		for e in FileSystem.get(filename, cur_dir)
			strcpy(name, e.name)
			type = int(e.type)
			size = e.size
			inode = e.inode
			return 0
		#panic(filename)
		return 1

#var _stat_data: StatData
#
#func int_syscall()
#	while true
#		#show_pvl()
#		int r = 0
#		
#		#int pid = (SysCallTask.tss.prev >> 3) - NUM_PRE_GDT_ENTRIES
#		var caller = &TaskManager.tasks[Scheduler.running_pid]
#		#printi(pid)
#		int index = caller.tss.eax
#		int param1 = caller.tss.ebx
#		int param2 = caller.tss.ecx
#		int param3 = caller.tss.edx
#		int param4 = caller.tss.esi
#		#printi(RunningPid)
##		prints(" ")
##		printi(index)
##		prints(" ")
#	
#		if index == 1 # exit
#			caller.sys_exit(param1)
#		else if index == 2 # fork
#			r = caller.sys_fork()


#		else if index == 14 # mknod
#			r = caller.sys_mknod(param1, param2)
#		else if index == 19 # seek
#			r = caller.sys_seek(param1, param2, param3)
#		else if index == 20 # getpid
#			r = Scheduler.running_pid
#		else if index == 25 # stime
#			KernelTimer.update()
#			r = 0
#			if !caller.page_dir.memcpy2task(param1, &KernelTimer.tv, sizeof(TimeValue))
#				r = -EFAULT
#		else if index == 37 # kill
#			r = caller.sys_kill(param1, param2)
#		else if index == 39 # mkdir
#			r = caller.sys_mkdir(param1)
#		else if index == 40 # rmdir
#			r = caller.sys_rmdir(param1)
#		else if index == 41 # dup
#			r = caller.sys_dup(param1)
#		else if index == 42 # pipe
#			r = caller.sys_pipe(param1)
#		else if index == 45 # brk
#			r = caller.sys_brk(param1)


#		else if index == 0x2002 # kprints
#			cstring filename
#			if param2 < sizeof(filename)
#				caller.page_dir.memcpy2kernel(&filename, param1, param2)
#				filename[param2] = 0
#				prints(filename)
#		else if index == 0x2003 # kprinti
#			printi(param1)
#		else if index == 0x2006 # exit_signal
#			r = caller.sys_exit_signal()
#			asm {
#				# don't overwrite eax with return value
#				jmp __sys_call_return
#			}
#		else if index == 0x2007 # map IRQ
#			r = irq.sys_map_irq(param1, caller, param2)
#		else if index == 0x2008 # mountinfo
#			r = _mount_info.get(param1)
#			if r == 0
#				caller.page_dir.memcpy2task(param2, &_mount_info, sizeof(_mount_info))
#		else if index == 0x2009 # blockinfo
#			r = -1
#			var d = BlockDevManager.get(param1, param2)
#			if d
#				caller.page_dir.memcpy2task(param3, d, sizeof(BlockDevice))
#				r = 0
#		else if index == 0x200a # stat
#			cstring filename
#			caller.page_dir.memcpy2kernel(&filename, param1, sizeof(cstring))
#			r = _stat_data.get(filename, caller.cur_dir)
#			if r == 0
#				caller.page_dir.memcpy2task(param2, &_stat_data, sizeof(_stat_data))
#		else if index == 0x200b # addr2phys
#			int offset
#			r = caller.page_dir.addr2kernel(param1, &offset)
#		else
#			r = -ENOSYS
#		#TextColor = 4
##		prints("<<")
##		prints(caller.name)
##		prints(":")
##		printi(index)
##		prints(">>")
##		TextColor = 7
#		#while true
#		#	nil
#		
#		if TaskManager.ack_hw_irq >= 0
#			#prints(" <ACK> ")
#			irq.end_of_interrupt(TaskManager.ack_hw_irq)
#			TaskManager.ack_hw_irq = -1
#		
#		# task switch?
#		if caller.status != TASK_STATUS_RUNNING
#			#prints("S")
#			int pid_next = Scheduler.get_next_task(Scheduler.running_pid)
#			Scheduler.reconnect_tasks(pid_next, sys_call_task)
#			#printi(pid_next)
#
#		# back
#		caller.tss.eax = r
#		
#		#prints(">")
#		asm {
#		__sys_call_return:
#			iret
#		}
#		#prints("<")

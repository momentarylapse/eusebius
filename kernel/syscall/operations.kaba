use common
use mem.memory
use mem.paging
use mem.heap
use task.task
use task.manager
use fs.fs
use fs.access
use time.timevalue
use time.timer

use io.text


func sys_nanosleep(out t: Task, p1: int64, p2: int64) -> int
	var tv = _i2p(p1) as TimeValue&
	tv.add(KernelTimer.tv)
	t.set_wait(WaitingMode.TIME, tv.sec, tv.nanosec, 0)
	return 0

func sys_stime(addr: int64) -> int
	KernelTimer.update()
	var tv = _i2p(addr) as TimeValue&
	tv = KernelTimer.tv
	#return -EFAULT
	return 0

func sys_exit(out t: Task, r: int)
	TaskManager.die(t, r)

func sys_waitpid(out t: Task, _pid: int, status_addr: int64, options: int) -> int
	for o in TaskManager.get_task(_pid)
		# already (un-) dead?
		if o.status == TaskStatus.ZOMBIE
			var p = _i2p(status_addr) as int&
			p = o.return_status
			o.clean_up_deep()
			t.activate()
			return 0
		
		# don't block?
		if (options & 1) > 0
			return -2

		t.set_wait(WaitingMode.TASK_EXIT, _pid, status_addr, 0)
		return 0
	return -ECHILD


func sys_execute(out t: Task, faddr: int64, fd_in: int, fd_out: int) -> int
	let h = t.sys_open(faddr, O_RDONLY)
	if h < 0
		return -ENOENT
	for of in t.handles[h]
		var filename: cstring
		of.entry.get_path(filename)
		var addr = TASK_IMAGE_POS # task space...
		for tt in TaskManager.add_user_task(filename, addr, &t)
			memcpy(&tt.arg, _i2p(faddr), sizeof(cstring))
			var code = tt.page_root_dir.virtual_to_physical(TASK_MEMORY_OFFSET)
			while true
				let r = of.read(code, 1024)
				if r <= 0
					break
				code += r
			t.sys_close(h)
			
		#	var of_in = get_handle(fd_in)
		#	var of_out = get_handle(fd_out)
		#	tt.add_handle(of_in)
		#	tt.add_handle(of_out)
	
			#tt.activate()
			return tt.pid
		else
			t.sys_close(h)
			return -ENOMEM
	t.sys_close(h)
	return -1

class SysInfo as @noauto
	var uptime: int
	var loads: int[3]
	var totalram, freeram, sharedram, bufferram: int
	var totalswap, freeswap: int
	var procs: int
	var totalhigh, freehigh: int
	var mem_unit: int
	var pad: int[2]
	var totalheap, freeheap: int
	func mut get()
		KernelTimer.update()
		uptime = KernelTimer.tv.sec
		for l in loads
			l = 0
		mem_unit = 1024 #PAGE_SIZE
		totalram = memory_size / mem_unit
		freeram = (memory_size - Paging.get_used()) / mem_unit
		sharedram = 0 #SharedMemory.get_used() / mem_unit
		bufferram = 0
		totalswap = 0
		freeswap = 0
		procs = 0
		for t in TaskManager.tasks
			if t.status != TaskStatus.UNUSED
				procs ++
		totalhigh = 0
		freehigh = 0
		totalheap = MEM_HEAP_SIZE / mem_unit
		freeheap = (MEM_HEAP_SIZE - Heap.allocated) / mem_unit

class UTSName as @noauto
	var sysname: cstring
	var nodename: cstring
	var release: cstring
	var version: cstring
	var machine: cstring
	var domainname: cstring
	func mut get()
		strcpy(sysname, KERNEL_NAME)
		strcpy(nodename, "???")
		strcpy(release, KERNEL_VERSION)
		strcpy(version, KERNEL_VERSION)
		strcpy(machine, MACHINE_TYPE)
		strcpy(domainname, "-no domain-")

class TaskInfo as @noauto
	var name: cstring
	var pid, ppid, mode: int
	var status: TaskStatus
	var mem: int
	var cpu: int
	var life: TimeValue
	func mut get(_pid: int) -> int
		for t in TaskManager.get_task(_pid)
			strcpy(name, t.name)
			pid = t.pid
			ppid = -1
			for p in t.parent
				ppid = p.pid
			status = t.status
			mode = 1
		#	if t.kernel_mode
		#		mode = 0
			mem = t.pages_alloced()
			cpu = t.cpu_load
			life = t.time_all
			return 0
		return -1

class MountInfo as @noauto
	var major, minor: int
	var dir: cstring
	func mut get(_index: int) -> int
		var m = &FileSystem.mounts[_index]
		for dev in m.dev
			major = dev.major
			minor = dev.minor
			for d in m.dest
				d.get_path(dir)
			return 0
		return -1


class StatData as @noauto
	var name: cstring
	var type: int
	var size: int
	var inode: int
	var mp_inode: int
	var time: int
	func mut get(filename: cstring, cur_dir: FileEntry) -> int
		for e in FileSystem.get(filename, cur_dir)
			strcpy(name, e.name)
			type = int(e.type)
			size = e.size
			inode = e.inode
			return 0
		#panic(filename)
		return 1

#var _stat_data: StatData
#
#func int_syscall()
#	while true
#		#show_pvl()
#		int r = 0
#		
#		#int pid = (SysCallTask.tss.prev >> 3) - NUM_PRE_GDT_ENTRIES
#		var caller = &TaskManager.tasks[Scheduler.running_pid]
#		#printi(pid)
#		int index = caller.tss.eax
#		int param1 = caller.tss.ebx
#		int param2 = caller.tss.ecx
#		int param3 = caller.tss.edx
#		int param4 = caller.tss.esi
#		#printi(RunningPid)
##		prints(" ")
##		printi(index)
##		prints(" ")


#		#TextColor = 4
##		prints("<<")
##		prints(caller.name)
##		prints(":")
##		printi(index)
##		prints(">>")
##		TextColor = 7
#		#while true
#		#	nil
#		
#		if TaskManager.ack_hw_irq >= 0
#			#prints(" <ACK> ")
#			irq.end_of_interrupt(TaskManager.ack_hw_irq)
#			TaskManager.ack_hw_irq = -1
#		
#		# task switch?
#		if caller.status != TASK_STATUS_RUNNING
#			#prints("S")
#			int pid_next = Scheduler.get_next_task(Scheduler.running_pid)
#			Scheduler.reconnect_tasks(pid_next, sys_call_task)
#			#printi(pid_next)
#
#		# back
#		caller.tss.eax = r
#		
#		#prints(">")
#		asm {
#		__sys_call_return:
#			iret
#		}
#		#prints("<")

use common
use dev.block
use mem.memory
use mem.paging
use mem.heap
use mem.shared
use task.task
use task.manager
use fs.fs
use fs.access
use time.timevalue
use time.timer

use io.text

func sys_hi() -> int64
	TextMode.text_color = 0x04
	prints("  <SYSCALL HI>  ")
	TextMode.text_color = 0x07
	return 0

func sys_nanosleep(out t: Task, p1: int64, p2: int64) -> int64
	var tv = _i2p(p1) as TimeValue&
	tv.add(KernelTimer.tv)
	t.set_wait(WaitingMode.TIME, tv.sec, tv.nanosec, 0)
	return 0

func sys_stime(addr: int64) -> int64
	KernelTimer.update()
	var tv = _i2p(addr) as TimeValue&
	tv = KernelTimer.tv
	#return -EFAULT
	return 0

func sys_exit(out t: Task, r: int)
	TaskManager.die(t, r)

func sys_waitpid(out t: Task, _pid: int, status_addr: int64, options: int) -> int64
	for o in TaskManager.get_task(_pid)
		# already (un-) dead?
		if o.status == TaskStatus.ZOMBIE
			var p = _i2p(status_addr) as int&
			p = o.return_status
			o.clean_up_deep()
			t.activate()
			return 0
		
		# don't block?
		if (options & 1) > 0
			return -2

		t.set_wait(WaitingMode.TASK_EXIT, _pid, status_addr, 0)
		return 0
	return -ECHILD


func sys_execute(out t: Task, faddr: int64, fd_in: int, fd_out: int) -> int64
	let h = t.sys_open(faddr, O_RDONLY)
	if h < 0
		return -ENOENT
	for of in t.handles[h]
		var filename: cstring
		of.entry.get_path(filename)
		var addr = TASK_IMAGE_POS # task space...
		for tt in TaskManager.add_user_task(filename, addr, &t)
			memcpy(&tt.arg, _i2p(faddr), sizeof(cstring))
			var code = tt.page_root_dir.virtual_to_physical(TASK_MEMORY_OFFSET)
			while true
				let r = of.read(code, 1024)
				if r <= 0
					break
				code += r
			t.sys_close(h)
			
		#	var of_in = get_handle(fd_in)
		#	var of_out = get_handle(fd_out)
		#	tt.add_handle(of_in)
		#	tt.add_handle(of_out)
	
			#tt.activate()
			return tt.pid
		else
			t.sys_close(h)
			return -ENOMEM
	t.sys_close(h)
	return -1

func sys_getcwd(out t: Task, addr: int64) -> int64
	var pf = _i2p(addr) as cstring&
	for d in t.cur_dir
		d.get_path(pf)
		return 0
	return -EFAULT

func sys_ipc(out t: Task, cmd: int, p1: int64, p2: int64, p3: int) -> int64
	if cmd == SHMGET
		return SharedMemory.shm_get(p1, p2, p3, t.pid)
	else if cmd == SHMAT
		for r in t.shmem
			if !r.s
				r.s = SharedMemory.get(p1)
				for s in r.s
					r.vaddr = t.page_root_dir.find_unmapped_space(0x00000000e0000000, s.size) #0xa0000000
					if r.vaddr == -1
						return -ENOMEM
					s.refcount ++
					t.page_root_dir.map_linear(r.vaddr, s.physical_addr, s.size, PageFlags.WRITABLE | PageFlags.USER)
					
					var o = _i2p(p2) as int64&
					o = r.vaddr
#					if !t.page_root_dir.memcpy2task(p2, &r.dest, 4)
#						return -EFAULT
					return 0
				return -ENOENT
		return -1
	else if cmd == SHMDT
		for r in t.shmem
			for s in r.s
				if r.vaddr == p1
					t.page_root_dir.unmap(r.vaddr, s.size, false)
					s.unref()
					r.s = nil
					return 0
		return -1
	else if cmd == 1001 # wait-for-message
		t.set_wait(WaitingMode.MESSAGE, 0, 0, 0)
		return 0
	else if cmd == 1002 # yield / wake-up
		for tt in TaskManager.get_task(p1)
			tt.activate()
			t.set_wait(WaitingMode.TIME, 0, 0, 0)
			return 0
		return -1
	return -EINVAL

func sys_blockinfo(major: int, minor: int, addr: int64) -> int64
	var bd = _i2p(addr) as BlockDevice&
	for d in BlockDevManager.get(major, minor)
		memcpy(bd as void&, d as void&, sizeof(BlockDevice))
		return 0
	return -1

class SysInfo as @noauto
	var uptime: int
	var loads: int[3]
	var totalram, freeram, sharedram, bufferram: int
	var totalswap, freeswap: int
	var procs: int
	var totalhigh, freehigh: int
	var mem_unit: int
	var pad: int[2]
	var totalheap, freeheap: int
	func mut get()
		KernelTimer.update()
		uptime = KernelTimer.tv.sec
		for l in loads
			l = 0
		mem_unit = 1024 #PAGE_SIZE
		totalram = memory_size / mem_unit
		freeram = (memory_size - Paging.get_used()) / mem_unit
		sharedram = SharedMemory.get_used() / mem_unit
		bufferram = 0
		totalswap = 0
		freeswap = 0
		procs = 0
		for t in TaskManager.tasks
			if t.status != TaskStatus.UNUSED
				procs ++
		totalhigh = 0
		freehigh = 0
		totalheap = MEM_HEAP_SIZE / mem_unit
		freeheap = (MEM_HEAP_SIZE - Heap.allocated) / mem_unit

class UTSName as @noauto
	var sysname: cstring
	var nodename: cstring
	var release: cstring
	var version: cstring
	var machine: cstring
	var domainname: cstring
	func mut get()
		strcpy(sysname, KERNEL_NAME)
		strcpy(nodename, "???")
		strcpy(release, KERNEL_VERSION)
		strcpy(version, KERNEL_VERSION)
		strcpy(machine, MACHINE_TYPE)
		strcpy(domainname, "-no domain-")

class TaskInfo as @noauto
	var name: cstring
	var pid, ppid, mode: int
	var status: TaskStatus
	var mem: int
	var cpu: int
	var life: TimeValue
	func mut get(_pid: int) -> int
		for t in TaskManager.get_task(_pid)
			strcpy(name, t.name)
			pid = t.pid
			ppid = -1
			for p in t.parent
				ppid = p.pid
			status = t.status
			mode = 1
		#	if t.kernel_mode
		#		mode = 0
			mem = t.pages_alloced()
			cpu = t.cpu_load
			life = t.time_all
			return 0
		return -1

class MountInfo as @noauto
	var major, minor: int
	var dir: cstring
	func mut get(_index: int) -> int
		var m = &FileSystem.mounts[_index]
		for dev in m.dev
			major = dev.major
			minor = dev.minor
			for d in m.dest
				d.get_path(dir)
			return 0
		return -1



use common
use dev.block
use mem.memory
use mem.paging
use mem.heap
use mem.shared
use task.task
use task.manager
use fs.fs
use fs.access
use time.timevalue
use time.timer

use op_fs
use io.text

func sys_hi() -> int64
	TextMode.text_color = 0x04
	prints("  <SYSCALL HI>  ")
	TextMode.text_color = 0x07
	return 0

func sys_stime(addr: int64) -> int64
	KernelTimer.update()
	var tv = _i2p(addr) as TimeValue&
	tv = KernelTimer.tv
	#return -EFAULT
	return 0

func sys_ipc(out t: Task, cmd: int, p1: int64, p2: int64, p3: int) -> int64
	if cmd == SHMGET
		return SharedMemory.shm_get(p1, p2, p3, t.pid)
	else if cmd == SHMAT
		for r in t.shmem
			if !r.s
				r.s = SharedMemory.get(p1)
				for s in r.s
					r.vaddr = t.page_root_dir.find_unmapped_space(0x00000000e0000000, s.size) #0xa0000000
					if r.vaddr == -1
						return -ENOMEM
					s.refcount ++
					t.page_root_dir.map_linear(r.vaddr, s.physical_addr, s.size, PageFlags.WRITABLE | PageFlags.USER)
					
					var o = _i2p(p2) as int64&
					o = r.vaddr
#					if !t.page_root_dir.memcpy2task(p2, &r.dest, 4)
#						return -EFAULT
					return 0
				return -ENOENT
		return -1
	else if cmd == SHMDT
		for r in t.shmem
			for s in r.s
				if r.vaddr == p1
					t.page_root_dir.unmap(r.vaddr, s.size, false)
					s.unref()
					r.s = nil
					return 0
		return -1
	else if cmd == 1001 # wait-for-message
		t.set_wait(WaitingMode.MESSAGE, 0, 0, 0)
		return 0
	else if cmd == 1002 # yield / wake-up
		for tt in TaskManager.get_task(p1)
			tt.activate()
			t.set_wait(WaitingMode.TIME, 0, 0, 0)
			return 0
		return -1
	return -EINVAL

func sys_blockinfo(major: int, minor: int, addr: int64) -> int64
	var bd = _i2p(addr) as BlockDevice&
	for d in BlockDevManager.get(major, minor)
		memcpy(bd, &d, sizeof(BlockDevice))
		return 0
	return -1

class SysInfo as @noauto
	var uptime: int
	var loads: int[3]
	var totalram, freeram, sharedram, bufferram: int
	var totalswap, freeswap: int
	var procs: int
	var totalhigh, freehigh: int
	var mem_unit: int
	var pad: int[2]
	var totalheap, freeheap: int
	func mut get()
		KernelTimer.update()
		uptime = KernelTimer.tv.sec
		for l in loads
			l = 0
		mem_unit = 1024 #PAGE_SIZE
		totalram = memory_size / mem_unit
		freeram = (memory_size - Paging.get_used()) / mem_unit
		sharedram = SharedMemory.get_used() / mem_unit
		bufferram = 0
		totalswap = 0
		freeswap = 0
		procs = 0
		for t in TaskManager.tasks
			if t.status != TaskStatus.UNUSED
				procs ++
		totalhigh = 0
		freehigh = 0
		totalheap = MEM_HEAP_SIZE / mem_unit
		freeheap = (MEM_HEAP_SIZE - Heap.allocated) / mem_unit

class UTSName as @noauto
	var sysname: cstring
	var nodename: cstring
	var release: cstring
	var version: cstring
	var machine: cstring
	var domainname: cstring
	func mut get()
		strcpy(sysname, KERNEL_NAME)
		strcpy(nodename, "???")
		strcpy(release, KERNEL_VERSION)
		strcpy(version, KERNEL_VERSION)
		strcpy(machine, MACHINE_TYPE)
		strcpy(domainname, "-no domain-")

class TaskInfo as @noauto
	var name: cstring
	var pid, ppid, mode: int
	var status: TaskStatus
	var mem: int
	var cpu: int
	var life: TimeValue
	func mut get(_pid: int) -> int
		for t in TaskManager.get_task(_pid)
			strcpy(name, t.name)
			pid = t.pid
			ppid = -1
			for p in t.parent
				ppid = p.pid
			status = t.status
			mode = 1
		#	if t.kernel_mode
		#		mode = 0
			mem = t.pages_alloced()
			cpu = t.cpu_load
			life = t.time_all
			return 0
		return -1

class MountInfo as @noauto
	var major, minor: int
	var dir: cstring
	func mut get(_index: int) -> int
		var m = &FileSystem.mounts[_index]
		for dev in m.dev
			major = dev.major
			minor = dev.minor
			for d in m.dest
				d.get_path(dir)
			return 0
		return -1



use common
use common.macros
use io.text
use cpu
use dev.block
use mem.heap
use mem.paging
#use mem.shared
use task.task
use task.manager
use task.scheduler
use syscall.operations
#use irq.irq

use fs # experiment

#let SYSCALL_STACK_SIZE = 65536


# syscall:
#  (cs = STAR...)
#  (ss = STAR...)
#  (rflags = ..MSTAR)
#  (cpl = 0)
#  rcx = rip
#  r11 = rflags
#  rip = LSTAR

# sysret:
#  (cs = STAR...)
#  (ss = STAR...)
#  (cpl = 3)
#  rflags = r11
#  rip = rcx


class Syscall
	let STACK_SIZE = 4096
	
	class Frame
		reg8ff: int64[8]
		rsi, rdi, rbp, rdx, rcx, rbx, rax: int64
	
	var static stack: void&
	var static rsp: void& # kernel/handler
	
	var static task_frame_rsp: void* # task stack + pushed frame
	
	func static init()
		stack := Heap.malloc(STACK_SIZE)
		rsp := _i2p(_p2i(stack) + STACK_SIZE)
		
		Cpu.enable_syscall()
		Cpu.write_msr(Cpu.MSR.STAR, 0x0010000800000000) # segments
		Cpu.write_msr(Cpu.MSR.LSTAR, _p2i(raw_function_pointer(syscall_handler)))
		Cpu.write_msr(Cpu.MSR.SF_MASK, (1 << 9) + (1 << 10)) # mask irq + direction flag
#		let x = Cpu.read_msr(Cpu.MSR.STAR)
#		printh(&x, 8)
#		prints(" STAR\n")
#		let x2 = Cpu.read_msr(Cpu.MSR.LSTAR)
#		printh(&x2, 8)
#		prints(" LSTAR\n")
#		let x3 = Cpu.read_msr(Cpu.MSR.SF_MASK)
#		printh(&x3, 8)
#		prints("\n")
##		for pp in raw_function_pointer(syscall_test)
#			printh(pp, 8)


	func static @noframe syscall_handler()
		asm {
			cli
		}
		# save frame on task's stack
		push_general_purpose_registers()
	
		# save task stack pointer
		asm {
			mov rax, rsp
			mov __temp_p__, rax
		}
		Syscall.task_frame_rsp = __temp_p__
		
		# switch to kernel/syscall stack
		__temp_p__ = Syscall.rsp
		asm {
			mov rsp, __temp_p__
			mov rbp, rsp
		}
	
		# no local variables allowed! (rbp still from task-frame)
#		__temp_i64__ = Syscall.handle(__temp_p__ as Syscall.Frame&)
		Syscall.handle_meta(Syscall.task_frame_rsp as Syscall.Frame&)

		# switch to task stack
		__temp_p__ = Syscall.task_frame_rsp
		asm {
			mov rax, __temp_p__
			mov rsp, rax
		}
	
		pop_general_purpose_registers()
		asm {
			#mov rax, __temp_i64__ # return value -> rax
			#add rsp, 0x08
		
			db 0x48
			sysret
		}




	func static handle_meta(out frame: Frame)
		TextMode.text_color = 0x02
#		prints("  <sc ")
#		printh(&frame.rax, 2)
#		prints(">  ")
		TextMode.text_color = 0x07
		let r = handle(frame)
		frame.rax = r
		for t in Scheduler.cur
			if t.status != TaskStatus.RUNNING and t.status != TaskStatus.IDLE
				return_to_idle(frame)
				#panic("???")
#		TextMode.text_color = 0x02
#		prints("  <sc ret>  ")
#		TextMode.text_color = 0x07

#		for t in Scheduler.cur
#			if t.pid == 0
#				printh(&frame, sizeof(Frame))
				#panic("x")
	
	func static return_to_idle(out frame: Frame)
#		TextMode.text_color = 0x02
#		prints("  <sc ret idle>  ")
#		TextMode.text_color = 0x07
		
		# prepare current task to be awoken by returning from a timer interrupt
		for t in Scheduler.cur
			memcpy(&t.frame.reg8ff, &frame.reg8ff, sizeof(int64) * (8 + 7))
			#t.syscall_rsp
			t.frame.rsp = _p2i(Syscall.task_frame_rsp) + sizeof(Frame)
			t.frame.rip = frame.rcx
			t.frame.rflags = frame.reg8ff[3] # r11
		
		Scheduler.cur = nil
		
#		# wait for timer interrupt
#		prints(">> IDLE...")
#		asm {
#			sti
#			jmp $
#		}	

#		panic("TODO iret idle")
		Scheduler.cur = &TaskManager.tasks[0]
		
		for t in Scheduler.cur
			__temp_p__ = t.page_root_dir
			asm {
				mov rax, __temp_p__
				mov cr3, eax
				jmp _flush_aaa
				_flush_aaa:
			}
			
			__temp_i64__ = t.frame.rip
			__temp_p__ = _i2p(t.frame.rsp)
			asm{
				#cli
				#sti
				push 0x0000001b #0x1b # ss + ring3
				mov rax, __temp_p__
				push rax # rsp
				push 0x00003200 # flags: iopl=3, iterrupts=1
				#push 0x00003000#0x202 # flags: iopl=3, iterrupts=1
				push 0x00000023 #0x23 # cs + ring3
				mov rax, __temp_i64__
				push rax # rip
			#	jmp $
				db 0x48
				iret
			}
			
			
			Syscall.task_frame_rsp = _i2p(t.frame.rsp - sizeof(Frame))
			var next_frame = Syscall.task_frame_rsp as Frame&
			memcpy(&next_frame.reg8ff, &t.frame.reg8ff, sizeof(int64) * (8 + 7))
		
		
		# switch to task stack
		__temp_p__ = Syscall.task_frame_rsp
		asm {
			mov rax, __temp_p__
			mov rsp, rax
		}
	
		pop_general_purpose_registers()
		asm {
			#mov rax, __temp_i64__ # return value -> rax
			#add rsp, 0x08
		
			db 0x48
			sysret
		}
		
		for t in Scheduler.cur
			if t.first_time_running
				panic("x432")
			else
				Syscall.task_frame_rsp = t.syscall_rsp
				var next_frame = Syscall.task_frame_rsp as Frame&
				memcpy(&next_frame.reg8ff, &t.frame.reg8ff, sizeof(int64) * (8 + 7))
		prints(">> IDLE...")


	func static handle(frame: Frame) -> int64
		let index = int(frame.rax)
		
#		prints("\n")
#		for t in Scheduler.cur
#			printi(t.pid)
#		prints(" SC")
#		printh(&index, 2)
		
		for t in Scheduler.cur
			if index == 0x0001 # exit
				sys_exit(t, frame.rdi)
				return 0
#			else if index == 0x0002 # fork
#				return t.sys_fork()
			else if index == 0x0003 # read
				return t.sys_read(frame.rdi, frame.rsi, frame.rdx)
			else if index == 0x0004 # write
				return t.sys_write(frame.rdi, frame.rsi, frame.rdx)
			else if index == 0x0005 # open
				return t.sys_open(frame.rdi, frame.rsi)
			else if index == 0x0006 # close
				return t.sys_close(frame.rdi)
#			else if index == 0x0007 # waitpid
#				r = caller.sys_waitpid(param1, param2, param3)
			else if index == 0x0008 # create
				return t.sys_open(frame.rdi, O_CREATE | O_WRONLY | O_TRUNC)
#			else if index == 0x000a # unlink
#				r = caller.sys_unlink(param1)
			else if index == 0x000b # exec
				return sys_execute(t, frame.rdi, frame.rsi, frame.rdx)
			else if index == 0x000c # chdir
				return t.sys_set_cur_dir(frame.rdi)
				
				
#			else if index == 0x000e # mknod
#				r = caller.sys_mknod(param1, param2)
			else if index == 0x0013 # seek
				return t.sys_seek(frame.rdi, frame.rsi, frame.rdx)
			else if index == 0x0014 # getpid
				return Scheduler.running_pid
			else if index == 0x0019 # stime
				return sys_stime(frame.rdi)
#			else if index == 0x0025 # kill
#				r = caller.sys_kill(param1, param2)
#			else if index == 0x0027 # mkdir
#				r = caller.sys_mkdir(param1)
#			else if index == 0x0028 # rmdir
#				r = caller.sys_rmdir(param1)
			else if index == 0x0029 # dup
				return t.sys_dup(frame.rdi)
#			else if index == 0x002a # pipe
#				return t.sys_pipe(frame.rdi)
			else if index == 0x002d # brk
				return t.sys_brk(frame.rdi)
			else if index == 0x0033 # fcntl
				return t.sys_fcntl(frame.rdi, frame.rsi, frame.rdx)
#			else if index == 0x0043 # sigaction
#				r = caller.sys_sigaction(param1, param2)
			else if index == 0x0058 # reboot
				pass
#			else if index == 0x0066 # socket
#				r = caller.sys_socket(param1, param2, param3)
			else if index == 0x0074 # sysinfo
				var si = _i2p(frame.rdi) as SysInfo&
				si.get()
				return 0
#			else if index == 0x0075 # ipc
#				r = caller.sys_ipc(param1, param2, param3, param4)
			else if index == 0x007a # uname
				var un = _i2p(frame.rdi) as UTSName&
				un.get()
				return 0
			else if index == 0x008d # getdents
				return t.sys_getdents(frame.rdi, frame.rsi, frame.rdx)
#			else if index == 0x009e # sched_yield
#				int pid_next = Scheduler.get_next_task(Scheduler.running_pid)
#				Scheduler.reconnect_tasks(pid_next, sys_call_task)
			else if index == 0x00a2 # nanosleep
				sys_nanosleep(t, frame.rdi, frame.rsi)
				# p1 = &duration
				# p2 = &duration_more
				return 0
			else if index == 0x00b7 # getcwd
				var pf = _i2p(frame.rdi) as cstring&
				for d in t.cur_dir
					d.get_path(pf)
					return 0
				return -EFAULT
			else if index == 0x1234 # print hi
				TextMode.text_color = 0x04
				prints("  <SYSCALL HI>  ")
				TextMode.text_color = 0x07
				return 0
			else if index == 0x2001 # getarg
				memcpy(_i2p(frame.rdi), &t.arg, sizeof(cstring))
				return 0
			else if index == 0x2002 # kprint
				TextMode.prints_low(_i2p(frame.rdi) as cstring&, frame.rsi)
				return 0
			else if index == 0x2003 # kprinti
				printi(frame.rdi)
				return 0
			else if index == 0x2004 # kprintp
				printh(&frame.rdi, 8)
				return 0
			else if index == 0x2005 # taskinfo
				var ti = _i2p(frame.rsi) as TaskInfo&
				return ti.get(frame.rdi)
#			else if index == 0x2006 # exit_signal
#				r = caller.sys_exit_signal()
#				asm {
#					# don't overwrite eax with return value
#					jmp __sys_call_return
#				}
#			else if index == 0x2007 # map IRQ
#				r = irq.sys_map_irq(param1, caller, param2)
			else if index == 0x2008 # mountinfo
				var mi = _i2p(frame.rsi) as MountInfo&
				return mi.get(frame.rdi)
			else if index == 0x2009 # blockinfo
				var bd = _i2p(frame.rdx) as BlockDevice&
				for d in BlockDevManager.get(frame.rdi, frame.rsi)
					memcpy(bd as void&, d as void&, sizeof(BlockDevice))
					return 0
				return -1
			else if index == 0x200a # stat
				var pd = _i2p(frame.rsi) as StatData&
				var pf = _i2p(frame.rdi) as cstring&
				for d in t.cur_dir
					return pd.get(pf, d)
				return 1
#			else if index == 0x200b # addr2phys
#				int offset
#				r = caller.page_dir.addr2kernel(param1, &offset)
			else
				prints("<syscall>")
				printh(&index, 2)
		return -ENOSYS


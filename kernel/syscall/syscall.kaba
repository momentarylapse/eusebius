use common
use io.text
use cpu
use dev.block
use mem.heap
use mem.paging
#use mem.shared
use task.task
use task.manager
use task.scheduler
use syscall.operations
#use irq.irq

use fs # experiment

#let SYSCALL_STACK_SIZE = 65536


# syscall:
#  (cs = STAR...)
#  (ss = STAR...)
#  (rflags = ..MSTAR)
#  (cpl = 0)
#  rcx = rip
#  r11 = rflags
#  rip = LSTAR

# sysret:
#  (cs = STAR...)
#  (ss = STAR...)
#  (cpl = 3)
#  rflags = r11
#  rip = rcx



class Syscall
	let STACK_SIZE = 4096
	
	class Frame
		reg8ff: int64[8]
		rsi, rdi, rbp, rdx, rcx, rbx, rax: int64
	
	var static stack: void&
	var static rsp: void& # kernel/handler
	
	var static task_rsp: void*
	
	func static init()
		stack := Heap.malloc(STACK_SIZE)
		rsp := _i2p(_p2i(stack) + STACK_SIZE)
		
		Cpu.enable_syscall()
		Cpu.write_msr(Cpu.MSR.STAR, 0x0010000800000000)
		Cpu.write_msr(Cpu.MSR.LSTAR, _p2i(raw_function_pointer(syscall_handler)))
		Cpu.write_msr(Cpu.MSR.SF_MASK, (1 << 9) + (1 << 10)) # mask irq + direction flag
#		let x = Cpu.read_msr(Cpu.MSR.STAR)
#		printh(&x, 8)
#		prints(" STAR\n")
#		let x2 = Cpu.read_msr(Cpu.MSR.LSTAR)
#		printh(&x2, 8)
#		prints(" LSTAR\n")
#		let x3 = Cpu.read_msr(Cpu.MSR.SF_MASK)
#		printh(&x3, 8)
#		prints("\n")
##		for pp in raw_function_pointer(syscall_test)
#			printh(pp, 8)


	func static @noframe syscall_handler()
		asm {
			cli
			# general purpose registers
			push rax
			push rbx
			push rcx # < task rip
			push rdx
			push rbp
			push rdi
			push rsi
			push r8
			push r9
			push r10
			push r11 # < task rflags
			push r12
			push r13
			push r14
			push r15
		}
	
		# switch to kernel/syscall stack
		asm {
			mov rax, rsp
			mov __temp_p__, rax
		}
		Syscall.task_rsp = __temp_p__
		__temp_p__ = Syscall.rsp
		asm {
			mov rsp, __temp_p__
			mov rbp, rsp
		}
	
		# no local variables allowed! (rbp still from task-frame)
#		__temp_i64__ = Syscall.handle(__temp_p__ as Syscall.Frame&)
		Syscall.handle_meta(Syscall.task_rsp as Syscall.Frame&)

		# switch to task stack
		__temp_p__ = Syscall.task_rsp
		asm {
			mov rax, __temp_p__
			mov rsp, rax
		}
	
		asm {
			# general purpose registers
			pop r15
			pop r14
			pop r13
			pop r12
			pop r11
			pop r10
			pop r9
			pop r8
			pop rsi
			pop rdi
			pop rbp
			pop rdx
			pop rcx
			pop rbx
			pop rax
			#mov rax, __temp_i64__ # return value -> rax
			#add rsp, 0x08
		
			db 0x48
			sysret
		}




	func static handle_meta(out frame: Frame)
		let r = handle(frame)
		frame.rax = r
		for t in Scheduler.cur
			if t.status != TaskStatus.RUNNING
				return_to_idle(frame)
				#panic("???")
	
	func static return_to_idle(out frame: Frame)
		panic("TODO iret idle")
		for t in Scheduler.cur
			memcpy(&t.frame.reg8ff, &frame.reg8ff, sizeof(int64) * (8 + 7))
			t.syscall_rsp := Syscall.task_rsp as void&
			
		for t in Scheduler.cur
			if t.first_time_running
				panic("x432")
			else
				Syscall.task_rsp = t.syscall_rsp
				var next_frame = Syscall.task_rsp as Frame&
				memcpy(&next_frame.reg8ff, &t.frame.reg8ff, sizeof(int64) * (8 + 7))
		prints(">> IDLE...")


	func static handle(frame: Frame) -> int64
		let index = int(frame.rax)
		
#		prints("\n")
#		for t in Scheduler.cur
#			printi(t.pid)
#		prints(" SC")
#		printh(&index, 2)
		
		for t in Scheduler.cur
			if index == 0x0001 # exit
				sys_exit(t, frame.rdi)
				return 0
#			else if index == 0x0002 # fork
#				return t.sys_fork()
			else if index == 0x0003 # read
				return t.sys_read(frame.rdi, frame.rsi, frame.rdx)
			else if index == 0x0004 # write
				return t.sys_write(frame.rdi, frame.rsi, frame.rdx)
			else if index == 0x0005 # open
				return t.sys_open(frame.rdi, frame.rsi)
			else if index == 0x0006 # close
				return t.sys_close(frame.rdi)
#			else if index == 0x0007 # waitpid
#				r = caller.sys_waitpid(param1, param2, param3)
			else if index == 0x0008 # create
				return t.sys_open(frame.rdi, O_CREATE | O_WRONLY | O_TRUNC)
#			else if index == 0x000a # unlink
#				r = caller.sys_unlink(param1)
			else if index == 0x000b # exec
				return sys_execute(t, frame.rdi, frame.rsi, frame.rdx)
			else if index == 0x000c # chdir
				return t.sys_set_cur_dir(frame.rdi)
				
				
#			else if index == 0x000e # mknod
#				r = caller.sys_mknod(param1, param2)
			else if index == 0x0013 # seek
				return t.sys_seek(frame.rdi, frame.rsi, frame.rdx)
			else if index == 0x0014 # getpid
				return Scheduler.running_pid
			else if index == 0x0019 # stime
				return sys_stime(frame.rdi)
#			else if index == 0x0025 # kill
#				r = caller.sys_kill(param1, param2)
#			else if index == 0x0027 # mkdir
#				r = caller.sys_mkdir(param1)
#			else if index == 0x0028 # rmdir
#				r = caller.sys_rmdir(param1)
			else if index == 0x0029 # dup
				return t.sys_dup(frame.rdi)
#			else if index == 0x002a # pipe
#				return t.sys_pipe(frame.rdi)
			else if index == 0x002d # brk
				return t.sys_brk(frame.rdi)
			else if index == 0x0033 # fcntl
				return t.sys_fcntl(frame.rdi, frame.rsi, frame.rdx)
#			else if index == 0x0043 # sigaction
#				r = caller.sys_sigaction(param1, param2)
			else if index == 0x0058 # reboot
				pass
#			else if index == 0x0066 # socket
#				r = caller.sys_socket(param1, param2, param3)
			else if index == 0x0074 # sysinfo
				var si = _i2p(frame.rdi) as SysInfo&
				si.get()
				return 0
#			else if index == 0x0075 # ipc
#				r = caller.sys_ipc(param1, param2, param3, param4)
			else if index == 0x007a # uname
				var un = _i2p(frame.rdi) as UTSName&
				un.get()
				return 0
			else if index == 0x008d # getdents
				return t.sys_getdents(frame.rdi, frame.rsi, frame.rdx)
#			else if index == 0x009e # sched_yield
#				int pid_next = Scheduler.get_next_task(Scheduler.running_pid)
#				Scheduler.reconnect_tasks(pid_next, sys_call_task)
			else if index == 0x00a2 # nanosleep
				sys_nanosleep(t, frame.rdi, frame.rsi)
				# p1 = &duration
				# p2 = &duration_more
				return 0
			else if index == 0x00b7 # getcwd
				var pf = _i2p(frame.rdi) as cstring&
				for d in t.cur_dir
					d.get_path(pf)
					return 0
				return -EFAULT
			else if index == 0x1234 # print hi
				TextMode.text_color = 0x04
				prints("  <SYSCALL HI>  ")
				TextMode.text_color = 0x07
				return 0
			else if index == 0x2001 # getarg
				memcpy(_i2p(frame.rdi), &t.arg, sizeof(cstring))
				return 0
			else if index == 0x2002 # kprint
				TextMode.prints_low(_i2p(frame.rdi) as cstring&, frame.rsi)
				return 0
			else if index == 0x2003 # kprinti
				printi(frame.rdi)
				return 0
			else if index == 0x2004 # kprintp
				printh(&frame.rdi, 8)
				return 0
			else if index == 0x2005 # taskinfo
				var ti = _i2p(frame.rsi) as TaskInfo&
				return ti.get(frame.rdi)
#			else if index == 0x2006 # exit_signal
#				r = caller.sys_exit_signal()
#				asm {
#					# don't overwrite eax with return value
#					jmp __sys_call_return
#				}
#			else if index == 0x2007 # map IRQ
#				r = irq.sys_map_irq(param1, caller, param2)
			else if index == 0x2008 # mountinfo
				var mi = _i2p(frame.rsi) as MountInfo&
				return mi.get(frame.rdi)
			else if index == 0x2009 # blockinfo
				var bd = _i2p(frame.rdx) as BlockDevice&
				for d in BlockDevManager.get(frame.rdi, frame.rsi)
					memcpy(bd as void&, d as void&, sizeof(BlockDevice))
					return 0
				return -1
			else if index == 0x200a # stat
				var pd = _i2p(frame.rsi) as StatData&
				var pf = _i2p(frame.rdi) as cstring&
				for d in t.cur_dir
					return pd.get(pf, d)
				return 1
#			else if index == 0x200b # addr2phys
#				int offset
#				r = caller.page_dir.addr2kernel(param1, &offset)
			else
				prints("<syscall>")
				printh(&index, 2)
		return -ENOSYS


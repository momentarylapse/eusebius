#define __STRING_CONST_AS_CSTRING__
#define __FUNCTION_POINTER_AS_CODE__
use common
use io.text
use cpu.cpu
use dev.ata
use dev.block
use dev.std_char_devs
use fs.fs
use fs.access
use fs.pipe
use mem.heap
use mem.paging
use mem.shared
use net.socket
use task.manager
##use task.scheduler
use irq.irq
use irq.error
use time.timer
##use syscall

let KALIB_LOCATION = 0x00050000

var _xxx_: int



##func load_kalib()
##	prints("loading kalib... ")
##	int h = kernel_task.open("/lib/kalib", O_RDONLY)
##	if h < 0
##		panic("can not read file /lib/kalib!")
##	int addr = KALIB_LOCATION
##	int size = 0
##	while true
##		int r = kernel_task.sys_read(h, addr, 1024)
##		if r <= 0
##			break
##		size += r
##		addr += r
##	kernel_task.sys_close(h)
##	printi(size)
##	prints("b  ok\n")

func @noframe syscall_test()
	asm{
		mov __temp_i64__, rcx
	}
	let ret_addr = __temp_i64__
	asm{
		mov rax, rsp
		mov __temp_p__, rax
	}
	printh(&__temp_p__, 8)
	#printh(&ret_addr, 8)
	prints("<syscall>")
	__temp_i64__ = ret_addr
	asm{
		mov rcx, __temp_i64__
		sysret
	}
	while true
		pass

func main()
	read_data_from_init()
	TextMode.init()
	TextMode.clear()
	
	prints("Welcome to ")
	prints(KERNEL_NAME)
	prints(" ")
	prints(KERNEL_VERSION)
	prints("   (c) by MichiSoft TM 2023\n")
	prints("memory: ")
	printi(MemorySize / 1024 / 1024)
	prints("m\n")


	#asm{
#		mov eax, 0x8000000
#		db 0x0f
#		db 0xa2
#		mov __temp_i__, eax
#		mov __temp_i2__, ecx
#		mov __temp_i3__, edx
#	}
#	prints("   cpu:  ")
#	printh(&__temp_i__, 4)
#	printh(&__temp_i2__, 4)
#	printh(&__temp_i3__, 4)
#	prints("\n")
	
	Paging.init()
	Heap.init()

#	for i in 0x01000000:0x02000000
#		var p: int* = _i2p(i)
#		*p = 3


	SharedMemory.init()


	TaskManager.init()
	Cpu.enable_sse()
	
	IrqManager.init()
	ErrorManager.init()


	BlockDevManager.init()

	InitFileAccessData()
	PipeManager.init()
	SocketManager.init()

	FileSystem.init()

	# assume a default disk layout...
	FileSystem.mount(BlockDevManager.devs[2], FileSystem.root, "ext2")
	for boot in FileSystem.get("/boot", FileSystem.root)
		FileSystem.mount(BlockDevManager.devs[1], boot, "michifs")
	else
		panic("/boot not found")
	
##	InitSysCall()
	
	StdCharDevs.init()
	
	KernelTimer.init(100)
	#IrqManager.enable()
	
#	__temp_i64__ = _p2i(raw_function_pointer(syscall_test))
#	prints("aaa:")
#	asm{
#		mov rax, __temp_i64__
#		call rax
#	}

#	TaskManager.x()
#	IrqManager.enable()

	prints("...user:\n")
	TaskManager.jump_to_user()
	asm{
		jmp $
	}
	
	Cpu.enable_syscall()
	Cpu.write_msr(Cpu.MSR.STAR, 0x0010000800000000)
	Cpu.write_msr(Cpu.MSR.LSTAR, _p2i(raw_function_pointer(syscall_test)))
	Cpu.write_msr(Cpu.MSR.CSTAR, _p2i(raw_function_pointer(syscall_test)))
	Cpu.write_msr(Cpu.MSR.SF_MASK, (1 << 9) + (1 << 10)) # mask irq + direction flag
#	let x = Cpu.read_msr(Cpu.MSR.STAR)
#	printh(&x, 8)
#	prints(" STAR\n")
#	let x2 = Cpu.read_msr(Cpu.MSR.LSTAR)
#	printh(&x2, 8)
#	prints(" LSTAR\n")
#	let x3 = Cpu.read_msr(Cpu.MSR.SF_MASK)
#	printh(&x3, 8)
#	prints("\n")
##	for pp in raw_function_pointer(syscall_test)
#		printh(pp, 8)
	prints("trying syscall....")
	#let pp = &__temp_i__
	#printh(&pp, 8)
	_xxx_ = 7
	asm{
		mov rax, rsp
		mov __temp_p__, rax
	}
	printh(&__temp_p__, 8)
	asm{
		#jmp $
		cli
		syscall
		syscall
#		mov eax, 0x00100000
#		mov [rax], 0x00000000
		syscall
	#	jmp $
	}
	if _xxx_ == 7
		pass
#		asm{
#			syscall
#			syscall
#			syscall
#		}
	asm{
		jmp $
	}
	
##	load_kalib()
##	
##	int stdin = kernel_task.open("/dev/tty", O_RDONLY)
##	int stdout = kernel_task.open("/dev/tty", O_WRONLY)
##	
##	if kernel_task.sys_execute(_p2i(&"/bin/shell"), stdin, stdout) < 0
##		panic("can not read file /bin/shell!")
##	
##	Scheduler.start()
##	panic("test")

#	for i in 0:300000000
#		pass
#	var p:int* = _i2p(0xf0000000)
#	*p = 3

	prints("  \\(^_^)/")
	#IrqManager.slow_endless_loop()
	while true
		pass
##	
##	panic("no tasks")
##
##
#define __STRING_CONST_AS_CSTRING__
#define __FUNCTION_POINTER_AS_CODE__
use common
use io.text
use cpu
use dev.ata
use dev.block
use dev.std_char_devs
use fs.fs
use fs.access
use fs.pipe
use mem.memory
use mem.heap
use mem.paging
use mem.shared
use net.socket
use task.manager
use task.scheduler
use task.task
use irq.irq
use irq.error
use time.timer
use syscall

let KALIB_LOCATION = 0x00050000

var _xxx_: int



func load_kalib()
	prints("loading kalib... ")
	
	for of in kernel_open("/lib/kalib", O_RDONLY, FileSystem.root)
		var addr = KALIB_LOCATION
		var size = 0
		while true
			let r = of.read(addr, 1024)
			if r <= 0
				break
			size += r
			addr += r
		printi(size)
		prints("b ok\n")
	else
		panic("can not read /lib/kalib")


func main()
	read_data_from_init()
	TextMode.init()
	TextMode.clear()
	
	prints("Welcome to ")
	prints(KERNEL_NAME)
	prints(" ")
	prints(KERNEL_VERSION)
	prints("   (c) by MichiSoft TM 2023\n")
	prints("memory: ")
	printi(memory_size / 1024 / 1024)
	prints("m\n")

	Paging.init()
	Heap.init()

	SharedMemory.init()


	TaskManager.init()
	Cpu.enable_sse()
	
	IrqManager.init()
	ErrorManager.init()


	BlockDevManager.init()

	InitFileAccessData()
	PipeManager.init()
	SocketManager.init()

	FileSystem.init()

	# assume a default disk layout...
	FileSystem.mount(BlockDevManager.devs[2], FileSystem.root, "ext2")
	for boot in FileSystem.get("/boot", FileSystem.root)
		FileSystem.mount(BlockDevManager.devs[1], boot, "michifs")
	else
		panic("/boot not found")
	
	StdCharDevs.init()

	Syscall.init()

	load_kalib()
	
	#--------- experiments:

	TaskManager.add_idle_task()

#	TaskManager.add_dummy()
	
	if false
		prints("loading dummy process... ")
		for of in kernel_open("/bin/simple", O_RDONLY, FileSystem.root)
			for t in TaskManager.add_user_task("simple", TASK_MEMORY_OFFSET, nil)
				var code = t.page_root_dir.virtual_to_physical(TASK_MEMORY_OFFSET)
				let r = of.read(code, 4096)
				#printh(code, r)
				prints("ok\n")
			else
				panic("task")
		else
			panic("can not open /bin/simple")


	if true
		prints("loading shell... ")
		for of in kernel_open("/bin/shell", O_RDONLY, FileSystem.root)
			for t in TaskManager.add_user_task("shell", TASK_MEMORY_OFFSET, nil)
				var code = t.page_root_dir.virtual_to_physical(TASK_MEMORY_OFFSET)
				let r = of.read(code, 65536)
				#printh(code, r)
				prints("ok\n")
			else
				panic("task")
		else
			panic("can not open /bin/shell")

#	printi(_p2i(FileSystem.get("/", FileSystem.root)))	
#	prints("\n")
#	for e in FileSystem.get("/", FileSystem.root)
#		prints(e.name)
#		printi(int(e.type))
#		prints("\n")
	
	KernelTimer.init(raw_function_pointer(Scheduler.int_timer), 50)
	Scheduler.run()
	

##	int stdin = kernel_task.open("/dev/tty", O_RDONLY)
##	int stdout = kernel_task.open("/dev/tty", O_WRONLY)
##	
##	if kernel_task.sys_execute(_p2i(&"/bin/shell"), stdin, stdout) < 0
##		panic("can not read file /bin/shell!")
##	
##	Scheduler.start()
##	panic("test")

#	for i in 0:300000000
#		pass
#	var p:int* = _i2p(0xf0000000)
#	*p = 3

	prints("  \\(^_^)/")
	#IrqManager.slow_endless_loop()
	while true
		pass
##	
##	panic("no tasks")
##
##

#define __OS__
use "base.kaba"
use "text_mode.kaba"
use "base_mem.kaba"
#define __STRING_CONST_AS_CSTRING__

const int PAGE_SIZE = 4096
const int PAGE_TABLE_ENTRIES = 1024
const int MAX_PAGE_MASKS = 32768 // 2^32 / PAGE_SIZE / 32
// 1 mask = 32 pages = 128k

//const int KERNEL_PAGE_DIRECTORY = 0x00200000
PageDirectory *KernelPageDir

int ceil_quot(int n, int m)
	return (n + m - 1) / m

class PageTable
	int[PAGE_TABLE_ENTRIES] e
	
	void init()
		for i in 0:PAGE_TABLE_ENTRIES
			e[i] = 0
	
	int count_entries()
		int num_entries = 0
		for i in 0:PAGE_TABLE_ENTRIES
			if e[i] == 0
				return i
		return PAGE_TABLE_ENTRIES

class PageDirectory : PageTable

	// source = task-space
	// dest = kernel-space
	void map_lin(int source, int dest, int size, bool writable)
		source = source & 0xfffff000
		int dir_no = source >> 22
		int page_no = (source >> 12) & 0x000003ff
		dest = dest & 0xfffff000
		int npages = ceil_quot(size, PAGE_SIZE)
		int flags = 5
		if writable
			flags = 7
		while npages > 0
			if e[dir_no] == 0
				int pos = Paging.alloc_page()
				PageTable *pt = _i2p(pos)
				e[dir_no] = pos + flags
			else
				pt = _i2p(e[dir_no] & 0xfffff000)
			int i0 = page_no
			int i1 = page_no + npages
			if i1 > PAGE_TABLE_ENTRIES
				i1 = PAGE_TABLE_ENTRIES
			for i in i0:i1
				pt.e[i] = dest + flags
				dest += PAGE_SIZE
			npages -= i1-i0
			dir_no ++
			page_no = 0

	// start = task-space
	bool map_by_alloc(int start, int size, bool writable)
		start = start & 0xfffff000
		int dir_no = start >> 22
		int page_no = (start >> 12) & 0x000003ff
		int npages = ceil_quot(size, PAGE_SIZE)
		int flags = 5
		if writable
			flags = 7
		while npages > 0
			if e[dir_no] == 0
				int pos = Paging.alloc_page()
				PageTable *pt = _i2p(pos)
				e[dir_no] = pos + flags
			else
				pt = _i2p(e[dir_no] & 0xfffff000)
			int i0 = page_no
			int i1 = page_no + npages
			if i1 > PAGE_TABLE_ENTRIES
				i1 = PAGE_TABLE_ENTRIES
			for i in i0:i1
				int dest = Paging.alloc_page()
				if dest == -1
					unmap(start, size, true)
					return false
				pt.e[i] = dest + flags
			npages -= i1-i0
			dir_no ++
			page_no = 0
		return true
	
	void unmap(int start, int size, bool dealloc)
		start = start & 0xfffff000
		int dir_no = start >> 22
		int page_no = (start >> 12) & 0x000003ff
		int npages = ceil_quot(size, PAGE_SIZE)
		while npages > 0
			int pt_pos = e[dir_no] & 0xfffff000
			PageTable *pt = _i2p(pt_pos)
			int i0 = page_no
			int i1 = page_no + npages
			if i1 > PAGE_TABLE_ENTRIES
				i1 = PAGE_TABLE_ENTRIES
			for i in i0:i1
				if pt.e[i] != 0
					if dealloc
						Paging.free_page(pt.e[i] & 0xfffff000)
					pt.e[i] = 0
			if pt.count_entries() == 0
				Paging.free_page(pt_pos)
			npages -= i1-i0
			dir_no ++
			page_no = 0

	int addr2kernel(int addr)
		int dir_no = addr >> 22
		int page_no = (addr >> 12) & 0x000003ff
		int offset = addr & 0x00000fff
		PageTable *pt = _i2p(e[dir_no] & 0xfffff000)
		int n = pt.e[page_no] & 0xfffff000
		return n + offset

	void memcpy2kernel(cstring *o, int addr, int size)
		while size > 0
			int dir_no = addr >> 22
			int page_no = (addr >> 12) & 0x000003ff
			int c = addr & 0x00000fff
			int n = e[dir_no] & 0xfffff000
			PageTable *pt = _i2p(n)
			n = pt.e[page_no] & 0xfffff000
			cstring *pp = _i2p( n + c)
			int num = PAGE_SIZE - c
			if num > size
				num = size
			for i in 0:num
				o[i] = pp[i]
			addr += num
			size -= num
			o = &o[num]

	void memcpy2task(int addr, cstring *p, int size)
		while size > 0
			int dir_no = addr >> 22
			int page_no = (addr >> 12) & 0x000003ff
			int c = addr & 0x00000fff
			int n = e[dir_no] & 0xfffff000
			PageTable *pt = _i2p(n)
			n = pt.e[page_no] & 0xfffff000
			cstring *pp = _i2p( n + c)
			int num = PAGE_SIZE - c
			if num > size
				num = size
			for i in 0:num
				pp[i] = p[i]
			addr += num
			size -= num
	
	int get_last_table()
		int last_table = -1
		for i in 0:PAGE_TABLE_ENTRIES
			if e[i] == 0
				last_table = i - 1
				break
		if last_table < 0
			return 0
		return last_table
	
	int count_pages()
		int last_table = get_last_table()
		//return last_table
		int pos = (e[last_table] & 0xfffff000)
		PageTable *pt = _i2p(pos)
		int num_entries = pt.count_entries()
		return last_table * PAGE_TABLE_ENTRIES + num_entries
	
	void clone(PageDirectory *pd2, int above)
		int mem = (pd2.count_pages() - count_pages()) * PAGE_SIZE
		grow(mem, true)
		for i in 0:PAGE_TABLE_ENTRIES
			if pd2.e[i] == 0
				break
			PageTable *pt = _i2p(e[i] & 0xfffff000)
			PageTable *pt2 = _i2p(pd2.e[i] & 0xfffff000)
			for j in 0:PAGE_TABLE_ENTRIES
				if pt2.e[j] == 0
					break
				if pt2.e[j] >= above
					memcpy(_i2p(pt.e[j] & 0xfffff000), _i2p(pt2.e[j] & 0xfffff000), PAGE_SIZE)
	
	void grow(int req_size, bool writable)
		int req_num_pages = ceil_quot(req_size, PAGE_SIZE)
		int last_table = get_last_table()
		int flags = 5
		if writable
			flags = 7
		PageTable *pt = _i2p(e[last_table] & 0xfffff000)
		while req_num_pages > 0
			int in_use = pt.count_entries()
			int num = PAGE_TABLE_ENTRIES - in_use
			if num > req_num_pages
				num = req_num_pages
			for i in 0:num
				int pos = Paging.alloc_page()
				pt.e[i + in_use] = pos + flags
			req_num_pages -= num
			
			if req_num_pages > 0
				last_table ++
				pos = Paging.alloc_page()
				pt = _i2p(pos)
				pt.init()
				e[last_table] = pos + 7
	
	void show()
		printh(self, 64)
		prints("...\n")
		for i in 0:4
			PageTable *pt = _i2p(e[i] & 0xfffff000)
			printh(pt, 64)
			prints("...\n")

class PageController
	int[MAX_PAGE_MASKS] mask
	int num_masks
	int mask_occupation
	int alloc_count, free_count
	void init()
		if VerbosityLevel >= 1
			prints("Paging")
		num_masks = MemorySize / PAGE_SIZE / 32
		MemorySize = num_masks * PAGE_SIZE * 32 // easier memory management...
		for i in 0:num_masks
			mask[i] = 0
		
		// reserve 8mb for kernel
		for i in 0:64
			mask[i] = 0xffffffff
		mask_occupation = 64
		
		alloc_count = 0
		free_count = 0
			
		// flat paging
		int nmax = MemorySize / PAGE_SIZE / 1024
		KernelPageDir = create_page_directory(MemorySize, true)
		//printi(_p2i(KernelPageDir))
	
		asm{
			mov eax, KernelPageDir
			mov cr3, eax
			mov eax, cr0
			or eax, 0x80000000
			mov cr0, eax
		
			// flush cpu prefetch
			jmp _flush
			_flush:
		}
		if VerbosityLevel >= 1
			prints(" ok\n")
		
	int alloc_page()
		bool ok = true
		for i in mask_occupation:num_masks
			if mask[i] == 0xffffffff
				continue
			for j in 0:32
				int m = 1 << j
				if (mask[i] & m) == 0
					mask_occupation = i
					mask[i] = mask[i] | m
					alloc_count ++
					return (i * 32 + j) * PAGE_SIZE
		return -1
	
	void free_page(int pos)
		int page_no = pos / PAGE_SIZE
		int mask_no = page_no / 32
		if mask_no > num_masks or mask_no < 0
			return
		int offset = page_no & 0x0000001f // % 32
		int m = 1 << offset
		if (mask[mask_no] & m) != 0
			free_count ++
			mask[mask_no] -= m
			if mask_no < mask_occupation
				mask_occupation = mask_no
		else
			prints("  -e-  ")
			printh(&mask[mask_no], 4)
			prints("  ")
			printh(&m, 4)
			prints("  ")
			printi(pos)
			prints(" ")
			printi(mask_no)
			prints(" ")
			printi(offset)
			panic("invalid free page")
	
	void show_stats()
		prints("alloc ")
		printi(alloc_count)
		prints("/")
		printi(free_count)
		prints(" ")
		alloc_count = 0
		free_count = 0
			
	int alloc_chunk(int size)
		//int num_pages_req = (size - PAGE_SIZE + 1) / PAGE_SIZE//ceil_quot(size, PAGE_SIZE)
		//int num_masks_req = (num_pages_req - 31) / 32 //ceil_quot(num_pages_req, 32)
		int num_pages_req = ceil_quot(size, PAGE_SIZE)
		int num_masks_req = ceil_quot(num_pages_req, 32)
		for i in 0:num_masks-num_masks_req
			bool ok = true
			for j in 0:num_masks_req
				if mask[i+j] != 0
					ok = false
					break
			if ok
				for j in 0:num_masks_req
					mask[i+j] = 0xffffffff
				return i * PAGE_SIZE * 32
		return 0

	void __free_chunk(int p, int size)
		int offset = p / PAGE_SIZE / 32
		int num_pages_req = (size - PAGE_SIZE + 1) / PAGE_SIZE//ceil_quot(size, PAGE_SIZE)
		int num_masks_req = (num_pages_req - 31) / 32 //ceil_quot(num_pages_req, 32)
		for j in 0:num_masks_req
			mask[offset + j] = 0

	int get_used()
		int n = 0
		for i in 0:num_masks
			if mask[i] == 0
				continue
			if mask[i] == 0xffffffff
				n += 32
			else
				for j in 0:32
					int m = 1 << j
					if (mask[i] & m) > 0
						n ++
		return n * PAGE_SIZE
	
	PageDirectory *create_page_directory(int size, bool writable)
		int pos = alloc_page()
		PageDirectory *pd = _i2p(pos)
		pd.init()
		pd.map_lin(0, 0, size, writable)
		return pd
			

PageController Paging


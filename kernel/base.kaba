#define __OS__
#define __CODE_ORIGIN__ 0x00010000
#define __VARIABLE_OFFSET__ 0x00100000
#define __ADD_ENTRY_POINT__
#define __STRING_CONST_AS_CSTRING__

const int EWOULDBLOCK = 128
const int ENOSPC = 127
const int EACCES = 126
const int EEXIST = 125
const int EINVAL = 124
const int ENOENT = 123
const int ENOMEM = 122
const int ESRCH = 121
const int ECHILD = 120
const int EBADF = 119
const int ENFILE = 118
const int EFAULT = 117
const int ENOSYS = 116

const int F_GETFL = 1
const int F_SETFL = 2

const int SHMAT = 9
const int SHMDT = 10
const int SHMGET = 11

const int SHM_DEST = 1<<11
const int IPC_CREAT = 1<<12
const int IPC_EXCL = 1<<13


int MemorySize // in bytes

const int KERNEL_MEM = 0x00800000 // 8mb


//--------------------------------------------------------------
// Low Level

int _temp_port_no_
int _temp_port_data_

void outportb(int port, char data)
	_temp_port_no_ = port
	_temp_port_data_ = data
	asm{
		mov eax, _temp_port_data_
		mov edx, _temp_port_no_
		out dx, al
	}

void outportd(int port,int data)
	_temp_port_no_ = port
	_temp_port_data_ = data
	asm{
		mov eax, _temp_port_data_
		mov edx, _temp_port_no_
		out dx, eax
	}

char inportb(int port)
	_temp_port_no_ = port
	asm{
		mov edx, _temp_port_no_
		xor eax, eax
		in al, dx
		mov _temp_port_data_, eax
	}
	return _temp_port_data_

int inportd(int port)
	_temp_port_no_ = port
	asm{
		mov edx, _temp_port_no_
		in eax, dx
		mov _temp_port_data_, eax
	}
	return _temp_port_data_



void read_data_from_init()
	asm{
		mov eax, [0x00005100]
		shl eax, 0x0a
		mov MemorySize, eax
	}


void memcpy(cstring *dest, cstring *source, int size)
	for n in 0:size
		dest[n] = source[n]
	/*if size > 0
		temp_i=size
		temp_p=source
		temp_p2=dest
		asm{
			mov ecx, temp_i
			mov eax, temp_p
			mov ebx, temp_p2
			_mem_cpy_loop:
				mov.b dl, [eax]
				mov.b [ebx], dl
				inc eax
				inc ebx
				loop _mem_cpy_loop
		}*/

int strlen(cstring *s)
	for i in 0:256
		if s[i] == 0
			return i
	return 256

void strcpy(cstring *a, cstring *b)
	for i in 0:256
		a[i] = b[i]
		if b[i] == 0
			break

void strcat(cstring *a, cstring *b)
	int n = strlen(a)
	strcpy(&a[n], b)

int strcmp(cstring *a, cstring *b)
	for i in 0:256
		if a[i] > b[i]
			return 1
		else if a[i] < b[i]
			return -1
		if a[i] == 0
			break
	return 0

int __temp_i__, __temp_i2__, __temp_i3__, __temp_i4__
void* __temp_p__, __temp_p2__, __temp_p3__, __temp_p4__
int _p2i(void* p)
	int* i = &p
	return *i

class PointerWrapper
	void *p

void *_i2p(int i)
	PointerWrapper *p = &i
	return p.p


int call_ppii(void *f, void *a, void *b, int c, int d)
	__temp_p__ = f
	__temp_p2__ = a
	__temp_p3__ = b
	__temp_i__ = c
	__temp_i2__ = d
	asm{
		mov eax, __temp_p__
		push __temp_i2__
		push __temp_i__
		push __temp_p3__
		push __temp_p2__
		call eax
		mov __temp_i__, eax
		sub esp, 0x12
	}
	return __temp_i__


int call_pp(void *f, void *a, void *b)
	__temp_p__ = f
	__temp_p2__ = a
	__temp_p3__ = b
	asm{
		mov eax, __temp_p__
		push __temp_p3__
		push __temp_p2__
		call eax
		mov __temp_i__, eax
		sub esp, 0x12
	}
	return __temp_i__

int call_p(void *f, void *a)
	__temp_p__ = f
	__temp_p2__ = a
	asm{
		mov eax, __temp_p__
		push __temp_p2__
		call eax
		mov __temp_i__, eax
		sub esp, 0x04
	}
	return __temp_i__

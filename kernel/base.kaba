#define __OS__
#define __CODE_ORIGIN__ 0x10000
#define __VARIABLE_OFFSET__ 0x110010 // > ~1mb, wegen Stack!
#define __ADD_ENTRY_POINT__
#define __STRING_CONST_AS_CSTRING__


int MemorySize // in bytes


//--------------------------------------------------------------
// Low Level

int _temp_port_no_
int _temp_port_data_

void outportb(int port, char data)
	_temp_port_no_ = port
	_temp_port_data_ = data
	asm{
		mov eax, _temp_port_data_
		mov edx, _temp_port_no_
		out dx, al
	}

void outportd(int port,int data)
	_temp_port_no_ = port
	_temp_port_data_ = data
	asm{
		mov eax, _temp_port_data_
		mov edx, _temp_port_no_
		out dx, eax
	}

char inportb(int port)
	_temp_port_no_ = port
	asm{
		mov edx, _temp_port_no_
		xor eax, eax
		in al, dx
		mov _temp_port_data_, eax
	}
	return _temp_port_data_

int inportd(int port)
	_temp_port_no_ = port
	asm{
		mov edx, _temp_port_no_
		in eax, dx
		mov _temp_port_data_, eax
	}
	return _temp_port_data_



void read_data_from_init()
	asm{
		mov eax, [0x00005100]
		shl eax, 0x0a
		mov MemorySize, eax
	}


void memcpy(cstring *dest, cstring *source, int size)
	for int n, 0, size
		dest[n] = source[n]
	/*if size > 0
		temp_i=size
		temp_p=source
		temp_p2=dest
		asm{
			mov ecx, temp_i
			mov eax, temp_p
			mov ebx, temp_p2
			_mem_cpy_loop:
				mov.b dl, [eax]
				mov.b [ebx], dl
				inc eax
				inc ebx
				loop _mem_cpy_loop
		}*/

int strlen(cstring *s)
	for int i, 0, 256
		if s[i] == 0
			return i
	return 256

void strcpy(cstring *a, cstring *b)
	for int i, 0, 256
		a[i] = b[i]
		if b[i] == 0
			break

void strcat(cstring *a, cstring *b)
	int n = strlen(a)
	strcpy(&a[n], b)

int strcmp(cstring *a, cstring *b)
	for int i, 0, 256
		if a[i] > b[i]
			return 1
		else if a[i] < b[i]
			return -1
		if a[i] == 0
			break
	return 0

int __temp_i__, __temp_i2__, __temp_i3__, __temp_i4__
void *__temp_p__, *__temp_p2__, *__temp_p3__, *__temp_p4__
int _p2i(void *p)
	int *i = &p
	return *i

class PointerWrapper
	void *p

void *_i2p(int i)
	PointerWrapper *p = &i
	return p.p

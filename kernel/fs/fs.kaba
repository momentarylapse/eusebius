use "../base.kaba"
use "../mem/heap.kaba"
use "../dev/ata.kaba"
use "../io/text.kaba"
#define __STRING_CONST_AS_CSTRING__


//--------------------------------------------------------------
// Dateisystem

const int FILE_TYPE_FILE = 0
const int FILE_TYPE_DIR = 1
const int FILE_TYPE_PIPE = 2
const int FILE_TYPE_CHAR = 8
const int FILE_TYPE_BLOCK = 16


class FileOperations
	void *_open
	void *_close
	void *_read
	void *_write

class FileEntry
	cstring name
	int type
	int size
	int num_blocks
	int[0]* blocks
	int inode
	int mp_inode
	MountPoint *mount
	FileEntry *parent
	FileEntry *next
	FileEntry *first_sub
	FileOperations *op
	bool meta_dirty
	
	void add(FileEntry *e)
		e.parent = self
		if first_sub
			FileEntry *i = first_sub
			while i.next
				i = i.next
			i.next = e
		else
			first_sub = e
	
	FileEntry *get_sub(cstring sname)
		if strcmp(&sname, &"..") == 0
			return parent
		if strcmp(&sname, &".") == 0
			return self
		FileEntry *e = first_sub
		while e
			if strcmp(&sname, &e.name) == 0
				return e
			e = e.next
		return nil
	
	// allocate list int blocks of int[16]
	void add_block(int b)
		if (num_blocks & 0x0f) == 0
			blocks = realloc(blocks, num_blocks * 4, (num_blocks + 16) * 4)
		blocks[num_blocks] = b
		num_blocks ++



class MountPoint
	FileSystemType *type
	PartitionData *dev
	FileEntry *dest
	int block_offset
	int block_size
	
	int dev_blocks_per_block
	int dev_block_offset
	
	void *saveInode // int f(FileSystemType*, FileEntry*)
	
	void update(int _bs, int _bo)
		block_size = _bs
		dev_blocks_per_block = _bs / 512
		block_offset = _bo
		dev_block_offset = _bo / 512
	
	void readBlock(int block_no, cstring *buf)
		for i in 0:dev_blocks_per_block
			Ata.readSector(dev.disk_no, dev.offset + block_no * dev_blocks_per_block + dev_block_offset + i    , 1, &buf[512 * i])
	void writeBlock(int block_no, cstring *buf)
		for i in 0:dev_blocks_per_block
			Ata.writeSector(dev.disk_no, dev.offset + block_no * dev_blocks_per_block + dev_block_offset + i    , 1, &buf[512 * i])



class FileSystemData
	MountPoint[16] mounts
	int num_mounts
	FileEntry *root
	
	void init()
		num_mounts = 0
		root = add("-root-", FILE_TYPE_DIR, nil, nil)
	
	FileEntry *add(cstring name, int type, MountPoint *mount, FileEntry *parent)
		FileEntry *e = malloc(sizeof(FileEntry))
		e.num_blocks = 0
		e.blocks = nil
		strcpy(&e.name, &name)
		e.parent = parent
		e.type = type
		e.mount = mount
		e.next = nil
		e.first_sub = nil
		e.op = nil
		e.meta_dirty = false
		if parent
			parent.add(e)
		return e
	
	void del(FileEntry *e)
		if e.parent
			prints("--[del e.parent]---\n")
		else
			free(e)
	
	FileEntry *get(cstring path, FileEntry *cur_dir)
		int ppos = 0
		if path[0] == '/'
			ppos = 1
			cur_dir = root
			if path[1] == 0
				return root
		else if !cur_dir
			return nil
		FileEntry *e = cur_dir
		cstring sub
		bool has_more = true
		while has_more
			strcpy(&sub, &path[ppos])
			cstring name
			for i in 0:256
				if (sub[i] == '/') or (sub[i] == 0)
					has_more = (sub[i] == '/')
					ppos += i + 1
					name[i] = 0
					break
				name[i] = sub[i]
			e = e.get_sub(name)
			if !e
				return nil
		return e
	
	void get_name(cstring path, FileEntry *e)
		if e.parent
			get_name(path, e.parent)
			if e.parent.parent
				strcat(&path, &"/")
			strcat(&path, &e.name)
		else
			strcpy(&path, &"/")
		
	void mount(PartitionData *dev, FileEntry *dir, cstring fs_name)
		prints("mounte...")
		MountPoint *mp = &mounts[num_mounts]
		num_mounts ++
		mp.dest = dir
		mp.dev = dev
		if strcmp(&fs_name, &"michifs") == 0
			mp.type = &FSTMichiFS
			FSTMichiFS.mount(mp)
		else if strcmp(&fs_name, &"ext2") == 0
			mp.type = &FSTExt2
			FSTExt2.mount(mp)
		dir.mount = mp
		prints(" ok\n")

FileSystemData FileSystem

class Word
	char[2] c
	int int()
		int a = c[0]
		int b = c[1]
		return a + b * 256

class FileSystemType
	int dummy

class FileSystemTypeMichiFS : FileSystemType
	char[2048] buf
	int buf_used
	
	int read_int()
		int *p = &buf[buf_used]
		buf_used += 4
		return *p
	void read_str(cstring s)
		int l = buf[buf_used] + buf[buf_used+1]*256
		buf_used += 2
		for i in 0:l
			s[i] = buf[buf_used + i]
		buf_used += l
		s[l] = 0
	bool mount(MountPoint *mp)
		mp.saveInode = nil
		mp.update(2048, 0)
		mp.readBlock(1, &buf)
		buf_used = 0
		int NumFiles = read_int()
		for n in 0:NumFiles
			cstring name
			read_str(name)
			FileEntry *e = FileSystem.add(name, FILE_TYPE_FILE, mp, mp.dest)
			//e.type =
			read_int()
			e.size = read_int()
			read_int() // NumParts = 1
			int first_block = read_int()
			int num_blocks = read_int()
			for i in 0:num_blocks
				e.add_block(first_block + i)
	
	//void readBlock(int no, cstring *buf)
	//void readFileBlock(int inode, int block, cstring *buf)

class Ext2Inode
	Word rights
	Word user
	int size
	int atime, ctime, mtime, dtime
	Word group
	Word hard_links
	int blocks
	int flags
	int version
	int[15] iblock
	int file_version
	int acl
	int size_high
	int dummy
	int[3] xx_high
	bool isDir()
		return (rights.int() & 0xf000) == 0x4000
	bool isFile()
		return (rights.int() & 0xf000) == 0x8000

class Ext2SuperBlock
	int inodes_count
	int blocks_count
	int reserved_blocks_count
	int free_blocks_count
	int free_inodes_count
	int first_data_block
	int log_block_size
	int log_cluster_size
	int blocks_per_group
	int obso_frags_per_group
	int inodes_per_group
	int mtime, wtime
	Word mnt_count, max_mnt_count
	Word magic
	Word state
	Word errors
	Word minor_rev_level
	int lastcheck, checkinterval
	int creator_os
	int rev_level
	Word def_resuid, def_resgid
	int first_ino
	Word inode_size
	Word block_group_nr
	int feature_compat, feature_incompat, feature_ro_compat
	char[16] uuid
	char[16] volume_name
	char[64] last_mounted
	char[1024-200] _filler_

class Ext2BlockGroupDescriptor
	int block_bitmap
	int inode_bitmap
	int inode_table
	Word free_blocks_count, free_inodes_count
	Word used_dirs_count
	Word flags
	int exclude_bitmap
	Word block_bitmap_csum, inode_bitmap_csum
	Word itable_unused
	Word checksum

class Ext2DirEntryHeader
	int inode
	Word rec_len
	char name_len
	char file_type

class FileSystemTypeExt2 : FileSystemType
	int inodes_per_block
	Ext2SuperBlock sb
	Ext2BlockGroupDescriptor bg
	char[4096] _buf
	bool readable, writable
	int block_size
	int block_offset
	MountPoint *_mp
	
	bool dirty
	
	int[0]* inode_bitmap
	int[0]* block_bitmap
	
	bool mount(MountPoint *mp)
		mp.saveInode = &saveInode
		_mp = mp
		mp.update(1024, 0) // temp
		
		mp.readBlock(1, &sb)
		
		block_size = 1 << (sb.log_block_size + 10)
		inodes_per_block = block_size / sizeof(Ext2Inode) //128
		block_offset = 1024
		if block_size == 1024
			block_offset = 0
		
		inode_bitmap = malloc(block_size)
		block_bitmap = malloc(block_size)
	
		//f.seek(1024 + block_size, true)
		//f.xread(&bg, sizeof(BlockGroupDescriptor))
		mp.readBlock(1 + block_size / 1024, &bg)
		
		mp.update(block_size, block_offset)
		
		
		mp.readBlock(bg.block_bitmap, block_bitmap)
		mp.readBlock(bg.inode_bitmap, inode_bitmap)
		
		dirty = false
		
		
		//showMetaData()
		testCompatibility()
		if readable
			loadInodeRecursive(2, mp.dest)
	
	void saveMetaData()
		Ata.writeSector(_mp.dev.disk_no, _mp.dev.offset + 2    , 1, &sb)
		_mp.writeBlock(1 + block_size / 1024, &bg)
			
	
	void testCompatibility()
		readable = false
		writable = false
		if (sb.feature_incompat & 0xfffffffd) > 0
			return
		readable = true
		if (sb.feature_ro_compat & 0xfffffffe) > 0
			return
		writable = true
	
	int saveInode(FileEntry *e)
		//prints("save Inode")
		int index = e.mp_inode
		int group_no = (index - 1) / sb.inodes_per_group // 0...
		int offset = ((index - 1) % sb.inodes_per_group) * sizeof(Ext2Inode)
		_mp.readBlock(group_no * sb.blocks_per_group + bg.inode_table + offset/block_size, &_buf)
		memcpy(&inode, &_buf[offset % block_size], sizeof(Ext2Inode))
		inode.size = e.size
		memcpy(&_buf[offset % block_size], &inode, sizeof(Ext2Inode))
		_mp.writeBlock(group_no * sb.blocks_per_group + bg.inode_table + offset/block_size, &_buf)
		return 0
	
	void readInode(int index, Ext2Inode inode, FileEntry *e)
		int group_no = (index - 1) / sb.inodes_per_group // 0...
		int offset = ((index - 1) % sb.inodes_per_group) * sizeof(Ext2Inode)
		// group_no!!!!!!!!!!!!!!
		_mp.readBlock(group_no * sb.blocks_per_group + bg.inode_table + offset/block_size, &_buf)
		memcpy(&inode, &_buf[offset % block_size], sizeof(Ext2Inode))
		
		e.type = FILE_TYPE_FILE
		if inode.isDir()
			e.type = FILE_TYPE_DIR
		
		e.size = inode.size
		if e.num_blocks != 0
			panic("!=0")
		int num_blocks = (inode.size-1) / block_size + 1
		//e.blocks = malloc((e.num_blocks + 8) * sizeof(int))
		int num_direct = num_blocks
		if num_direct > 12
			num_direct = 12
	
		for i in 0:num_direct
			e.add_block(inode.iblock[i])
		if num_blocks > 12
			_mp.readBlock(inode.iblock[12], &_buf)
			int[0]* p = &_buf
			for i in 12:num_blocks
				e.add_block(p[i - 12])
		
	
	Ext2Inode inode
	
	cstring *readInodeContents(FileEntry *e)
		cstring *buf = malloc(e.num_blocks * block_size)
		for i in 0:e.num_blocks
			_mp.readBlock(e.blocks[i], &buf[i * block_size])
		
		return buf
	
	void loadInodeRecursive(int index, FileEntry *dir)
		readInode(index, inode, dir)
		if !inode.isDir()
			return
		cstring *cont = readInodeContents(dir)
		int p = 0
		while p < dir.size
			Ext2DirEntryHeader *d = &cont[p]
			if d.rec_len.int() == 0
				break
			cstring name
			int len = d.name_len
			memcpy(&name, &cont[p + 8], len)
			name[len] = 0
			p += d.rec_len.int()
			if d.name_len == 0 or d.inode == 0
				continue
				
		
			if strcmp(&name, &".") != 0 and strcmp(&name, &"..") != 0
				int type = FILE_TYPE_FILE
				if d.file_type == 2
					type = FILE_TYPE_DIR
				FileEntry *e = FileSystem.add(name, type, _mp, dir)
				e.mp_inode = d.inode
				loadInodeRecursive(d.inode, e)
		free(cont)
	
	int allocInode()
		int n = sb.inodes_per_group / 32
		for i in 0:n
			int b = inode_bitmap[i]
			if b == 0xffffffff
				continue
			for j in 0:32
				int m = 1 << j
				if (b & m) == 0
					inode_bitmap[i] += m
					sb.free_inodes_count --
					//bg.free_inodes_count
					dirty = true
					return i * 32 + j
		return -1
	
	int allocBlock()
		int n = sb.blocks_per_group / 32
		for i in 0:n
			int b = block_bitmap[i]
			if b == 0xffffffff
				continue
			for j in 0:32
				int m = 1 << j
				if (b & m) == 0
					block_bitmap[i] += m
					sb.free_blocks_count --
					//bg.free_blocks_count
					dirty = true
					return i * 32 + j
		return -1

FileSystemTypeMichiFS FSTMichiFS
FileSystemTypeExt2 FSTExt2

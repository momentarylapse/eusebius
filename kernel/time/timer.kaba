use common
use io.io
use io.text
use time.timevalue
use task.task
use task.manager
use irq.irq

let TIMER_IRQ = 0

class KernelTimer as @noauto
	#int[2] state
	var static tv: TimeValue
	var static dt_nanosec: int
	
	#void update_state()
#		asm{
#			db 0x0f
#			db 0x31
#			mov __temp_i__, eax
#			mov __temp_i2__, edx
#		}
#		state[0] = __temp_i2__
#		state[1] = __temp_i__
	
	func static update()
		#update_state()
		# TODO   :P
		#tv.sec = (state[0] << 8) + (state[1] >> 24)
		#tv.nanosec = 0
		#tv.nanosec = (state[1] << 6) & 0x3fffffff
	func static tick()
		tv.inc_nanosec(dt_nanosec)

#	func static init_interrupt(out t: Task, dt_ms: int)

	func static init(dt_ms: int)
		# read year from CMOS
		#outportb(0x70, 0x40 | 0x09)
		#int rr = inportb(0x71)
		# year=0x09 month=0x08 day=0x07 hours=0x04 min=0x02 sec=0x00

		tv.clear()
		dt_nanosec = dt_ms * 1000000
	
	#	irq.set_task(irq.hw2soft(0), &t) # IRQ 0
	
		IrqManager.disable()
		IrqManager.set_func(TIMER_IRQ + 32, raw_function_pointer(int_timer))
	
		# ticks/s: 1193180
		# 100Hz:   11932 = 0x2e9c
		let ticks_per_sec = 1193180
		var ticks_till_irq = (ticks_per_sec >> 10) * dt_ms
		if ticks_till_irq > 0xffff
			ticks_till_irq = 0xffff

		outportb(0x43, 0x34) # channel 0, rate generator
		outportb(0x40, ticks_till_irq)
		outportb(0x40, ticks_till_irq >> 8)
		
		IrqManager.unmask(TIMER_IRQ)
		#IrqManager.enable()

	func static @noframe int_timer()
		asm{
			cli
			# general purpose registers
			push rax
			push rbx
			push rcx
			push rdx
			push rbp
			push rdi
			push rsi
			push r8
			push r9
			push r10
			push r11
			push r12
			push r13
			push r14
			push r15
			# control registers 4*8b=32b
			mov eax, cr0
			push rax
			mov eax, cr2
			push rax
			mov eax, cr3
			push rax
			mov eax, cr4
			push rax
			#mov rax, cr8
			#push rax
			mov rax, rsp
			mov __temp_p__, rax
		}
		handle_irq(__temp_p__ as InterruptFrame&)
		asm{
			# control registers
			#add rsp, 0x20
			pop rax
			mov cr4, eax
			pop rax
			mov cr3, eax
			pop rax
			mov cr2, eax
			pop rax
			mov cr0, eax
			# general purpose registers
			pop r15
			pop r14
			pop r13
			pop r12
			pop r11
			pop r10
			pop r9
			pop r8
			pop rsi
			pop rdi
			pop rbp
			pop rdx
			pop rcx
			pop rbx
			pop rax
			sti
			db 0x48
			iret
		}
	#var static ii: int

	func static handle_irq(out frame: InterruptFrame&)
		IrqManager.mask(TIMER_IRQ)
		prints("<timer>")
		if TaskManager.x_first
			frame.cs = 0x23
			frame.ss = 0x1b
			#frame.cs = 0x08
			#frame.ss = 0x10
			frame.rip = TaskManager.x_rip
			frame.rsp = TaskManager.x_rsp
			frame.rflags = 0x202
			TaskManager.x_first = false
		# do stuff
		IrqManager.eoi(TIMER_IRQ)
		IrqManager.unmask(TIMER_IRQ)
	
	

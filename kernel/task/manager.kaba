use common
use io.text
use fs
use mem.heap
use mem.paging
use task
use gdt

let MAX_TASKS = 256

class TaskManager as @noauto
	var static gdt: GlobalDescriptorTable
	var static tss: TaskStateSegment
	var static stack0: void*
	var static ist1: void*
	
#	func static get_task(pid: int) -> Task*
#		if pid < 0 or pid >= MAX_TASKS
#			return nil
#		var t = &tasks[pid]
#		if t.status == TaskStatus.UNUSED
#			return nil
#		return t

	var static tasks: Task[MAX_TASKS]
#	var static idle_task: Task*
	var static next_pid_to_assign: int
	var static next_puid_to_assign: int
	
	var static __handler_p__: int
	var static ack_hw_irq: int

	func static get_next_unused_pid() -> int
		for i in next_pid_to_assign:MAX_TASKS
			if tasks[i].status == TaskStatus.UNUSED
				next_pid_to_assign = i + 1
				return i
		for i in 0:next_pid_to_assign
			if tasks[i].status == TaskStatus.UNUSED
				next_pid_to_assign = i + 1
				return i
		return -1

	func static add_task_user(name: cstring, F: int64, parent: Task*) -> Task*

		let pid = get_next_unused_pid()
		if pid < 0
			return nil
		var t = &tasks[pid]
		
		t.init(pid, name, F, parent)
		t.puid = next_puid_to_assign
		next_puid_to_assign ++

		t.page_root_dir := create_page_root_table_for_task()
		t.frame.cr3 = _p2i64(t.page_root_dir)

		t.status = TaskStatus.RUNNING

		return t
		
	func static create_page_root_table_for_task() -> PageRootTable&
		var table_flags = PageFlags.PRESENT | PageFlags.WRITABLE | PageFlags.GLOBAL | PageFlags.USER
		let flags = PageFlags.WRITABLE | PageFlags.PRESENT | PageFlags.GLOBAL | PageFlags.USER

		var rt = Paging.create_root_table()
		var pdpt = rt.get_or_create_sub(0, table_flags)
		var kernel_pdpt = _i642p(Paging.kernel_root_table.e[0] & 0xfffffffffffff000) as PageTable&
		# reuse 1g from kernel
		pdpt.e[0] = kernel_pdpt.e[0]
		
		
		# alloc + randomly map 8m for user task
		# FIXME: ...everything
		rt.map_by_alloc(TASK_MEMORY_OFFSET, TASK_INITIAL_MEMORY_SIZE, PageFlags.WRITABLE | PageFlags.USER)
		return rt
#
#	func static add_task_kernel(name: cstring, F: void*, stack_size: int, parent: Task*) -> Task*
#		let pid = get_next_pid()
#		if pid < 0
#			return nil
#		var t = &tasks[pid]
#
#		t.init(pid, name, parent)
#		t.kernel_mode = true
#	
#		t.stack_size = stack_size
#		t.stack = Heap.malloc(stack_size)
#		t.page_dir = Paging.kernel_root_table
#		t.mem_bottom = 0
#		t.mem_size = 0
#		t.tss.set(t.get_initial_stack_pos(), 1, 2, 0, Paging.kernel_root_table, F)
#	
#		gdt[t.desc].set_task(t)
#
#		return t
#
#	func static idle_func()
#		while true
#			#prints("<idle>")
#			asm {
#				hlt
#			}
#	func static get_pvl() -> int
#		asm {
#			db 0x9c # pushf
#			pop eax
#			mov __temp_i__, eax
#		}
#		let eflags = __temp_i__
#		return (eflags >> 12) & 3


	# running in task space
#	func static task_signal_handler()
#		asm {
#			mov TaskManager.__handler_p__, edx
#		}
#		#prints("[task-signal-handler] ")
#		#printh(&__handler_p__, 4)
#		#prints(" [call]\n")
#		asm {
#			mov eax, TaskManager.__handler_p__
#			call eax
#		}
#		#prints("[done...return]\n")
#		asm {
#			# return from handler
#			mov eax, 0x00002006
#			int 0x80
#		}
#		while true
#			nil

	func static setup_hardware_task()
		asm{
			mov rax, _start_as_task
			mov __temp_p__, rax
		}
		# not sure if this is neccessary
		#tss.rsp0 = Heap.malloc(2048)#__temp_p__
#		stack2 = Heap.malloc(1024)
#		printh(&stack2, 8)
#		tss.rsp2 = _i2p(_p2i(stack2) + 1000)
		ist1 = Heap.malloc(1024)
		tss.ist1 = _i2p(_p2i(ist1) + 1000)
		prints("ltr...")
		asm{
			mov ax, 0x0028
			ltr ax
			_start_as_task:
			
			
			mov eax, 0x00000008
			push rax
			mov eax, _start_as_task2
			push rax
			db 0x48
			ret_far
			_start_as_task2:
		}
		# markiert das aktuelle TSS als "busy"!
		

	func static init()
		prints("init tasks...")
		gdt.init()
		gdt.set_tss(tss)
		
		ack_hw_irq = -1
	
		# null descriptor
#		for g in gdt
#			g.a = 0x00000000
#			g.b = 0x00000000
		# kernel code
#		gdt[1].set_data(0, 0xffffffff, true, 0)
		# kernel data
#		gdt[2].set_data(0, 0xffffffff, false, 0)
		# user code
#		gdt[3].set_data(0, 0xffffffff, true, 0)#3)
		# user data
#		gdt[4].set_data(0, 0xffffffff, false, 0)#3)

		for t in tasks
			t.status = TaskStatus.UNUSED
#			for h in t.handles
#				h = nil
#			for sm in t.shmem
#				sm.s = nil

		next_pid_to_assign = 0
		next_puid_to_assign = 0
		#UserMemMask = 0

#		kernel_task = add_task_kernel("kernel", nil, KERNEL_STACK_SIZE, nil)
#		idle_task = add_task_kernel("idle", idle_func, IDLE_STACK_SIZE, kernel_task)
	
		gdt.load()
		setup_hardware_task()

		prints("  ok\n")
	
	func static jump_to_user(f: void*)
		let stack = Heap.malloc(1024)
		__temp_i64__ = _p2i(f)#raw_function_pointer(f_user))
		__temp_p__ = _i2p(_p2i(stack) + 1016)
		asm{
			#cli
			#sti
			push 0x0000001b #0x1b # ss + ring3
			mov rax, __temp_p__
			push rax # rsp
			push 0x00003200 # flags: iopl=3, iterrupts=1
			#push 0x00003000#0x202 # flags: iopl=3, iterrupts=1
			push 0x00000023 #0x23 # cs + ring3
			mov rax, __temp_i64__
			push rax # rip
		#	jmp $
			db 0x48
			iret
			
			_user:
		}

	func static @noframe f_user()
		var s: cstring
		strcpy(s, "USER: HI")
		while true
			#prints("\nhi, user!\n")
			__temp_p__ = &s
			__temp_i__ = strlen(s)
			asm{
				mov rdi, __temp_p__
				mov esi, __temp_i__
				mov eax, 0x00001234
				syscall
			}
			for i in 0:370000000
				pass

	func static add_dummy()
		add_task_user("dummy", _p2i(raw_function_pointer(f_user)), nil)

#int sys_getpid()
#	asm{
#		xor, eax, eax
#		str ax
#		mov __temp_i__, eax
#	}
#	int pid = (__temp_i__ >> 3) - NUM_PRE_GDT_ENTRIES

			
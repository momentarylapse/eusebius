#define __OS__
use "base.kaba"
use "text_mode.kaba"
use "filesystem.kaba"
use "base_mem.kaba"
use "paging.kaba"
#define __STRING_CONST_AS_CSTRING__


const int MAX_OPEN_FILES = 128
const int MAX_PIPES = 64
const int PIPE_BUFFER_SIZE = 1024

const int O_RDONLY = 1
const int O_WRONLY = 2
const int O_RDWR = 3
const int O_APPEND = 16
const int O_CREATE = 32
const int O_NONBLOCK = 64
const int O_TRUNC = 128


//--------------------------------------------------------------
// Dateizugriff

class PipeData
	bool used
	FileEntry *e
	int read_ref_count
	int write_ref_count
	char buffer[0]*
	int buffer_used
	int write(PageDirectory *page_dir, int addr, int size)
		if buffer_used + size > PIPE_BUFFER_SIZE
			return E_WOULD_BLOCK
		page_dir.memcpy2kernel(&buffer[buffer_used], addr, size)
		buffer_used += size
		return size
	int read(PageDirectory *page_dir, int addr, int size)
		if buffer_used == 0
			// no data... block if we have a writer
			if write_ref_count > 0
				return E_WOULD_BLOCK
			// else "empty"
			return 0
		if size > buffer_used
			size = buffer_used
		page_dir.memcpy2task(addr, buffer, size)
		buffer_used -= size
		for int i, 0, buffer_used
			buffer[i] = buffer[i + size]
		return size
	void unref(OpenFileData *of)
		if of.reading
			read_ref_count --
		else
			write_ref_count --
		/*if read_ref_count < 0
			panic("Pipe.read_ref_count < 0")
		if write_ref_count < 0
			panic("Pipe.write_ref_count < 0")*/
		if read_ref_count <= 0 and write_ref_count <= 0 and !e
			free(buffer)
			used = false

PipeData Pipe[MAX_PIPES]



PipeData *create_pipe(FileEntry *e)
	for int i, 0, MAX_PIPES
		if !Pipe[i].used
			Pipe[i].used = true
			Pipe[i].e = e
			Pipe[i].read_ref_count = 0
			Pipe[i].write_ref_count = 0
			Pipe[i].buffer_used = 0
			Pipe[i].buffer = malloc(PIPE_BUFFER_SIZE)
			return &Pipe[i]
	return nil

void delete_pipe(PipeData *p)
	free(p.buffer)
	p.used = false

PipeData *get_pipe(FileEntry *e)
	for int i, 0, MAX_PIPES
		if Pipe[i].e == e
			return &Pipe[i]
	return nil

class OpenFileData
	bool used
	bool reading
	bool writing
	bool blocking
	FileEntry *entry
	int offset
	int block_size
	char buffer[0]*
	PipeData *pipe
	int ref_count
	
	int get_flags()
		int flags = 0
		if reading
			flags += O_RDONLY
		if writing
			flags += O_WRONLY
		if !blocking
			flags += O_NONBLOCK
		return flags
	void set_flags(int flags)
		reading = (flags & O_RDONLY) > 0
		writing = (flags & O_WRONLY) > 0
		blocking = (flags & O_NONBLOCK) == 0

	int read(PageDirectory *page_dir, int addr, int size)
		int r=0
		
		if !reading
			return -3
		
		if entry.type == FILE_TYPE_CHAR
			return call_ppii(entry.op._read, entry, page_dir, addr, size)
		else if entry.type == FILE_TYPE_PIPE
			return pipe.read(page_dir, addr, size)
		
		int pos_in_block = offset % block_size
		int block_no = offset / block_size
		
		int size_max = entry.size - offset
		if size > size_max
			size = size_max
		
		while size > 0
	
			// wieviel kann aus dem Puffer gelesen werden?
			int cur_size = size
			if cur_size > block_size - pos_in_block
				cur_size = block_size - pos_in_block

			// direkt lesen (aus dem Lese-Puffer kopieren)
			page_dir.memcpy2task(addr, &buffer[pos_in_block], cur_size)
			pos_in_block += cur_size
			offset += cur_size
			r += cur_size
			size -= cur_size
			addr += cur_size
		
			if pos_in_block >= block_size
				// read next block
				pos_in_block = 0
				block_no ++
				int cl = entry.blocks[block_no]
				entry.mount.readBlock(cl, buffer)
		
		return r

	void truncate()
		entry.size = offset
		entry.meta_dirty = true

	int write(PageDirectory *page_dir, int addr, int size)
		int r=0

		if !used
			return -1
		
		if !writing
			return -2
		
		if entry.type == FILE_TYPE_CHAR
			return call_ppii(entry.op._write, entry, page_dir, addr, size)
		else if entry.type == FILE_TYPE_PIPE
			return pipe.write(page_dir, addr, size)
		
		int pos_in_block = offset % block_size
		int block_no = offset / block_size
		
		while size > 0
	
			// wieviel kann in den Puffer geschrieben werden?
			int cur_size = size
			if cur_size > block_size - pos_in_block
				cur_size = block_size - pos_in_block

			// direkt lesen (aus dem Lese-Puffer kopieren)
			page_dir.memcpy2kernel(&buffer[pos_in_block], addr, cur_size)
			pos_in_block += cur_size
			offset += cur_size
			r += cur_size
			size -= cur_size
			addr += cur_size
			entry.size += cur_size
			entry.meta_dirty = true
			
			// write cur block
			int cl = entry.blocks[block_no]
			entry.mount.writeBlock(cl, buffer)
		
			if pos_in_block >= block_size
				// next block
				pos_in_block = 0
				block_no ++
		
		return r
		
		entry.size += size
		return size
		return E_WOULD_BLOCK

	int getdents(PageDirectory *page_dir, int addr, int num)
		if !used
			return -1

		if entry.type != FILE_TYPE_DIR
			return -2
		
		if !reading
			return -3
	
		FileEntry *e = entry.first_sub
		for int i, 0, offset
			e = e.next
			if !e
				return 0
		if !e
			return 0
		dirent_struct r
		r.struct_size = strlen(&e.name) + 13
		r.size = e.size
		r.type = e.type
		strcpy(&r.name, &e.name)
		page_dir.memcpy2task(addr, &r, r.struct_size)
		offset ++
		return 1


	void unref()
		if !used
			return
		ref_count --
		if ref_count > 0
			return
		
		/*if ref_count < 0
			panic("OpenFileData.ref_count < 0")*/
			
		if entry.meta_dirty
			prints "-dirty- "
			if entry.mount.saveInode
				call_pp(entry.mount.saveInode, entry.mount.type, entry)
				entry.meta_dirty = false
			
		if buffer
			free(buffer)
		if entry.type == FILE_TYPE_CHAR
			call_p(entry.op._close, entry)
		if entry.type == FILE_TYPE_PIPE
			pipe.unref(self)
		
		used = false
		entry = nil


OpenFileData OpenFile[MAX_OPEN_FILES]

OpenFileData *create_handle(int flags)
	for int i, 0, MAX_OPEN_FILES
		if !OpenFile[i].used
			OpenFile[i].used = true
			OpenFile[i].set_flags(flags)
			OpenFile[i].buffer = nil
			OpenFile[i].ref_count = 0
			return &OpenFile[i]
	return nil



OpenFileData *kernel_open_entry(FileEntry *e, int flags)
	bool truncating = (flags & O_TRUNC) > 0
	OpenFileData *of = create_handle(flags)
	if !of
		return nil
	of.entry = e
	of.offset = 0
	of.block_size = of.entry.mount.block_size
	if of.entry.type == FILE_TYPE_FILE
		of.buffer = malloc(of.block_size)
		if of.entry.num_blocks > 0
			of.entry.mount.readBlock(of.entry.blocks[0], of.buffer)
		if of.writing
			if truncating
				of.truncate()
			else
				of.offset = e.size
	else if of.entry.type == FILE_TYPE_PIPE
		if of.reading == of.writing
			return nil
		of.pipe = get_pipe(of.entry)
		if !of.pipe
			of.used = false
			return nil
		if of.reading
			of.pipe.read_ref_count ++
		else
			of.pipe.write_ref_count ++
	else if of.entry.type == FILE_TYPE_CHAR
		call_p(of.entry.op._open, of.entry)
	return of

OpenFileData *kernel_open(cstring filename, int flags, FileEntry *cur_dir)
	bool creating = (flags & O_CREATE) > 0
	FileEntry *e = FileSystem.get(filename, cur_dir)
	if !e and creating
		e = FileSystem.add(filename, FILE_TYPE_FILE, cur_dir.mount, cur_dir)
		prints("kernel Warnung: neue Datei...\n")
	if !e
		return nil
	return kernel_open_entry(e, flags)

int kernel_mkdir(cstring filename, FileEntry *cur_dir)
	if FileSystem.get(filename, cur_dir)
		return -1
	if !FileSystem.add(filename, FILE_TYPE_DIR, cur_dir.mount, cur_dir)
		return -2
	return 0

int kernel_mknod(cstring filename, int flags, FileEntry *cur_dir)
	if FileSystem.get(filename, cur_dir)
		return -1
	FileEntry *e = FileSystem.add(filename, FILE_TYPE_PIPE, cur_dir.mount, cur_dir)
	if !e
		return -2
	if !create_pipe(e)
		return -3
	return 0


class dirent_struct
	int struct_size
	int size
	int type
	cstring name

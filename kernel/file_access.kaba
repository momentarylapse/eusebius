#define __OS__
use "base.kaba"
use "text_mode.kaba"
use "filesystem.kaba"
use "base_mem.kaba"
use "paging.kaba"
#define __STRING_CONST_AS_CSTRING__


const int MAX_OPEN_FILES = 128


//--------------------------------------------------------------
// Dateizugriff

class OpenFileData
	bool used
	FileEntry *entry
	int pos_in_cluster
	int cluster_no
	char buffer[0]*
	

	int read(PageDirectory *page_dir, int addr, int size)
		int r=0
		
		if entry.type == FILE_TYPE_CHAR
			__temp_p__ = entry.op._read
			__temp_p2__ = entry
			__temp_p3__ = page_dir
			__temp_i__ = addr
			__temp_i2__ = size
			asm{
				mov eax, __temp_p__
				push __temp_i2__
				push __temp_i__
				push __temp_p3__
				push __temp_p2__
				call eax
				mov __temp_i__, eax
				sub esp, 0x12
			}
			return __temp_i__
		
		if size > entry.size - cluster_no * 2048 - pos_in_cluster
			size = entry.size - cluster_no * 2048 - pos_in_cluster
		
		while size > 0
	
			// wieviel kann aus dem Puffer gelesen werden?
			int cur_size = size
			if cur_size > 2048 - pos_in_cluster
				cur_size = 2048 - pos_in_cluster

			// direkt lesen (aus dem Lese-Puffer kopieren)
			page_dir.memcpy2task(addr, &buffer[pos_in_cluster], cur_size)
			pos_in_cluster += cur_size
			r += cur_size
			size -= cur_size
			addr += cur_size
		
			if pos_in_cluster >= 2048
				// n√§chsten Cluster einlesen
				pos_in_cluster = 0
				cluster_no ++
				int cl = entry.offset + cluster_no
				int p_offset = entry.device.offset / 4
				FileSystem.Read(entry.device.disk_no, p_offset + cl, buffer)
		
		return r


	int write(PageDirectory *page_dir, int addr, int size)
		int r=0

		if !used
			return -1
		
		if entry.type == FILE_TYPE_CHAR
			__temp_p__ = entry.op._write
			__temp_p2__ = entry
			__temp_p3__ = page_dir
			__temp_i__ = addr
			__temp_i2__ = size
			asm{
				mov eax, __temp_p__
				push __temp_i2__
				push __temp_i__
				push __temp_p3__
				push __temp_p2__
				call eax
				mov __temp_i__, eax
				sub esp, 0x12
			}
			return __temp_i__
		return 0

	int getdents(PageDirectory *page_dir, int addr, int num)
		if !used
			return -1

		if entry.type != FILE_TYPE_DIR
			return -2
	
		FileEntry *e = entry.first_sub
		for int i, 0, pos_in_cluster
			e = e.next
			if !e
				return 0
		if !e
			return 0
		dirent_struct r
		r.struct_size = strlen(&e.name) + 13
		r.size = e.size
		r.type = e.type
		strcpy(&r.name, &e.name)
		page_dir.memcpy2task(addr, &r, r.struct_size)
		pos_in_cluster ++
		return 1


	void close()
		if !used
			return
		if entry.type == FILE_TYPE_FILE
			free(buffer)
		else if entry.type == FILE_TYPE_CHAR
			__temp_p__ = entry.op._close
			__temp_p2__ = entry
			asm{
				mov eax, __temp_p__
				push __temp_p2__
				call eax
				sub esp, 0x04
			}
		used = false
		entry = nil


OpenFileData OpenFile[MAX_OPEN_FILES]

OpenFileData *get_handle()
	for int i, 0, MAX_OPEN_FILES
		if !OpenFile[i].used
			OpenFile[i].used = true
			return &OpenFile[i]
	return nil



OpenFileData *kernel_open(cstring filename, FileEntry *cur_dir)
	OpenFileData *of = get_handle()
	if !of
		return nil
	of.entry = FileSystem.get(filename, cur_dir)
	if !of.entry
		of.used = false
		return nil
	of.cluster_no = 0
	of.pos_in_cluster = 0
	if of.entry.type == FILE_TYPE_FILE
		of.buffer = malloc(2048)
		int p_offset = of.entry.device.offset / 4
		FileSystem.Read(of.entry.device.disk_no, p_offset + of.entry.offset, of.buffer)
	else if of.entry.type == FILE_TYPE_CHAR
		__temp_p__ = of.entry.op._open
		__temp_p2__ = of.entry
		asm{
			mov eax, __temp_p__
			push __temp_p2__
			call eax
			sub esp, 0x04
		}
	return of


class dirent_struct
	int struct_size
	int size
	int type
	cstring name

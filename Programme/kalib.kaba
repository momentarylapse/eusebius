#define __OS__
#define __CODE_ORIGIN__ 0x00030000
#define __VARIABLE_OFFSET__ 0x00a3f000
#define __ADD_ENTRY_POINT__

const int MALLOC_OFFSET = 0x00b00000

int stdin, stdout, lib_error

int __temp_i__, __temp_i2__, __temp_i3__
void *__temp_p__, *__temp_p2__
int _p2i(void *p)
	int *i = &p
	return *i

//class PointerWrapper
//	void *p
	
void *_i2p(int i)
//	PointerWrapper *p = &i
//	return p.p
	__temp_i__ = i
	asm{
		mov eax, __temp_i__
		mov __temp_p__, eax
	}
	return __temp_p__


void s2cs(string s, cstring cs)
	for int i, 0, s.num
		cs[i] = s[i]
	cs[s.num] = 0

void cs2s(cstring cs, lib__string s)
	s.clear()
	for int i, 0, 255
		if cs[i] == 0
			return
		s.add(cs[i])

void sa2cs(string a[], cstring cs)
	int n = 0
	for int k, 0, a.num
		for int i, 0, a[k].num
			cs[n] = a[k][i]
			n ++
		cs[n] = 0
		n ++
	cs[n] = 0

int exit(int r)
/*	if stdin >= 0
		close(stdin)
	if stdout >= 0
		close(stdout)*/
	__temp_i__ = r
	asm{
		mov eax, 0x00000001
		mov ebx, __temp_i__
		int 0x80
	}

int open(string filename)
	cstring tt
	s2cs(filename, tt)
	__temp_p__ = &tt
	asm{
		mov eax, 0x00000005
		mov ebx, __temp_p__
		int 0x80
		mov __temp_i__, eax
	}
	return __temp_i__
	
void close(int h)
	__temp_i__ = h
	asm{
		mov eax, 0x00000006
		mov ebx, __temp_i__
		int 0x80
	}

int read(int h, void *buf, int size)
	__temp_i__ = h
	__temp_i2__ = size
	__temp_p__ = buf
	asm{
		mov eax, 0x00000003
		mov ebx, __temp_i__
		mov ecx, __temp_p__
		mov edx, __temp_i2__
		int 0x80
		mov __temp_i3__, eax
	}
	return __temp_i3__
	
int write(int h, void *buf, int size)
	__temp_i__ = h
	__temp_i2__ = size
	__temp_p__ = buf
	asm{
		mov eax, 0x00000004
		mov ebx, __temp_i__
		mov ecx, __temp_p__
		mov edx, __temp_i2__
		int 0x80
		mov __temp_i3__, eax
	}
	return __temp_i3__

int getdents(int h, void *buf)//lib__DirEntry)
	__temp_i__ = h
	__temp_i2__ = 1
	__temp_p__ = buf
	asm{
		mov eax, 0x0000008d
		mov ebx, __temp_i__
		mov ecx, __temp_p__
		mov edx, __temp_i2__
		int 0x80
		mov __temp_i3__, eax
	}
	return __temp_i3__

int getpid()
	asm{
		mov eax, 0x00000014
		int 0x80
		mov __temp_i__, eax
	}
	return __temp_i__
	
int waitpid(int pid, void *status, bool block)
	__temp_i__ = pid
	__temp_p__ = status
	__temp_i2__ = 0
	if !block
		__temp_i2__ = 1
	asm{
		mov eax, 0x00000007
		mov ebx, __temp_i__
		mov ecx, __temp_p__
		mov edx, __temp_i2__
		int 0x80
		mov __temp_i3__, eax
	}
	return __temp_i3__
	
int kill(int pid, int signal)
	__temp_i__ = pid
	__temp_i2__ = signal
	asm{
		mov eax, 0x00000025
		mov ebx, __temp_i__
		mov ecx, __temp_i2__
		int 0x80
		mov __temp_i3__, eax
	}
	return __temp_i3__
	
void showstats()
	asm{
		mov eax, 0x00002003
		int 0x80
	}

int chdir(string dir)
	cstring tt
	s2cs(dir, tt)
	__temp_p__ = &tt
	asm{
		mov eax, 0x0000000c
		mov ebx, __temp_p__
		int 0x80
		mov __temp_i__, eax
	}
	return __temp_i__

lib__string getcwd()
	cstring tt
	__temp_p__ = &tt
	asm{
		mov eax, 0x000000b7
		mov ebx, __temp_p__
		mov ecx, 0x00000100
		int 0x80
		mov __temp_i__, eax
	}
	lib__string r
	cs2s(tt, r)
	return r

int execute(string arg[])
	cstring tt_arg
	sa2cs(arg, tt_arg)
	__temp_p__ = &tt_arg
	asm{
		mov eax, 0x0000000b
		mov ebx, __temp_p__
		int 0x80
		mov __temp_i__, eax
	}
	return __temp_i__

void get_args(lib__string@list arg)
	cstring cs
	__temp_p__ = &cs
	asm{
		mov eax, 0x00002001
		mov ebx, __temp_p__
		int 0x80
	}
	lib__string s
	
	int p = 0
	lib__string s
	for int i, 0, 250
		if cs[i] == 0
			if s.num == 0
				break
			arg.add(s)
			s.clear()
			p = i + 1
		else
			s.add(cs[i])

int lib__clampi(int i, int min, int max)
	if i > max
		return max
	if i < min
		return min
	return i

int lib__loopi(int i, int min, int max)
	int d = max - min + 1
	if i < min
		int n = ( (min-i-1) / d ) + 1
		return i + d * n
	if i > max
		int n = ( (i-max-1) / d ) + 1
		return i - d * n
	return i

float lib__max(float a, float b)
	if a > b
		return a
	return b

void memcpy(char dest[0]*, char source[0]*, int size)
	for int i, 0, size
		dest[i] = source[i]
		
void prints(cstring s)
	__temp_p__ = &s
	asm{
		mov eax, 0x00002002
		mov ebx, __temp_p__
		int 0x80
	}

class MallocHeader
	int size
	void *next
MallocHeader *malloc_first_free


void *lib__@malloc(int size)
	MallocHeader *h = malloc_first_free
	int s = size + sizeof(MallocHeader)
	while h
		if s <= h.size
			h.size -= s
			char p[0]* = h
			MallocHeader *hh = &p[h.size + sizeof(MallocHeader)]
			hh.size = size
			return &p[h.size + sizeof(MallocHeader) * 2]
		h = h.next
	return nil

void lib__@free(void *p)

void *lib__@realloc(void *p, int size)
	MallocHeader hp[0]* = p
	MallocHeader *h = &hp[-1]
	int old_size = h.size
	void *pp = lib__@malloc(size)
	memcpy(pp, p, old_size)
	lib__@free(p)
	return pp

class lib__@DynamicArray
	cstring *data
	int num
	int allocated
	int element_size
	void __mem_init__(int _element_size)
		data = nil
		num = 0
		allocated = 0
		element_size = _element_size
	void __mem_clear__()
		if allocated > 0
			lib__@free(data)
		data = nil
		allocated = 0
		num = 0

	void reserve(int size)
		if allocated == 0
			if size > 0
				allocated = size * element_size
					data = lib__@malloc(allocated)
		else if size * element_size > allocated
			allocated = size * element_size * 2
			void *data0 = data
			data = lib__@realloc(data, allocated)
		else if size == 0
			__mem_clear__()

	void __mem_resize__(int size)
		if size > num
			reserve(size)
			//memset((char*)data + num * element_size, 0, (size - num) * element_size);
		num = size

	void __mem_remove__(int index)
		if index < 0 or index >= num
			return
		for int i, index*element_size, (num-1)*element_size
			data[i] = data[i+element_size]
		__mem_resize__(num - 1)
		
	void __assign__(lib__@DynamicArray a)
		__mem_resize__(a.num)
		memcpy(data, a.data, num * element_size)
		num = 0

class lib__string : lib__@DynamicArray
	overwrite char data[0]*
	void __init__()
		__mem_init__(1)
	void __delete__()
		__mem_clear__()
	void resize(int size)
		__mem_resize__(size)
	void clear()
		__mem_clear__()
	void add(char c)
		__mem_resize__(num + 1)
		data[num - 1] = c
	void __assign__(lib__string o)
		__mem_resize__(o.num)
		memcpy(data, o.data, num)
	void __iadd__(lib__string o)
		int n0 = num
		__mem_resize__(num + o.num)
		memcpy(&data[n0], o.data, o.num)
	lib__string __add__(lib__string o)
		lib__string r
		r = *self
		r += o
		return r
			
	lib__string substr(int start, int length)
		lib__string r
		if start >= num
			return r
		if start < 0
			// start from the end
			start = num + start
			if start < 0
				return r
		if length < 0
			length = num - start + length + 1
		if start + length > num
			length = num - start
		if length > 0
			r.resize(length)
			memcpy(r.data, &data[start], length)
		return r

	lib__string head(int size)
		return substr(0, size)

	lib__string tail(int size)
		return substr(num - size, size)

	int find(lib__string s, int start)
		for int i, start, num - s.num
			bool ok = true
			for int j, 0, s.num
				if data[i + j] != s.data[j]
					ok = false
					break
			if ok
				return i
		return -1
		
	int compare(lib__string s)
		int n = num
		if s.num < num
			n = s.num
		for int i, 0, n
			char a = data[i]
			char b = s.data[i]
			if a != b
				return a - b
		return num - s.num
		
	bool __eq__(lib__string s)
		return compare(s) == 0
	bool __neq__(lib__string s)
		return compare(s) != 0

/*int string::rfind(const string &s, int start) const
{
	char *b = (char*)data;
	char *aa = (char*)s.data;
	if (start < 0)
		start = num - 1;
	for (int i=start;i>=0;i--){
		bool ok = true;
		for (int j=0;j<s.num;j++)
			if (b[i + j] != aa[j]){
				ok = false;
				break;
			}
		if (ok)
			return i;
	}
	return -1;
}

int string::compare(const string &s) const
{
	char *a = (char*)data;
	int n = num;
	if (num > s.num)
		n = s.num;
	for (int i=0;i<n;i++){
		if (s[i] != a[i])
			return (int)(unsigned char)a[i] - (int)(unsigned char)s[i];
	}
	return num - s.num;
}

inline int ichar(char a)
{
	if ((a >= 'A') && (a <= 'Z'))
		return (int)(unsigned char)a - (int)(unsigned char)'A' + (int)(unsigned char)'a';
	return (int)(unsigned char)a;
}

int string::icompare(const string &s) const
{
	char *a = (char*)data;
	int n = num;
	if (num > s.num)
		n = s.num;
	for (int i=0;i<n;i++){
		if (ichar(s[i]) != ichar(a[i]))
			return ichar(a[i]) - ichar(s[i]);
	}
	return num - s.num;
}*/

	lib__string reverse()
		lib__string r
		r.resize(num)
		for int i, 0, num
			r.data[num - i - 1] = data[i]
		return r

	void replace0(int start, int length, lib__string str)
		if start + length > num
			return
		int d = str.num - length
		if d > 0
			resize(num + d)
			//for (int i=num-1;i>=start+length;i--)
			int j = num-1
			while j >= start+length
				data[j] = data[j - d]
				j --
		memcpy(&data[start], str.data, str.num)
		if d < 0
			for int i, start + str.num, num + d
				data[i] = data[i - d]
			resize(num + d)

	lib__string replace(lib__string sub, lib__string by)
		lib__string r = *self
		int i = r.find(sub, 0)
		while i >= 0
			r.replace0(i, sub.num, by)
			i = r.find(sub, i + by.num)
		return r

	lib__string lower()
		lib__string r = *self
		for int i, 0, num
			if (data[i] >= 'A') and (data[i] <= 'Z')
				r.data[i] += 'a' - 'A'
		return r

	lib__string upper()
		lib__string r = *self
		for int i, 0, num
			if (data[i] >= 'a') and (data[i] <= 'z')
				r.data[i] += 'A' - 'a'
		return r
		

	lib__string@list explode(lib__string s)
		lib__string@list r

		int pos = 0
		while true
			int pos2 = find(s, pos)
			if pos2 < 0
				break

			r.add(substr(pos, pos2 - pos))

			pos = s.num + pos2
		if (r.num > 0) or (pos < num)
			r.add(substr(pos, num - pos))
		return r
		
	lib__string hex(bool inverted)
		lib__string ttt
		for int i, 0, num
			int d = data[i]
			int d1 = (d>>4)
			int d2 = (d&15)
			if d1 < 10
				ttt.add(d1+48)
			else
				ttt.add(d1+87)
			if d2<10
				ttt.add(d2+48)
			else
				ttt.add(d2+87)
			if i == num-1
				ttt.add(' ')
			else
				ttt.add('.')
		return ttt
	
	int int()
		if num == 0
			return 0
		bool sign = (data[0] != '-')
		int r = 0
		int i0 = 0
		if !sign
			i0 = 1
		for int i, i0, num
			int c = data[i]
			r = r * 10 + c - 48
		if !sign
			return -r
		return r

class lib__int@list : lib__@DynamicArray
	overwrite int data[0]*
	void __init__()
		__mem_init__(sizeof(int))
	void resize(int size)
		if size > num
			reserve(size)
		num = size
	void add(int i)
		resize(num + 1)
		data[num - 1] = i
	void remove(int index)
		if (index < 0) or (index >= num)
			return
		for int i, index, num - 1
			data[i] = data[i+1]
		resize(num - 1)

class lib__string@list : lib__@DynamicArray
	overwrite lib__string data[0]*
	void __init__()
		__mem_init__(sizeof(lib__string))
	/*overwrite*/ void __delete__()
		for int i, 0, num
			data[i].__delete__()
		//clear()
	void resize(int size)
		if size < num
			// shrink -> destruct
			for int i, size, num
				data[i].__delete__()
		else if size > num
			reserve(size)
			for int i, num, size
				data[i].__init__()
		num = size
	void add(lib__string s)
		resize(num + 1)
		data[num - 1] = s
	void __assign__(lib__string@list o)
		resize(o.num)
		for int i, 0, num
			data[i] = o.data[i]
	void remove(int index)
		if (index < 0) or (index >= num)
			return
		for int i, index, num - 1
			data[i] = data[i+1]
		resize(num - 1)
		//data[index].__clear__()
		//__mem_remove__(index)

	lib__string join(lib__string glue)
		lib__string r
		for int i, 0, num
			if i > 0
				r += glue
			r += data[i]
		return r

lib__string lib__@i2s(int i)
	bool sign = i >= 0
	if !sign
		i = -i
	lib__string s
	while true
		s.add((i % 10) + 0x30)
		i /= 10
		if i == 0
			break
	if !sign
		s.add('-')
	return s.reverse()

lib__string lib__p2s(void *p)
	lib__string r
	r.resize(sizeof(p))
	void *pp = &p
	memcpy(r.data, pp, sizeof(p))
	return r.hex(true)

lib__string lib__@b2s(bool b)
	lib__string r
	if b
		r.add('1')
	else
		r.add('0')
	return r

lib__string lib__@ia2s(lib__int@list a)
	lib__string r
	r.add('[')
	for int i, 0, a.num
		if i > 0
			r.add(',')
		r += lib__@i2s(a.data[i])
	r.add(']')
	return r

void lib__print(lib__string s)
	/*cstring ss
	ss[1] = 0
	for int i, 0, s.num
		ss[0] = s.data[i]
		prints(ss)*/
	write(stdout, s.data, s.num)



class lib__DirEntry
	lib__string name
	int dddd, eee
	int size
	bool is_dir
	void __init__()
		name.__init__()
	void __assign__(lib__DirEntry o)
		name = o.name
		size = o.size
		is_dir = o.is_dir


class lib__DirEntry@list : lib__@DynamicArray
	overwrite lib__DirEntry data[0]*
	void __init__()
		__mem_init__(sizeof(lib__DirEntry))
	/*overwrite*/ void __delete__()
		for int i, 0, num
			data[i].__delete__()
		//clear()
	void resize(int size)
		if size < num
			// shrink -> destruct
			for int i, size, num
				data[i].__delete__()
		else if size > num
			reserve(size)
			for int i, num, size
				data[i].__init__()
		num = size
	void add(lib__DirEntry s)
		resize(num + 1)
		data[num - 1] = s
	void __assign__(lib__DirEntry@list o)
		resize(o.num)
		for int i, 0, num
			data[i] = o.data[i]
	void swap(int i, int j)
		lib__DirEntry e = data[i]
		data[i] = data[j]
		data[j] = e
		



class dirent_struct
	int struct_size
	int size
	int type
	cstring name
	void fill(lib__DirEntry e)
		cs2s(name, e.name)
		e.size = size
		e.is_dir = (type == 1)

lib__DirEntry@list lib__DirSearch(string dirname, string filter, bool allow_dirs)
	lib__DirEntry@list l
	int h = open(dirname)
	if h < 0
		lib_error = -1
		return l
	dirent_struct d
	int r = getdents(h, &d)
	lib__DirEntry e
	while r > 0
		lib__string s
		cs2s(d.name, s)
		d.fill(e)
		l.add(e)
		r = getdents(h, &d)
	close(h)
	lib_error = 0
	
	for int i, 0, l.num-1
		for int j, i+1, l.num
			if !l.data[i].is_dir and l.data[j].is_dir
				l.swap(i, j)
	for int i, 0, l.num-1
		for int j, i+1, l.num
			/*if l.data[i].is_dir != l.data[j].is_dir
				nil
			else */
			if (l.data[i].name.compare(l.data[j].name) < 0)
				l.swap(i, j)
	return l

void init_lib()
	malloc_first_free = _i2p(0x00b00000)
	malloc_first_free.size = 0x00200000 - sizeof(MallocHeader)
	malloc_first_free.next = nil
	
	stdout = open("/dev/tty")
	stdin = -1
	//stdin = open("/dev/keyboard")


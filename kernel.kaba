/*----------------------------------------------------------------------------*\
| Eusebius - Kernel                                                            |
| -> primitiv...                                                               |
|                                                                              |
| zuletzt geaendert: 2009.01.19 (c) by MichiSoft TM                            |
\*----------------------------------------------------------------------------*/


#os
#code_origin 0x9000
#variables_offset 0x200010 // > 2mb, wegen Stack!


#define MEM_ALLOC_OFFSET	0x300000 // (3-2)=1mb Kernel-Variablen
#define MAX_MEM_ALLOCS		4096
#define MAX_TASKS		256
#define MAX_FILES		128
#define MAX_OPEN_FILES		64
#define STACK_SIZE		4096	// pro Task
#define NUM_PRE_GDT_ENTRIES	5
#define TASK_SWITCH_DT		10		// in ms



char *ExecBuffer


int MemSize
int *GDT


// Daten Konversion (asm)
int temp_i,temp_i2
char *temp_p,*temp_p2
char temp_c


int NumMemAllocs
struct mem_alloc_t
	int Offset,End
mem_alloc_t MemAlloc[MAX_MEM_ALLOCS]

enum
	TASK_STATUS_DEAD
	TASK_STATUS_ALIVE


int NumTasks,CurPid
struct task_t
	int *tss,*stack
	int desc // Index in GDT
	int pid,status
	string name
task_t Task[MAX_TASKS],*CurTask,*TimerTask
int TaskCallData[2]


// erweiterer Textmodus
#define etm_nx		80
#define etm_ny		23

#define def_col_text	0x09
#define def_col_status	0x70
#define def_col_greet	0x71

char TextColor,TextColor2
int TextPos,TextLine


bool KBCData,KBCMouse,WaitingForMouseFA
int InputMouse[3]
char TempInputChar,KeyInputLast
int TempInput,MouseNo
bool MXOverflow,MYOverflow,MXNegative,MYNegative
char CharRead
int mx,my,mdx,mdy
bool lbut,mbut,rbut
#define NumKeys		96
bool Key[NumKeys]
char *KeyCode


// Ata-Geraete
int nAta,AtaStatus

struct ata_disk_info_t
	bool Available
	bool isAtapi
	int Size
	string Name
ata_disk_info_t DiskInfo[4]

int AtaIOBase,AtaIOCtrl,ide_no,ide_ms
char AtaMSMask

char AtaBuffer[512]
int *AtaBufferDW
int AtaSize

char atapi_buffer[16]

struct partition_t
	int offset,size
	char type
partition_t Partition[4]
int CurrentPartition


// Datei-Zugriffe
struct file_t
	int size
	bool is_dir
	string name
	int offset,num_clusters
int NumFiles
file_t File[MAX_FILES]

char FSBuffer[2048],*pFSBuffer
int FSBufferUsed,FSIntRead

int NumOpenFiles
struct open_file_t
	file_t *file
	int cluster_no,pos_in_cluster
	char *buffer
open_file_t OpenFile[MAX_OPEN_FILES]


// ...Test!
char TGAHeader[18]
int TGAWidth,TGAHeight,TGADepth
char *TGATemp
int *TGAImage
char TGAColor[4]

int font[256][7][13]



//--------------------------------------------------------------
// Hilfs-Funktionen

/*int c2i(char c)
	temp_c=c
	asm{
		xor eax, eax
		mov.b al, temp_c
		mov temp_i, eax
	}
	return temp_i

char i2c(int i)
	temp_i=i
	asm{
		mov eax, temp_i
		mov.b temp_c, al
	}
	return temp_c*/

int p2i(char *p)
	temp_p=p	
	asm{
		mov eax, temp_p
		mov temp_i, eax
	}
	return temp_i

object i2p(int i)
	temp_i=i
	asm{
		mov eax, temp_i
		mov temp_p, eax
	}
	return temp_p

void outportb(int port,char data)
	temp_c=data
	temp_i=port
	asm{
		mov.b al, temp_c
		mov edx, temp_i
		out dx, al
	}

void outportd(int port,int data)
	temp_i2=data
	temp_i=port
	asm{
		mov eax, temp_i2
		mov edx, temp_i
		out dx, eax
	}

char inportb(int port)
	temp_i=port
	asm{
		mov edx, temp_i
		in al, dx
		mov.b temp_c, al
	}
	return temp_c

int inportd(int port)
	temp_i=port
	asm{
		mov edx, temp_i
		in eax, dx
		mov temp_i, eax
	}
	return temp_i




void memcpy(char *dest,char *source,int size)
	/*int n
	for n, 0, size
		dest[n]=source[n]*/
	if size > 0
		temp_i=size
		temp_p=source
		temp_p2=dest
		asm{
			mov ecx, temp_i
			mov eax, temp_p
			mov ebx, temp_p2
			_mem_cpy_loop:
				mov.b dl, [eax]
				mov.b [ebx], dl
				inc eax
				inc ebx
				loop _mem_cpy_loop
		}

//--------------------------------------------------------------
// Text Modus

void DrawString(int x,int y,string str)
	temp_p=str
	temp_i=2*(x+80*y)
	asm{
		mov edx, 0x00
		_write_loop:
			mov eax, edx
			shl eax, 0x01
			add eax, 0xb8000
			add eax, temp_i
			add edx, temp_p
			mov.b bl, [edx]
			sub edx, temp_p
			mov.b [eax], bl
			add eax, 0x00000001
			mov.b cl, TextColor2
			mov.b [eax], cl
			add edx, 0x00000001
			cmp.b bl, 0x00
			jnz.b _write_loop
	}

int DrawHex(int x,int y,char *data,int size)
	char ttt[128]
	int i
	for i, 0, size
		int d=c2i(data[i])
		int d1=(d>>4)
		int d2=(d&15)
		if d1<10
			ttt[i*3]=i2c(d1+48)
		else
			ttt[i*3]=i2c(d1+97)
		if d2<10
			ttt[i*3+1]=i2c(d2+48)
		else
			ttt[i*3+1]=i2c(d2+97)
		ttt[i*3+2]=0x20 // ' '
	ttt[size*3-1]=0
	DrawString(x,y,ttt)

//--------------------------------------------------------------
// verwalteter Textmodus

void clrscr()
	asm{
		//mov eax, 0xb8000
		mov eax, 0xb80a0
		_clear_loop2:
			mov.b [eax], ' '
			add eax, 0x01
			mov.b [eax], 0x00
			add eax, 0x01
			cmp eax, 0xb8f00
			js.b _clear_loop2
	}
	TextLine=0
	TextPos=0

void clrstatus()
	asm{
		//mov eax, 0xb8000
		mov eax, 0xb8f00
		_clear_loop3:
			mov.b [eax], ' '
			add eax,0x01
			mov.b cl, TextColor2
			mov.b [eax], cl
			add eax, 0x01
			cmp eax, 0xb8fa0
			js.b _clear_loop3
	}

void etm_init()
	TextColor=def_col_text
	clrscr()
	TextColor2=def_col_greet
	DrawString(0, 0,"                 Eusebius 0.1.3   (c) by MichiSoft TM   2010                    ")
	TextColor2=def_col_status
	clrstatus()

void etm_shift()
	int *p1=i2p(0xb8140)
	int *p2=i2p(0xb80a0)
	memcpy(p2,p1,etm_nx*(etm_ny-1)*2)
	char a=TextColor2
	TextColor2=TextColor
	DrawString(0,etm_ny,"                                                                                ")
	TextColor2=a

void print(char *str)
	int i=0
	while str[i]!=0
		if str[i]!=0x0a
			char *p=i2p( (TextPos+etm_nx*(TextLine+1))*2 + 0xb8000 )
			*p=str[i]
			p[1]=TextColor
			TextPos++
		if (TextPos>=etm_nx) or (str[i]==0x0a)
			TextPos=0
			TextLine++
			if TextLine>=etm_ny
				etm_shift()
				TextLine=etm_ny-1
		i++

	// Cursor
	int position=((TextLine+1)*etm_nx) + TextPos-1
	// cursor LOW port to vga INDEX register
	outportb(0x3d4, 0x0f)
	outportb(0x3d5, i2c(position&0xff))
	// cursor HIGH port to vga INDEX register
	outportb(0x3d4, 0x0e)
	outportb(0x3d5, i2c((position>>8)&0xff))

void printi(int i)
	char ttt[16]
	ttt[15]=0
	int s=14
	while true
		ttt[s]=i2c(i%10)+0x30
		i/=10
		s--
		if i == 0
			break
	print(&ttt[s+1])

int printh(char *data,int size)
	char ttt[128]
	int i
	for i, 0, size
		int d=c2i(data[i])
		int d1=(d>>4)
		int d2=(d&15)
		if d1<10
			ttt[i*3]=i2c(d1+48)
		else
			ttt[i*3]=i2c(d1+87)
		if d2<10
			ttt[i*3+1]=i2c(d2+48)
		else
			ttt[i*3+1]=i2c(d2+87)
		ttt[i*3+2]=0x20 // ' '
	ttt[size*3-1]=0
	print(&ttt[0])

void print_ok()
	char tc=TextColor
	TextColor=0x02
	//TextPos=60
	TextPos+=2
	print("ok\n")
	TextColor=tc

void WasteTime()
	int x
	for x, 0, 100000
		nil


//--------------------------------------------------------------
// Speicher-"Verwaltung"

// Speicherbloecke bleiben immer so sortiert, dass der Offset monoton mit dem Index steigt!
object malloc(int size)
	// Anfang
	int offset=MEM_ALLOC_OFFSET
	int a=0
	// suchen
	while a<NumMemAllocs
		if offset+size<MemAlloc[a].Offset
			break
		offset=MemAlloc[a].End
		a ++
	// hintere Allocs verschieben
	int a2=NumMemAllocs-1
	while a2>=a
		MemAlloc[a2+1]=MemAlloc[a2]
		a2--
	// neuen Alloc einfuegen
	MemAlloc[a].Offset=offset
	MemAlloc[a].End=offset+size
	NumMemAllocs++
	return i2p(offset)

void free(void *mem)
	int mem_i=p2i(mem)
	int a=0
	int ae=-1
	while (ae<0) or (a<NumMemAllocs)
		if MemAlloc[a].Offset==mem_i
			ae=a
		a++
	if ae>=0
		a=ae
		NumMemAllocs--
		while a<NumMemAllocs
			MemAlloc[a]=MemAlloc[a+1]
			a++

/*void memcpy(char *dest,char *source,int size)
{
	//int n=0;
	//while(n<size){
	//	dest[n]=source[n];
	//	n++;
	//}
	if (size>0){
		temp_i=size;
		temp_p=source;
		temp_p2=dest;
		asm{
			mov ecx, temp_i
			mov eax, temp_p
			mov ebx, temp_p2
			_mem_cpy_loop:
				mov.b dl, [eax]
				mov.b [ebx], dl
				inc eax
				inc ebx
				loop _mem_cpy_loop
		}
	}
}*/

bool str_equ(char *a,char *b)
	int n=0
	bool equ=false
	while true
		equ=(a[n]==b[n])
		if (a[n]==0) or (b[n]==0) or !equ
			break
		n++
	return equ

//--------------------------------------------------------------
// Eingabe-Geraete

void InitInput()
	print("init input")
	
	// Puffer leeren
	while true
		// Daten da?
		if ((inportb(0x64) & 0x01)==0x01)
			// lesen
			inportb(0x60)
		else
			break

	// Maus aktivieren
	//   AUX aktivieren
	outportb(064,0xa8)
	//   Maus zum Sprechen bringen
	outportb(064,0xd4) // an Maus senden (AUX)
	outportb(060,0xf4) // EnableReporting

	WaitingForMouseFA=true
	MouseNo=0
	/*if VideoModeEnabled
		mx=ResX/2
		my=ResY/2*/
	mdx=0
	mdy=0
	lbut=false
	mbut=false
	rbut=false
	int k
	for k, 0, NumKeys
		Key[k]=false

	print_ok()

void UpdateInput()
	KBCMouse=false
	mdx=0
	mdy=0

	char data = inportb(0x64)
	// generell Daten?
	KBCData = ((data & 0x01) == 0x01)
	if KBCData
		// Tastatur/Maus
		KBCMouse=((data&0x20)==0x20)
		// lesen
		TempInputChar=inportb(0x60)
		//TempInput=c2i(TempInputChar)
		TempInput=TempInputChar

	if KBCMouse
		KBCData=false
		KBCMouse=false
		if WaitingForMouseFA and (TempInput==0xfa)
			WaitingForMouseFA=false
		else
			InputMouse[MouseNo]=TempInput
			TempInput=InputMouse[0]
			MouseNo++
			if MouseNo>=3
				MYOverflow=((TempInput&0x80)>0)
				MXOverflow=((TempInput&0x40)>0)
				MYNegative=((TempInput&0x20)>0)
				MXNegative=((TempInput&0x10)>0)
				mbut=((TempInput&0x04)>0)
				rbut=((TempInput&0x02)>0)
				lbut=((TempInput&0x01)>0)
				/*asm{
					mov.b al, TempInput
					cmp.b al, 0x80
					setnb.b MYOverflow
					shl.b al, 0x01
					cmp.b al, 0x80
					setnb.b MXOverflow
					shl.b al, 0x01
					cmp.b al, 0x80
					setnb.b MYNegative
					shl.b al, 0x01
					cmp.b al, 0x80
					setnb.b MXNegative
					shl.b al, 0x02
					cmp.b al, 0x80
					setnb.b mbut
					shl.b al, 0x01
					cmp.b al, 0x80
					setnb.b rbut
					shl.b al, 0x01
					cmp.b al, 0x80
					setnb.b lbut
				}*/
				KBCData=true
				KBCMouse=true
				MouseNo=0
				if MXNegative
					InputMouse[1]-=256
				if MYNegative
					InputMouse[2]-=256
				if MXOverflow
					InputMouse[1]=0
				if MYOverflow
					InputMouse[2]=0
				mdx+=InputMouse[1]
				mdy+=InputMouse[2]
	else
		//KeyInputE0
		int k
		for k, 0, NumKeys
			if (TempInputChar==KeyCode[k*4+2]) and (KeyInputLast==KeyCode[k*4+3])
				Key[k]=true
			if (TempInputChar==KeyCode[k*4  ]) and (KeyInputLast==KeyCode[k*4+1])
				Key[k]=false
		

	if TempInputChar==0xe0
		KeyInputLast=0xe0
	else
		KeyInputLast=0x00

	// noch mehr Daten?

	mx+=mdx
	my-=mdy
	/*if VideoModeEnabled
		if mx<0
			mx=0
		if mx>ResX
			mx=ResX
		if my<0
			my=0
		if my>ResY
			my=ResY*/

//	MouseNo=0

void WaitReturn()
	clrstatus()
	DrawString(40,24,"Weiter mit Return")
	while true
		UpdateInput()
		if Key[KEY_RETURN]
			break
	while true
		UpdateInput()
		if !Key[KEY_RETURN]
			break
	clrstatus()

//--------------------------------------------------------------
// ATA-Geraete

//#define AllowAta

//#ifdef AllowAta

//#define AtaIOCtrl		0x3f6

void wait_400_ns()
	int i
	for i, 0, 100
		inportb(AtaIOBase+7)

#define AtaMaskBusy		0x80
#define AtaMaskReady		0x40
#define AtaMaskData		0x08

bool ata_wait_status(char mask,char value)
	char AtaStatusChar=inportb(AtaIOBase+7)
	int n=1000000000
	while ((AtaStatusChar & mask)!=value) and (n>=0)
		AtaStatusChar=inportb(AtaIOCtrl)//+7)
		n--
	return n>=0

void SetDiskAdd(int disk_no)
	ide_no=(disk_no/2)
	ide_ms=(disk_no%2)
	// Adressierungs-Daten
	AtaIOBase=0x1f0
	if ide_no==1
		AtaIOBase=0x170
	AtaIOCtrl=AtaIOBase+0x206
	//AtaIOCtrl=0x3f6
	AtaMSMask=0x00
	if ide_ms==1
		AtaMSMask=0x10

bool AtaTestDisk(int disk_no)
	SetDiskAdd(disk_no)
	DiskInfo[disk_no].Available=false

	// generell ansprechbar?
	print("IDE ")
	printi(ide_no)
	print(":")
	printi(ide_ms)
	TextPos=20
	outportb( 0x1f6, AtaMSMask )
	wait_400_ns()
	outportb( AtaIOBase+2, 0x55 )
	outportb( AtaIOBase+3, 0xaa )
	outportb( AtaIOBase+2, 0xaa )
	outportb( AtaIOBase+3, 0x55 )
	outportb( AtaIOBase+2, 0x55 )
	outportb( AtaIOBase+3, 0xaa )
	char sc = inportb( AtaIOBase+2 )
	char sn = inportb( AtaIOBase+3 )
	if ( sc != 0x55 ) or ( sn != 0xaa )
		print("---\n")
		return false

	// now we think we know which devices, if any are there,
	// so lets try a soft reset (ignoring any errors).

	outportb( AtaIOBase+6, AtaMSMask )
	wait_400_ns()
	outportb( AtaIOCtrl, 0x0e ) // soft reset
	wait_400_ns()
	outportb( AtaIOCtrl, 0x0a )
	wait_400_ns()

	//sub_atapi_delay( 0 )
	ata_wait_status(AtaMaskBusy,0)
	outportb( AtaIOBase+6, AtaMSMask )
	wait_400_ns()

	// lets check device 0 again, is device 0 really there?
	// is it ATA or ATAPI?
	sc = inportb( AtaIOBase+2 )
	sn = inportb( AtaIOBase+3 )
	bool fail=true
	if ( sc == 0x01 ) and ( sn == 0x01 )
		DiskInfo[disk_no].isAtapi=false
		fail=false
		char cl = inportb( AtaIOBase+4 )
		char ch = inportb( AtaIOBase+5 )
		char st = inportb( AtaIOBase+7 )
		if ( cl == 0x14 ) and ( ch == 0xeb )
			print("ATAPI (CD-Rom)")
			DiskInfo[disk_no].isAtapi=true
		else
			if ( cl == 0x00 ) and ( ch == 0x00 ) and ( st != 0x00 )
				print("ATA")
			else
				fail=true
	if fail
		print("---\n")
		return false

	/*outportb( 0x1f6, 0xe0 ) // Master+LBA
	wait_400_ns()
	outportb( 0x3f6, 0x0e ) // ?+SoftReset+NoInt
	wait_400_ns()
	outportb( 0x3f6, 0x0a ) // ?+NoInt
	wait_400_ns()
	ata_wait_busy()*/


	DiskInfo[disk_no].Available=true

	outportb( AtaIOCtrl, 0x0a ) // ?+NoInt
	wait_400_ns()
	ata_wait_status(AtaMaskBusy,0)
	outportb( AtaIOBase+1, 0 ) //?
	outportb( AtaIOBase+2, 0 ) // NumSectors
 	outportb( AtaIOBase+3, 0 ) // S0
 	outportb( AtaIOBase+4, 0 ) // C0
	outportb( AtaIOBase+5, 0 )
	char ata_lba3=AtaMSMask | 0x60 // ...+LBA
	outportb( AtaIOBase+6, ata_lba3 ) // H0
	if DiskInfo[disk_no].isAtapi
		outportb( AtaIOBase+7, 0xa1 ) // IdentifyDrive (ATAPI)
	else
		outportb( AtaIOBase+7, 0xec ) // IdentifyDrive
	wait_400_ns()

	ata_wait_status(0x88,AtaMaskData)
	wait_400_ns()

	AtaBufferDW=&AtaBuffer
	int n
	for n, 0, 128
		AtaBufferDW[n]=inportd(AtaIOBase)
	// die Bytes des Namens korregieren
	//for n, 0, 40, 2
	n=0
	while n<40
		DiskInfo[disk_no].Name[n  ]=AtaBuffer[55+n]
		DiskInfo[disk_no].Name[n+1]=AtaBuffer[54+n]
		n+=2
	DiskInfo[disk_no].Name[40]=0
	print(DiskInfo[disk_no].Name)
	memcpy(&DiskInfo[disk_no].Size,&AtaBuffer[120],4)
	temp_i=DiskInfo[disk_no].Size >> 11
	/*asm{
		mov eax, temp_i
		shr eax, 0xb
		mov temp_i, eax
	}*/
	TextPos=60
	printi(temp_i)
//	TextPos=60
//	printi(DiskInfo[disk_no].Size)
	print("mb\n")

	return true

bool AtaReset(int disk_no)
	if !DiskInfo[disk_no].Available
		return false
	clrstatus()
	DrawString(0,24,"AtaReset")
	SetDiskAdd(disk_no)
	
	
	char status
	status=inportb(AtaIOBase+7)
	DrawHex(20,24,&status,1)
	status=inportb(AtaIOBase+1)
	DrawHex(23,24,&status,1)
	status=inportb(AtaIOCtrl)
	DrawHex(26,24,&status,1)
	
	//WaitReturn()
	status=inportb(AtaIOBase+7)
	DrawHex(20,24,&status,1)
	status=inportb(AtaIOBase+1)
	DrawHex(23,24,&status,1)
	status=inportb(AtaIOCtrl)
	DrawHex(26,24,&status,1)
	
	//WaitReturn()

void InitAta()
	print("\ninit ATA Geraete\n")
	// set up Device Control register
	outportb( 0x3f6, 0x0a )
	outportb( 0x376, 0x0a )

	AtaTestDisk(0)
	AtaTestDisk(1)
	AtaTestDisk(2)
	AtaTestDisk(3)

bool AtaRead(int disk_no,int sector_offset,int num_sectors,char *buf)
	if !DiskInfo[disk_no].Available
		return false
	clrstatus()
	DrawString(0,24,"MAtaRead")
	SetDiskAdd(disk_no)
	DrawHex(22,24,&AtaIOBase,2)
	// num_sectors=1...
	outportb( AtaIOBase+0x206, 0x0a )
	
	char status


	if DiskInfo[disk_no].isAtapi
		/*status=inportb(AtaIOBase+7)
		DrawHex(20,24,&status,1)
		status=inportb(AtaIOBase+1)
		DrawHex(23,24,&status,1)
		status=inportb(AtaIOCtrl)
		DrawHex(26,24,&status,1)
		WaitReturn()*/
			
		ata_wait_status(0x88,0)
		outportb( AtaIOBase+7, 0x08 ) // Soft Reset
		wait_400_ns()

		// CommandPacket
		atapi_buffer[0]=0xa8 // Read
		atapi_buffer[1]=0x00
		atapi_buffer[2]=i2c(sector_offset>>24) // LBA 24..31
		atapi_buffer[3]=i2c(sector_offset>>16) // 16..23
		atapi_buffer[4]=i2c(sector_offset>>8) // 8..15
		atapi_buffer[5]=i2c(sector_offset) // 0..7
		atapi_buffer[6]=0x00
		atapi_buffer[7]=0x00
		atapi_buffer[8]=0x00
		atapi_buffer[9]=i2c(num_sectors) // NumSectors
		atapi_buffer[10]=0x00
		atapi_buffer[11]=0x00
		
		//ata_wait_status(AtaMaskBusy | AtaMaskData,0)
		ata_wait_status(0x88,0)

		// dem ATA-Controller sagen, wir wollen ein ATAPI-Paket senden
		outportb( AtaIOBase+1, 0 ) // Features
		outportb( AtaIOBase+2, 0 )
		outportb( AtaIOBase+3, 0 )
		outportb( AtaIOBase+4, 0 )
		outportb( AtaIOBase+5, 0 )
		outportb( AtaIOBase+6, AtaMSMask | 0x40 ) // H0 ...+LBA
		outportb( AtaIOBase+7, 0xa0 ) // Packet
		wait_400_ns()

		//ata_wait_status(AtaMaskBusy,0)

		//ata_wait_status(0x88,AtaMaskData)
		ata_wait_status(AtaMaskData,AtaMaskData)

		/*status=inportb(AtaIOBase+7)
		DrawHex(50,15,&status,1)
		status=inportb(AtaIOBase+1)
		DrawHex(50,16,&status,1)
		status=inportb(AtaIOCtrl)
		DrawHex(50,17,&status,1)*/
		
		
		int *abdw=&atapi_buffer
		outportd(AtaIOBase,abdw[0])
		outportd(AtaIOBase,abdw[1])
		outportd(AtaIOBase,abdw[2])
	else
		outportb( AtaIOCtrl, 0x0a ) // ?+NoInt
		wait_400_ns()
		ata_wait_status(AtaMaskBusy,0)

		outportb( AtaIOBase+1, 0 ) // Features
		outportb( AtaIOBase+2, i2c(num_sectors) ) // NumSectors
 		outportb( AtaIOBase+3, i2c(sector_offset) ) // S0
 		outportb( AtaIOBase+4, i2c(sector_offset>>8) ) // C0
		outportb( AtaIOBase+5, i2c(sector_offset>>16) )
		outportb( AtaIOBase+6, i2c(sector_offset>>24) | AtaMSMask | 0x40 ) // H0 ...+LBA
		outportb( AtaIOBase+7, 0x20 ) // ReadSector
	wait_400_ns()

	ata_wait_status(0x88,AtaMaskData)
	//ata_wait_status(AtaMaskData | AtaMaskBusy,AtaMaskData)
	wait_400_ns()


	AtaBufferDW=buf
	
	if DiskInfo[disk_no].isAtapi
		DrawString(0,24,"Lese...")
		status=inportb(AtaIOBase+7)
		DrawHex(20,24,&status,1)
		status=inportb(AtaIOBase+1)
		DrawHex(23,24,&status,1)
		status=inportb(AtaIOCtrl)
		DrawHex(26,24,&status,1)
		
		int read=0
		while read<512 // 2048b
		
			int byte_cnt=c2i(inportb(AtaIOBase+5))*256+c2i(inportb(AtaIOBase+4))
			DrawHex(40,24,&byte_cnt,2)
			//WaitReturn()
			byte_cnt=20
		
			int dw_cnt=byte_cnt/4
			int n
			for n, 0, dw_cnt
				AtaBufferDW[n]=inportd(AtaIOBase)
			DrawHex(50,24,buf,20)
			read+=dw_cnt
	else
		for n, 0, 128 // 512b
			AtaBufferDW[n]=inportd(AtaIOBase)

	status=inportb(AtaIOBase+7)
	DrawHex(10,24,&status,1)
	status=inportb(AtaIOBase+1)
	DrawHex(15,24,&status,1)
	status=inportb(AtaIOCtrl)
	DrawHex(20,24,&status,1)

	return true
//#endif

int FSReadInt()
	int *p=&FSBuffer[FSBufferUsed]
	FSBufferUsed+=4
	return *p

void FSReadStr(string str)
	int l=FSReadInt()
	int n=0
	char *s=str
	while n<l
		s[n]=FSBuffer[FSBufferUsed]
		n++
		FSBufferUsed++
	s[l]=0

void GetPartitions(int disk_no)
	// mbr lesen
	AtaRead(disk_no,0,1,&AtaBuffer)
	print("\nPrimaere Partitionen:     Offset   Groesse\n")
	int n
	//MountPartition=false
	for n, 0, 4
		int *offset=&AtaBuffer[454+n*16]
		Partition[n].offset=*offset
		int *size=&AtaBuffer[458+n*16]
		Partition[n].size=*size
		char fs=AtaBuffer[450+n*16]
		Partition[n].type=fs
		print("/dev/hda")
		printi(n+1)
		if (fs!=0x00) and (*size>0)
			TextPos=60
			if AtaBuffer[446+n*16]==0x80
				print("(aktiv)")
			TextPos=27
			printi(*offset)
			TextPos=36
			printi(*size)
			TextPos=50
			if fs==0x83
				print("Linux")
			else if fs==0x20
				print("MichiFS")
				//MountPartition=true
				//PartitionMountOffset=*offset
			else if fs==0x0c
				print("Fat 32")
			else if fs==0x0e
				print("Fat 16")
			else if fs==0x07
				print("NTFS")
			else if fs==0x0f
				print("Erweitert...")
			else
				printh(&fs,1)
		else
			TextPos=50
			print("---")
		print("\n")
	/*for n, 0, 512
		DrawHex(n*3,2,&AtaBuffer[n],1)*/

void FSRead(int disk_no,int sector_offset,char *buffer)
	AtaRead(disk_no,sector_offset  ,1,buffer)
	AtaRead(disk_no,sector_offset+1,1,&buffer[512])
	AtaRead(disk_no,sector_offset+2,1,&buffer[1024])
	AtaRead(disk_no,sector_offset+3,1,&buffer[1536])

int open(string filename)
	print("        oeffne ")
	print(filename)
	print("\n")
	int n_f=-1
	int n
	for n, 0, NumFiles
		if str_equ(File[n].name,filename)
			n_f=n
	if n_f<0
		return -1
	print("Groesse: ")
	printi(File[n_f].size)
	print("\nOffset   ")
	printi(File[n_f].offset)
	print("\nClusters ")
	printi(File[n_f].num_clusters)
	print("\nName:    ")
	print(File[n_f].name)
	print("\nP-Offset ")
	OpenFile[NumOpenFiles].buffer=malloc(2048)
	OpenFile[NumOpenFiles].file=&File[n_f]
	OpenFile[NumOpenFiles].cluster_no=0
	OpenFile[NumOpenFiles].pos_in_cluster=0
	int p_offset=Partition[CurrentPartition].offset
	printi(p_offset+1+4*File[n_f].offset)
	FSRead(0,p_offset+1+4*File[n_f].offset,OpenFile[NumOpenFiles].buffer)
	//DrawHex(2,20,	OpenFile[NumOpenFiles].buffer,5);//FSBuffer,5)
	//print(OpenFile[NumOpenFiles].buffer)
	print("\n")
	OpenFile[NumOpenFiles].pos_in_cluster=0
	NumOpenFiles++
	return NumOpenFiles-1

int read(int handle,char *buffer,int size)
	if handle<0
		return -1
	int r=0

	open_file_t *of=&OpenFile[handle]

	// Datei zu Ende?
	int f_rest = of.file.size - of.cluster_no*2048 - of.pos_in_cluster
	if size > f_rest
		size = f_rest

	bool done=false
	while !done
		int post_read=0

		// Cluster zu Ende?
		int c_rest = 2048 - of.pos_in_cluster
		if size > c_rest
			post_read = size - c_rest // spaeter lesen
			size = c_rest // jetzt lesen


		// direkt lesen (aus dem Lese-Puffer kopieren)
		memcpy(buffer,&of.buffer[of.pos_in_cluster],size)
		r+=size


		if post_read>0
			// naechsten Cluster einlesen
			of.pos_in_cluster=0
			of.cluster_no++
			//print(of.cluster_no,0,"X")
			//printi(of.cluster_no)
			int cl = of.file.offset + of.cluster_no
			int p_offset=Partition[CurrentPartition].offset
			FSRead( 0, p_offset+1+4*cl,of.buffer)
			buffer=&buffer[size]
			size=post_read // noch zu lesender Rest
		else
			done=true
	return r

int GetIntFromBuffer(char *buffer,int offset,int length)
	int r=0
	int n=length-1
	while n>=0
		temp_c=buffer[n+offset]
		asm{
			xor eax, eax
			mov.b al, temp_c
			mov temp_i, eax
		}
		r=r*256+temp_i
		n--
	return r

void LoadTga(string filename)
	print("  Lade TGA-Datei....\n")

	int h=open(filename)
	int r=read(h,TGAHeader,18)

	TGAWidth=GetIntFromBuffer(TGAHeader,12,2)
	TGAHeight=GetIntFromBuffer(TGAHeader,14,2)
	TGADepth=GetIntFromBuffer(TGAHeader,16,1)
	print("Breite: ")
	printi(TGAWidth)
	print("\nHoehe: ")
	printi(TGAHeight)
	print("\nTiefe: ")
	printi(TGADepth)
	print("\n")
	int n_p=TGAWidth*TGAHeight
	TGATemp=malloc(n_p*3)
	TGAImage=malloc(n_p*4)

	read(h,TGATemp,n_p*3)
	print("TGA fertig geladen!\n")

void DrawFont(char *s)
	int i,j,x,y
	print("\n\n\n\n\n\n\n\n\n\n\n\n\n")

	i=0
	while true
		j=c2i(s[i])
		for y, 0, 13
			for x, 0, 7
				if font[j][x][y]!=0
					DrawString(x+i*7,10+y,"X")
		/*			print("X")
				else
					print(" ")*/
			//print("\n")
		i++
		if s[i]==0
			break
	WaitReturn()

void LoadTgaFont()
	print("Lade Font\n")
	LoadTga("font.tga")
	print("transformiere Font\n")
	int i, x, y
	for i, 0, 127
		for x, 0, 7
			for y, 0, 13
				int j=(i*7+6+x) + (12-y)*889
				char c=TGATemp[j*3]
				font[i][x][y]=0
				if c==0
					font[i][x][y]=0xffffffff
	print("teste Font....\n")
	/*for i, 0, 127
		printi(i)
		print("\n")
		for y, 0, 13
			for x, 0, 7
				if font[i][x][y]>0
					print("X")
				else
					print(" ")
			print("\n")
		WaitReturn()*/
	DrawFont("hallo")
	print("ok\n")

void Execute(string filename)
	//clrscr()
	print("fuehre aus: ")
	print(filename)
	print("\n")

//????????
	temp_p=&ExecBuffer
	asm{
		mov eax, temp_p
		mov temp_i, eax
		mov eax, 0x200014
		mov temp_p2, eax
	}
	//DrawHex(20,1,&pExecBuffer,4)
	
	int h=open(filename)
	read(h,ExecBuffer,1024)
	//DrawHex(20,2,ppp,4)
	//WaitReturn()
	asm{
		call 0x200014
	}

void SetTaskStateSegment(int pos,int stack_pos,int cs,int ds,void *task)
	int eip=p2i(task)
	int ss=ds
	int *tss=i2p(pos)
	tss[ 0]=0 // previous TSS (dynamisch)
	tss[ 1]=stack_pos // ESP0
	tss[ 2]=ss // SS0
	tss[ 3]=stack_pos // ESP1
	tss[ 4]=ss // SS1
	tss[ 5]=stack_pos // ESP2
	tss[ 6]=ss // SS2
	tss[ 7]=0 // CR3 (=PDPR)
	tss[ 8]=eip // eip
	tss[ 9]=0x200 // eflags (Iterrupt Flag)
	tss[10]=0 // eax
	tss[11]=0 // ecx
	tss[12]=0 // edx
	tss[13]=0 // ebx
	tss[14]=stack_pos // esp
	tss[15]=stack_pos // ebp
	tss[16]=0 // esi
	tss[17]=0 // edi
	tss[18]=ds // es
	tss[19]=cs // cs
	tss[20]=ss // ss
	tss[21]=ds // ds
	tss[22]=ds // fs
	tss[23]=ds // gs
	tss[24]=0 // ldt
	tss[25]=0

object AddTask(string name,void *func)
	asm{
		cli
	}
	task_t *t=&Task[NumTasks]
	t.pid=CurPid
	CurPid++

	memcpy(t.name,name,256)//sizeof(string))
	t.desc=NUM_PRE_GDT_ENTRIES+NumTasks
	//t.tss=malloc(128)
	t.tss=i2p(0x6000+0x80*NumTasks)
	t.stack=malloc(STACK_SIZE)
	t.status=TASK_STATUS_DEAD
	SetTaskStateSegment(p2i(t.tss),p2i(t.stack),8,16,func)
	NumTasks++

	// Global Descriptor Table
	int i
	for i, 0, NumTasks
		int base=p2i(Task[i].tss)
		print("XX")
		printh(&GDT[(i+NUM_PRE_GDT_ENTRIES)*2  ],8)
		print("-")
		int d=(base<<16)+0x007f // base[15..0] limit=103 pl=0
		GDT[(i+NUM_PRE_GDT_ENTRIES)*2  +0]=d
		d=(base&0xff000000)+0x008900+((base>>16)&0xff)  // base[31..24], not busy, base[23..16]
		if CurTask==&Task[i]
			d+=0x200
		GDT[(i+NUM_PRE_GDT_ENTRIES)*2+1+0]=d
		printh(&GDT[(i+NUM_PRE_GDT_ENTRIES)*2+0],8)
	asm{
		//lgdt [_gdtr]
		//sti
	}
	return t

void RunTask(task_t *t)
	// "Task Gate Descriptor"
	TaskCallData[0]=0
	TaskCallData[1]=8*t.desc
	temp_p=&TaskCallData[0]

	// in Task springen
	CurTask=t
	t.status=TASK_STATUS_ALIVE
	asm{
		mov eax, temp_p
		call_far [eax]
		//jmp 0x0040:0x00000000
	}

void InitTasks()
	print("init Tasks")


	CurPid=1
	NumTasks=0

	CurTask=AddTask("kernel",nil)

	//print("\n  setze Kernel-Task-Register")
	temp_i=CurTask.desc*8
	asm{
		mov eax, temp_i // Descriptor[5]
		ltr ax
	}

	print_ok()

void int_handler(int i)
	TextColor=0x04
	print("\nInt ")
	printi(i)
	if i==0
		print(": Division durch Null")
	if i==1
		print(": Debug")
	if i==3
		print(": Breakpoint")
	if i==4
		print(": Overflow")
	if i==5
		print(": Bounds Check")
	if i==6
		print(": Invalider Opcode")
	if i==7
		print(": kein Ko-Prozessor")
	if i==8
		print(": System-Fehler")
	if i==9
		print(": Ko-Prozessor-Segment overrun")
	if i==10
		print(": Invalides TSS")
	if i==11
		print(": Segment fehlt")
	if i==12
		print(": Stack-Fehler")
	if i==13
		print(": General Protection Fault")
	if i==14
		print(": Page-Fault")
	if i==16
		print(": Koprozessor-Fehler")
	print("  8-P")
	while true
		nil

void int_00()
	int_handler(0)
void int_01()
	int_handler(1)
void int_02()
	int_handler(2)
void int_03()
	int_handler(3)
void int_04()
	int_handler(4)
void int_05()
	int_handler(5)
void int_06()
	int_handler(6)
void int_07()
	int_handler(7)
void int_08()
	int_handler(8)
void int_09()
	int_handler(9)
void int_10()
	int_handler(10)
void int_11()
	int_handler(11)
void int_12()
	int_handler(12)
void int_13()
	int_handler(13)
void int_14()
	int_handler(14)
void int_15()
	int_handler(15)
void int_16()
	int_handler(16)
void int_XX()
	int_handler(2004)

void SetInterrupt(int ir,void *func)
	int *idt=i2p(0x00006800)
	if !func
		idt[ir*2  ]=0
		idt[ir*2+1]=0
	else
		int addr=p2i(func)
		// Interrupt Gate
		idt[ir*2  ]= 0x00080000 + (addr&0xffff) // desc[1],addr[15..0]
		idt[ir*2+1]= ((addr<<16)&0xffff) + 0x00008e00 // addr[31..16],typ

object SetInterruptTask(int ir,void *func)
	int *idt=i2p(0x00006800)
	if !func
		idt[ir*2  ]=0
		idt[ir*2+1]=0
	else
		task_t *t=AddTask("IRQ",func)

		// Interrupt Task Gate
		idt[ir*2  ]= 0x00080000*t.desc // desc,0[15..0]
		idt[ir*2+1]= 0x00008500 // 0[31..16],typ
		return t
	return nil

void irq_1()
	while true
		asm{
			cli
		}

		print(" IRQ ")
		outportb(0x20,0x20)
		//int k=c2i(inportb(0x60))
		//printi(k)
		asm{
			iret
		}

void int_timer()
	while true
		asm{
			cli
		}

		//print(" Timer!\n")
		print("-")
		int last=(TimerTask.tss[0]>>3)-NUM_PRE_GDT_ENTRIES
		printi(last)

		// weitere Aufrufe erlauben
		outportb(0x20,0x20)

		// zurueck
		asm{
			iret
		}

void InitInterrupts()
	print("lade Iterrupt-Tabelle")
//	WaitReturn()

	int i
	for i, 0, 256
		SetInterrupt(i,&int_XX)

	SetInterrupt( 0,&int_00)
	SetInterrupt( 1,&int_01)
	SetInterrupt( 2,&int_02)
	SetInterrupt( 3,&int_03)
	SetInterrupt( 4,&int_04)
	SetInterrupt( 5,&int_05)
	SetInterrupt( 6,&int_06)
	SetInterrupt( 7,&int_07)
	SetInterrupt( 8,&int_08)
	SetInterrupt( 9,&int_09)
	SetInterrupt(10,&int_10)
	SetInterrupt(11,&int_11)
	SetInterrupt(12,&int_12)
	SetInterrupt(13,&int_13)
	SetInterrupt(14,&int_14)
	SetInterrupt(15,&int_15)
	SetInterrupt(16,&int_16)
	TimerTask=SetInterruptTask(32,&int_timer)
	SetInterruptTask(33,&irq_1)

	// IRQs auf hoehere Interrupts legen
	outportb(0x20,0x11)
	outportb(0xa0,0x11)
	outportb(0x21,0x20)
	outportb(0xa1,0x28)
	outportb(0x21,0x04)
	outportb(0xa1,0x02)
	outportb(0x21,0x01)
	outportb(0xa1,0x01)
	outportb(0x21,0x00)
	outportb(0xa1,0x00)

	asm{
		cli
		lidt [_idtr]
		sti
	}

	//1/0

	/*outportb(0x70,0x08)
	char c=inportb(0x71)
	outportb(0x71,c|0x40)*/

	/*print("versuche boese Speicher-Operation...")
	WaitReturn()

	1/0
	asm{
		mov eax, [0xffffffff]
	}*/

	print_ok()

void second_task()
	int counter_j=1
	while true
		print(" ")
		printi(counter_j)
		TextPos++

		int i
		for i, 0, 20000
			nil

		if (counter_j%50)==0
			print("\nversuche, zurueck zu springen...\n")
			asm{
				iret
			}
		counter_j++

void InitTimer()
	print("setze Timer-Daten")
	// ticks/s: 1193180
	// 100Hz:   11932 = 0x2e9c
	int ticks_per_sec=1193180
	int ticks_till_irq=(ticks_per_sec>>10)*TASK_SWITCH_DT
	if ticks_till_irq>0xffff
		ticks_till_irq=0xffff
	//1/0
	outportb(0x43,0x34)
	outportb(0x40,i2c(ticks_till_irq))//0x9c)
	outportb(0x40,i2c(ticks_till_irq>>8))//0x2e)

	print_ok()

void TaskTest()
	print("teste Task-Faehigkeit:\n")
	print("  erstelle neue Task")

	task_t *t=AddTask("test",&second_task)
	print_ok()
	print("starte zweite Task...\n")
	WaitReturn()

	RunTask(t)

	print("\nfahre fort...\n")
	WaitReturn()
	int i
	for i, 0, 400000
		nil

	RunTask(t)

	asm{
		cli
	}

	print_ok()
	char tc=TextColor
	TextColor=0x04
	print("fertig")
	TextColor=tc
	//while true
	//	NULL

void DoConsole()
	print("Konsole....\n")
	print("Eusebius: ")
	string ips
	ips[0]=0
	int len=0
	while true

		/*int k=KEY_A
		while k<=KEY_Z
			if Key[k]
				ips[len]=i2c(k+48-KEY_A)
				len++*/
		int k
		for k, 0, NumKeys
			if Key[k]
				printi(k)

		int p=TextPos
		int l=TextLine
		print(ips)
		TextPos=p
		TextLine=l
		UpdateInput()

void main()
	asm{
		mov eax, 0xb8000
		mov.b [eax], 'M'
		add eax,0x01
		mov.b [eax], 0x20

		// Variablen laden
		mov eax, [0x5100]
		mov MemSize, eax
		mov eax, [0x5110]
		mov GDT, eax
		mov eax, _key_codes
		mov KeyCode, eax
		
		mov eax, 0xb8004
		mov.b [eax], '2'
		add eax,0x01
		mov.b [eax], 0x20
	}


	etm_init()
	print("Willkommen zu Eusebius\n\n")
	printi(MemSize/16)
	print(" mb RAM gefunden\n")
	//while true
	//	NULL


	NumMemAllocs=0
	NumOpenFiles=0


	InitInput()

	InitTasks()

	InitInterrupts()

	InitTimer()

	TaskTest()
		
	//DoConsole()
		
	//print("4")

	
	WaitReturn()

	//clrscr()
	InitAta()

	
	WaitReturn()
	
	/*AtaRead(3,68,1,AtaBuffer)
	int n
	for n, 0, 512
		DrawHex(n*3,4,&AtaBuffer[n],1)
	//GetPartitions(2)
	WaitReturn()*/

	//int d=0
	//while (d<4) and ((!DiskInfo[d].isAtapi) or (!DiskInfo[d].Available))
	//	d++;
	if (DiskInfo[0].isAtapi) or (!DiskInfo[0].Available)
		TextColor=0x04
		print("IDE 0:0 ist nicht benutzbar!")
		while true
			nil
	AtaReset(0)
	GetPartitions(0)
	WaitReturn()
	int n
	for n, 0, 512
		AtaBuffer[n]=0
/*	if AtaRead(d,16,1,&AtaBuffer)
		for n, 0, 512
			DrawHex(n*3,4,&AtaBuffer[n],1)
	else
		print("nicht lesbar\n")*/

	//print("FERTIG!!!\n")
	//while true
	//	NULL


	CurrentPartition=-1
	int np
	for np, 0, 4
		if Partition[np].type==0x20
			CurrentPartition=np

	if CurrentPartition>=0
		//clrscr()
		print("mounte /dev/hda")
		printi(CurrentPartition+1)
		print(" (mfs)...\n")
		FSRead(0,Partition[CurrentPartition].offset+1,&FSBuffer)
		//clrscr()
		print("\nDateisystem...\n")
		FSBufferUsed=0
		NumFiles=FSReadInt()
		//printi(20,2,NumFiles)
		for n, 0, NumFiles
			FSReadStr(&File[n].name)
			print("          ")
			print(File[n].name)
			print("\n")
			FSBufferUsed+=1 // IsDir
			File[n].size=FSReadInt()
			FSReadInt() // NumParts = 1
			File[n].offset=FSReadInt()
			File[n].num_clusters=FSReadInt()
		WaitReturn()
		LoadTgaFont()
		//LoadTga("b.tga")
		//Execute("hello")
	else
		TextColor=0x0c
		print("keine mfs-Partition zum mounten gefunden!\n")
		while true
			nil
	//RenderVideoBuffer()

/*	TextColor=0x0c

	print("ok")
	while true
		nil*/





	DoConsole()

	clrscr()
	while true
		UpdateInput()

		if KBCData
			clrscr()
		DrawString(16,4,"Willkommen zu Eusebius!")
		DrawString(30,21,"VESA deaktiviert!")
		/*DrawHex(10,2,&DiskInfo[0].Status,1)
		DrawHex(10,3,&DiskInfo[1].Status,1)
		DrawHex(30,2,&DiskInfo[2].Status,1)
		DrawHex(30,3,&DiskInfo[3].Status,1)
		DrawHex(15,2,&DiskInfo[0].Error,1)
		DrawHex(15,3,&DiskInfo[1].Error,1)
		DrawHex(35,2,&DiskInfo[2].Error,1)
		DrawHex(35,3,&DiskInfo[3].Error,1)
		//DrawHex(0,0,DiskInfo[0].Buffer,16)
		DrawHex(0,1,DiskInfo[1].Buffer,16)*/


		/*if KBCData
			if KBCMouse
				DrawString(45,15,"Eingabe-Maus:")
				DrawInt(50,16,InputMouse[0])
				DrawInt(50,17,InputMouse[1])
				DrawInt(50,18,InputMouse[2])
			else
				DrawString(45,15,"Eingabe-Tastatur:")
				DrawInt(50,16,TempInput)*/
		if lbut
			print("links")
		if mbut
			print("mitte")
		if rbut
			print("rechts")
	/*	DrawInt(40,13,mx)
		DrawInt(40,14,my)*/
		WasteTime()

	asm{
		jmp.b $

	//-------------------------------------------------------------
	// Daten

		_idtr:
		dw  0x07ff // 0x0087
		dd 0x00006800

	//	_ldt: // Kopier-Vorlage....
		// [0] 0x00 null descriptor
	//	dd 0x00000000
	//	dd 0x00000000
		// [1] 0x08 code descriptor
	//	dd 0x0000ffff
	//	dd 0x00cf9a00
		// [2] 0x10 data descriptor
	//	dd 0x0000ffff
	//	dd 0x00cf9200


		_key_codes:
		dd 0x001d009d // KEY_LCONTROL
		dd 0xe01de09d // KEY_RCONTROL
		dd 0x002a00aa // KEY_LSHIFT
		dd 0x003600b6 // KEY_RSHIFT
		dd 0x003800b8 // KEY_LALT
		dd 0xe038e0b8 // KEY_RALT
		dd 0xffffffff // KEY_ADD,
		dd 0xffffffff // KEY_SUBTRACT,
		dd 0xffffffff // KEY_FENCE,		// "Raute"???
		dd 0xe04fe0cf // KEY_END,
		dd 0xe049e0c9 // KEY_NEXT,
		dd 0xe051e0d1 // KEY_PRIOR,
		dd 0xe048e0c8 // KEY_UP,
		dd 0xe050e0d0 // KEY_DOWN,
		dd 0xe04be0cb // KEY_LEFT,
		dd 0xe04de0cd // KEY_RIGHT,
		dd 0x001c009c // KEY_RETURN,
		dd 0x00010081 // KEY_ESCAPE,
		dd 0xe052e0d2 // KEY_INSERT,
		dd 0xe05300d3 // KEY_DELETE,
		dd 0x003900b9 // KEY_SPACE,
		dd 0x003b00bb // KEY_F1,
		dd 0x003c00bc // KEY_F2,
		dd 0x003d00bd // KEY_F3,
		dd 0x003e00be // KEY_F4,
		dd 0x003f00bf // KEY_F5,
		dd 0x004000c0 // KEY_F6,
		dd 0x004100c1 // KEY_F7,
		dd 0x004200c2 // KEY_F8,
		dd 0x004300c3 // KEY_F9,
		dd 0x004400c4 // KEY_F10,
		dd 0x005700d7 // KEY_F11,
		dd 0x005800d8 // KEY_F12,
		dd 0x000b008b // KEY_0,
		dd 0x00020082 // KEY_1,
		dd 0x00030083 // KEY_2,
		dd 0x00040084 // KEY_3,
		dd 0x00050085 // KEY_4,
		dd 0x00060086 // KEY_5,
		dd 0x00070087 // KEY_6,
		dd 0x00080088 // KEY_7,
		dd 0x00090089 // KEY_8,
		dd 0x000a008a // KEY_9,
		dd 0x001E009E // KEY_A,
		dd 0x003000b0 // KEY_B,
		dd 0x002e00ae // KEY_C,
		dd 0x002000a0 // KEY_D,
		dd 0x00120092 // KEY_E,
		dd 0x002100a1 // KEY_F,
		dd 0x002200a2 // KEY_G,
		dd 0x002300a3 // KEY_H,
		dd 0x00170097 // KEY_I,
		dd 0x002400a4 // KEY_J,
		dd 0x002500a5 // KEY_K,
		dd 0x002600a6 // KEY_L,
		dd 0x003200b2 // KEY_M,
		dd 0x003100b1 // KEY_N,
		dd 0x00180098 // KEY_O,
		dd 0x00190099 // KEY_P,
		dd 0x00100090 // KEY_Q,
		dd 0x00130093 // KEY_R,
		dd 0x001f009f // KEY_S,
		dd 0x00140094 // KEY_T,
		dd 0x00160096 // KEY_U,
		dd 0x002f00af // KEY_V,
		dd 0x00110091 // KEY_W,
		dd 0x002d00ad // KEY_X,
		dd 0x00150095 // KEY_Y,
		dd 0x002c00ac // KEY_Z,
		dd 0x000e008e // KEY_BACKSPACE,
		dd 0x000f008f // KEY_TAB,
		dd 0xe049e0c9 // KEY_HOME,
		dd 0x005200d2 // KEY_NUM_0,
		dd 0x004f00cf // KEY_NUM_1,
		dd 0x005000d0 // KEY_NUM_2,
		dd 0x005100d1 // KEY_NUM_3,
		dd 0x004b00cb // KEY_NUM_4,
		dd 0x004c00cc // KEY_NUM_5,
		dd 0x004d00cd // KEY_NUM_6,
		dd 0x004700c7 // KEY_NUM_7,
		dd 0x004800c8 // KEY_NUM_8,
		dd 0x004900c9 // KEY_NUM_9,
		dd 0x004e00ce // KEY_NUM_ADD,
		dd 0x004a00ca // KEY_NUM_SUBTRACT,
		dd 0x003700b7 // KEY_NUM_MULTIPLY,
		dd 0xe03500b5 // KEY_NUM_DIVIDE,
		dd 0xffffffff // KEY_NUM_COMMA,
		dd 0xffffffff // KEY_NUM_ENTER,
		dd 0xffffffff // KEY_COMMA,
		dd 0xffffffff // KEY_DOT,
		dd 0xffffffff // KEY_SMALLER,
		dd 0xffffffff // KEY_SZ,
		dd 0xffffffff // KEY_AE,
		dd 0xffffffff // KEY_OE,
		dd 0xffffffff // KEY_UE,
		dd 0xffffffff // KEY_GRAVE,

	}


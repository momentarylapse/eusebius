use image
use lib.std
use lib.std.sys
use lib.std.file
use lib.std.net
use lib.io
use lib.pci
use lib.vesa
#use lib.x
use hui


const XCMD_KILL = 666
const XCMD_NEW_WINDOW= 1024
const XCMD_DEL_WINDOW = 1025
const XCMD_WINDOW_MOVE = 1026
const XCMD_WINDOW_INVALIDATE = 1027
const XCMD_WINDOW_GET_SIZE = 2048
const XCMD_WINDOW_GET_POS = 2049
const XCMD_WINDOW_DRAG_START = 2050
const XCMD_WINDOW_DRAG_STOP = 2051
const XCMD_WINDOW_ACTIVATE = 2052
const XCMD_POINTER_GET_WINDOW = 3072
const XCMD_EXECUTE = 4096

const XCMD_EVENT_MOUSE = 3072
const XCMD_EVENT_KEY = 3073
const XCMD_EVENT_DRAW = 3074

const CON_STATUS_CLEAR = 0
const CON_STATUS_BUSY = 13
const CON_STATUS_SERVER_SEND = 1
const CON_STATUS_SERVER_ANSWER = 2
const CON_STATUS_CLIENT_SEND = 3
const CON_STATUS_CLIENT_ANSWER = 4

const WF_TRANSPARENT = 1024
const WF_DONT_INVALIDATE = 2048

class MouseController
	var xx, yy: float
	var scale: float
	var x, y, flags: int
	var cursor: owned![XWindow]
	var drag_win: XWindow*
	
	var dev: int
	var sending: bool
	
	func __init__()
		scale = 1.0 #3.5
	
		x = screen_width / 2
		y = screen_height / 2
		xx = x * scale
		yy = y * scale
		dev = open("/dev/mouse", O_RDONLY | O_NONBLOCK)
		#fcntl(dev, F_SETFL, O_RDONLY | O_NONBLOCK)
		
		drag_win = nil
		sending = false
	
	func mut set(x: int, y: int)
		self.x = x
		self.y = y
		xx = x * scale
		yy = y * scale
		
	func mut create()

		var im = Image.load("/images/cursor.tga")
		# FIXME should return xfer?[]...
	
#		if weak(im)
#			cursor = new XWindow(nil, x - im.width/2, y - im.height/2, im.width, im.height, WF_TRANSPARENT | 7)
#			cursor.fill_image(0, 0, im)
#		else
#			cursor = new XWindow(nil, x-16, y-16, 32, 32, WF_TRANSPARENT | 7)
#			cursor.fill(0xffc0c0c0)

	func mut poll_single() -> bool
		var m: int[4]
		if read(dev, &m, 4*4) < 16
			return false
		print("M")
		flags = m[0]
		xx += m[1]
		yy -= m[2]
		let max_x = float(screen_width - 1) * scale
		let max_y = float(screen_height - 1) * scale
		if xx < 0
			xx = 0
		if xx > max_x
			xx = max_x
		if yy < 0
			yy = 0
		if yy > max_y
			yy = max_y
		x = xx / scale
		y = yy / scale
	
		return true

	func mut poll()
		var x0 = x
		var y0 = y
		var need_update = false
		for i in 0:8
			if !poll_single()
				break
			need_update = true
		if need_update
			if !sending
				sending = true
				for c in cmds.clients
					c.send_mouse()
				sending = false
			cursor.move(x - cursor.r.w()/2, y - cursor.r.h()/2)
			for w in drag_win
				w.move(w.r.x0 + x - x0, w.r.y0 + y - y0)

var mouse: owned![MouseController]

class KeyboardController
	var key: int
	var handle: int
	var control, shift, altgr: bool
	var escaped: bool
	func __init__()
		handle = open("/dev/keyboard", O_RDONLY | O_NONBLOCK)
#		fcntl(stdin, F_SETFL, O_RDONLY | O_NONBLOCK)
		control = false
		shift = false
		altgr = false
		escaped = false
	func mut digest(_k: int)
		var k = _k
		if k == 0xe0
			escaped = true
			return

		if escaped
			k += 0xe000
		escaped = false
	
		if (k & 0x80) > 0
			if k == 0xaa or k == 0xb6
				shift = false
			if k == 0x9d or k == 0xe09d
				control = false
			if k == 0xe0b8
				altgr = false
		if k == 0x2a or k == 0x36
			shift = true
		if k == 0x1d or k == 0xe01d
			control = true
		if k == 0xe038
			altgr = true
		
		key = getkey(k)
		if key < 0
			return
		if shift
			key += KEY_SHIFT
		if control
			key += KEY_CONTROL
		if altgr
			key += KEY_ALT
		
		for cc in cmds.clients
			cc.send_key()
	func getkey(k: int) -> int
		if k == 0x1c
			return KEY_RETURN
		if k == 0x39
			return KEY_SPACE
		if k == 0x0e
			return KEY_BACKSPACE
		if k == 0xe053
			return KEY_DELETE
		if k == 0xe048
			return KEY_UP
		if k == 0xe050
			return KEY_DOWN
		if k == 0xe04b
			return KEY_LEFT
		if k == 0xe04d
			return KEY_RIGHT
		if k == 0x0b
			return KEY_0
		if k == 0x02
			return KEY_1
		if k == 0x03
			return KEY_2
		if k == 0x04
			return KEY_3
		if k == 0x05
			return KEY_4
		if k == 0x06
			return KEY_5
		if k == 0x07
			return KEY_6
		if k == 0x08
			return KEY_7
		if k == 0x09
			return KEY_8
		if k == 0x0a
			return KEY_9
		if k == 0x35
			return KEY_MINUS
		if k == 0x34
			return KEY_DOT
		if k == 0x33
			return KEY_COMMA
		if k == 0x56
			return KEY_LESS
		if k == 0x2b
			return KEY_FENCE
		if k == 0x1b
			return KEY_PLUS
		if k == 0x29
			return -1 # '^'
		if k == 0x0c
			return KEY_SZ
		if k == 0x0d
			return -1 # 'Â´'
			
		if k == 0x1e
			return KEY_A
		if k == 0x30
			return KEY_B
		if k == 0x2e
			return KEY_C
		if k == 0x20
			return KEY_D
		if k == 0x12
			return KEY_E
		if k == 0x21
			return KEY_F
		if k == 0x22
			return KEY_G
		if k == 0x23
			return KEY_H
		if k == 0x17
			return KEY_I
		if k == 0x24
			return KEY_J
		if k == 0x25
			return KEY_K
		if k == 0x26
			return KEY_L
		if k == 0x32
			return KEY_M
		if k == 0x31
			return KEY_N
		if k == 0x18
			return KEY_O
		if k == 0x19
			return KEY_P
		if k == 0x10
			return KEY_Q
		if k == 0x13
			return KEY_R
		if k == 0x1f
			return KEY_S
		if k == 0x14
			return KEY_T
		if k == 0x16
			return KEY_U
		if k == 0x2f
			return KEY_V
		if k == 0x11
			return KEY_W
		if k == 0x2d
			return KEY_X
		if k == 0x2c
			return KEY_Y
		if k == 0x15
			return KEY_Z
		return -1

	func mut poll()
		var k = 0
		let r = read(handle, &k, 1)
		if r > 0
			digest(k)

var keyboard: owned![KeyboardController]

func XExit()
	bga_write_register(VbeIndex.ENABLE, VBE_DISPI_DISABLED)
	exit(0)

struct XRect
	var x0, y0, x1, y1: int
	func w() -> int
		return x1 - x0
	func h() -> int
		return y1 - y0
	func inside(x: int, y: int) -> bool
		return x >= x0 and x < x1 and y >= y0 and y < y1


class XWindow
	var client: Client*
	var id: int
	var r: XRect
	var shm_key: int
	var shm_id: int
	var buf: int[0]&
	var transparent: bool
	var level: int
	
#	func __init__(client: Client*, _x: int, _y: int, w: int, h: int, flags: int)
#		kprint("x: new win\n")
#		self.client = client
#		var x = _x
#		var y = _y
#		if x < 0
#			x = rand(screen_width - w)
#		if y < 0
#			y = rand(screen_height - h)
#		r.x0 = x
#		r.y0 = y
#		r.x1 = x + w
#		r.y1 = y + h
#		level = flags & 0xf
#		transparent = ((flags & WF_TRANSPARENT) > 0)
#		id = next_window_id
#		next_window_id ++
#		shm_key = next_window_id + 0x0f810000 # randi()
#		shm_id = shmget(shm_key, w*h*4, SHM_DEST | IPC_CREAT)
#		if shm_id < 0
#			print("x: ERROR can't create shared memory for window")
#			# TODO clean-up
#		else
#			for b in shmat(shm_id, 0)
#				buf := b
#			windows.add(&self)
#			sort_windows()
#			if (flags & WF_DONT_INVALIDATE) == 0
#				invalidated.add(r)
		
	func __delete__()
		kprint("x: del win\n")
		for b in buf
			invalidated.add(r)
			shmdt(b)
		for n=>ww in windows
			if ww == &self
				windows_r.remove(len(windows) - n - 1)
				windows.remove(n)
	
	func mut move(x: int, y: int)
		var r0 = r
		r.x1 += x - r.x0
		r.y1 += y - r.y0
		r.x0 = x
		r.y0 = y
		invalidated.add(r)
		invalidated.add(r0)
#		for c in client
#			c.send(XCMD_WINDOW_MOVE, id, r.x0, r.y0, 0, 0)
	
	#void draw_rect(int x, int y, int w, int h, int c)
	func mut fill(c: int)
		let n = r.w() * r.h()
		for i in 0:n
			buf[i] = c
	func mut fill_image(dx: int, dy: int, im: Image&)
		#int x1 = dx
#		if x1 < 0
#			x1 = 0
#			
#		for y in y1:y2
#			for x in x1:x2
		let w = r.w()
		let h = r.h()
		for y in 0:h
			for x in 0:w
				buf[x + y*w] = im.data[x + y*w]

var next_window_id: int
var windows, windows_r: XWindow&[]
var desktop: owned![XWindow]
var active_window: XWindow*

func sort_windows()
	for i in 0:len(windows)
		for j in i+1:len(windows)
			if windows[i].level > windows[j].level
				var t = windows[i]
				windows[i] := windows[j]
				windows[j] := t
	windows_r.resize(len(windows))
	for i=>w in windows
		windows_r[len(windows) - i - 1] := w

var invalidated: XRect[]

func find_top_most_window(x: int, y: int) -> XWindow*
	for w in windows_r
		if w.level != 2
			continue
		if w.r.inside(x, y)
			return w
	return nil

func activate_window(win: XWindow*)
	if active_window == win
		return
#	for a in active_window
#		for c in a.client
#			c.send(XCMD_WINDOW_ACTIVATE, -1, 0, 0, 0, 0)
#	active_window = win
#	for a in active_window
#		for c in a.client
#			c.send(XCMD_WINDOW_ACTIVATE, a.id, 0, 0, 0, 0)

func draw(rr: XRect)
	var r = rr
	if r.x0 < 0
		r.x0 = 0
	if r.x1 >= screen_width
		r.x1 = screen_width-1
	if r.y0 < 0
		r.y0 = 0
	if r.y1 >= screen_height
		r.y1 = screen_height-1
	for y in r.y0:r.y1
		var xs = r.x0
		while xs < r.x1
			var xe = r.x1
			
			# find the top most window at (x1,y)
			var ww: XWindow* = nil
			for i=>w in windows_r
				if w.r.inside(xs, y)
					ww = w
					if w.r.x1 < xe
						xe = w.r.x1
					# test for overlap in [y]*[xs:xe]
					for j in 0:i
						var v = windows_r[j]
						if y < v.r.y0 or y >= v.r.y1
							continue
						if xe <= v.r.x0 or xs >= v.r.x1
							continue
						xe = v.r.x0
					break
			for _ww in ww
				if _ww.transparent
					# brute force :P
					for x in xs:xe
						for w in windows_r
							if w.r.inside(x, y)
								let dx = x-w.r.x0
								let dy = y-w.r.y0
								let c = w.buf[dx + dy*w.r.w()]
								if w.transparent
									if (c & 0xff000000) != 0
										set_pixel(x, y, c)
										break
								else
									set_pixel(x, y, c)
									break
				else
					let dy = y - _ww.r.y0
					let dx = xs - _ww.r.x0
					let index = dx + dy*_ww.r.w()
					set_pixels(xs, y, &_ww.buf[index], xe-xs)
					#for x in xs:xe
#						set_pixel(x, y, ww.buf[index])
#						index ++
			xs = xe
	

func draw_invalidated()
	for r in invalidated
		draw(r)
	invalidated.clear()


class Client
	var sock: int
	var kill_me: bool
	var win: owned![XWindow][]
	var buf: int[8]
	
	func __init__(_sock: int)
		sock = _sock
		kill_me = false
		kprint("x: new client sock={{sock}}\n")
	
	func __delete__()
		kprint("x: del client\n")
		win.clear()
		#for w in win
		#	del w
		close(sock)
	
#	func mut send(cmd: int, p1: int, p2: int, p3: int, p4: int, p5: int)
#		kprint(" x:send ")
#		buf[0] = cmd
#		buf[1] = p1
#		buf[2] = p2
#		buf[3] = p3
#		buf[4] = p4
#		buf[5] = p5
#		var r = write(sock, &buf[0], 4*8)
#		kprint(str(r))
#		#return buf[32]
#		kprint(" x:/send ")
	
	func mut send_mouse()
		kprint("x: send mouse\n")
		var w = find_top_most_window(mouse.x, mouse.y)
		var id = -1
		for _w in w
			id = _w.id
#		send(XCMD_EVENT_MOUSE, mouse.x, mouse.y, mouse.flags, id, 0)
	
	func mut send_key()
		kprint("x: send key\n")
#		send(XCMD_EVENT_KEY, keyboard.key, 0, 0, 0, 0)
	
	func mut poll()
		let n = read(sock, &buf[0], 4*8)
		if n == -ENOTCONN
			kill_me = true
			return
		if n <= 0
			return
		kprint("x: recv\n")
		if buf[0] == XCMD_KILL
			kill_me = true
#		else if buf[0] == XCMD_NEW_WINDOW
#			var ww = new XWindow(&self, buf[1], buf[2], buf[3], buf[4], 2 | WF_DONT_INVALIDATE)
#			send(XCMD_NEW_WINDOW, ww.id, ww.shm_key, ww.r.x0, ww.r.y0, 0)
#			kprint("x: c.sock={{sock}} w.key={{ww.shm_key}}\n")
#			activate_window(weak(ww))
#			win.add(give(ww))
		else if buf[0] == XCMD_WINDOW_INVALIDATE
			for w in win
				if w.id == buf[1]
					invalidated.add(w.r)
		else if buf[0] == XCMD_WINDOW_MOVE
			for w in win
				if w.id == buf[1]
					w.move(buf[2], buf[3])
		else if buf[0] == XCMD_WINDOW_GET_POS
			for w in win
				if w.id == buf[1]
#					send(XCMD_WINDOW_GET_POS, w.id, w.r.x0, w.r.y0, 0, 0)
					break
		else if buf[0] == XCMD_WINDOW_GET_SIZE
			for w in win
				if w.id == buf[1]
#					send(XCMD_WINDOW_GET_SIZE, w.id, w.r.w(), w.r.h(), 0, 0)
					break
		else if buf[0] == XCMD_WINDOW_DRAG_START
			for w in win
				if w.id == buf[1]
					mouse.drag_win = w
					break
		else if buf[0] == XCMD_WINDOW_DRAG_STOP
			for w in win
				if w.id == buf[1]
					mouse.drag_win = nil
					break
		else if buf[0] == XCMD_WINDOW_ACTIVATE
			for w in win
				if w.id == buf[1]
					w.level = 3
					sort_windows()
					w.level = 2
					activate_window(w)
					invalidated.add(w.r)
					break
		else if buf[0] == XCMD_DEL_WINDOW
			for i=>w in win
				if w.id == buf[1]
					win.remove(i)
					break
#		else if buf[0] == XCMD_POINTER_GET_WINDOW
#			for w in find_top_most_window(mouse.x, mouse.y)
#				send(XCMD_POINTER_GET_WINDOW, w.id, 0, 0, 0, 0)
#			else
#				send(XCMD_POINTER_GET_WINDOW, -1, 0, 0, 0, 0)
#		else if buf[0] == XCMD_EXECUTE
#			var cmd: string[]
#			for i in 0:buf[1]
#				cmd.add(read_string())
#			#print("EXE  " + cmd[0] + "  ---")
#			let r = pm.run(cmd)
#			send(XCMD_EXECUTE, r, 0, 0, 0, 0)
	
	func read_string() -> string
		var num: int
		read(sock, &num, 4)
		var s: string
		s.resize(num)
		read(sock, &s[0], num)
		return s
			
		

class CommandController
	var sock: int
	#int connection
	var clients: owned![Client][]
	
	func __init__()
	
		sock = socket(0)
		if !bind(sock, 0x7bcd0123)
			print("x: bind() failed")
			exit(-1)
		if !listen(sock)
			print("x: listen() failed")
			exit(-1)
		fcntl(sock, F_SETFL, O_RDWR | O_NONBLOCK)
		
		#mkfifo("/tmp/x")
		#connection = open("/tmp/x", O_RDONLY)
	
	func mut update()
		let ss = accept(sock)
		if ss >= 0
			fcntl(ss, F_SETFL, O_RDWR | O_NONBLOCK)
			clients.add(new Client(ss))
			
		for c in clients
			c.poll()
		for i in 0:len(clients)
			if clients[i].kill_me
				clients.remove(i)
				i --

var cmds: owned![CommandController]

class ProcessManager
	var pids: int[]
	func mut run(cmd: string[]) -> int
		let r = execute(cmd, -1, -1)
		if r >= 0
			pids.add(r)
		return r
	func mut update()
		for p in pids
			var status: int
			if waitpid(p, &status, false) == -2
				continue
			p = -1
		for i in 0:len(pids)
			if pids[i] < 0
				pids.remove(i)
				i --

var pm: owned![ProcessManager]

func main()
	init_lib()
	let args = get_args()
	
	vesa_init()

	next_window_id = 0
	windows.__init__()
	windows_r.__init__()
	invalidated.__init__()
	active_window = nil
	
	
	cmds = new CommandController()
	mouse = new MouseController()
	keyboard = new KeyboardController()
	pm = new ProcessManager()
	
	if len(args) == 0
		#bga_set_video_mode(800, 600, 32)
		bga_set_video_mode(1024, 768, 32)
		mouse.set(screen_width / 2, screen_height / 2)
	
#	desktop = new XWindow(nil, 0, 0, screen_width, screen_height, 1)
#	if vga_mem2
#	desktop.fill(0xff242040)
#	else
#		desktop.fill(0xff000000)
	
	mouse.create()
	
	draw_invalidated()
	
#	execute(["/bin/xdesktop"], -1, -1)
	#execute(["/bin/xtest"], -1, -1)
	#execute(["/bin/c"], -1, -1)
	#execute(["/bin/xterm"], -1, -1)
	
	print("x: running")
	while true
		pm.update()
		cmds.update()
		mouse.poll()
		keyboard.poll()
		draw_invalidated()
		usleep(5000)
		
	XExit()

use "lib/std.kaba"
use "lib/io.kaba"
use "lib/pci.kaba"
use "lib/vesa.kaba"
//use "lib/x.kaba"


const int XCMD_KILL = 666
const int XCMD_NEW_WINDOW= 1024
const int XCMD_DEL_WINDOW = 1025
const int XCMD_WINDOW_MOVE = 1026
const int XCMD_WINDOW_INVALIDATE = 1027
const int XCMD_WINDOW_GET_SIZE = 2048
const int XCMD_WINDOW_GET_POS = 2049
const int XCMD_WINDOW_DRAG_START = 2050
const int XCMD_WINDOW_DRAG_STOP = 2051
const int XCMD_WINDOW_ACTIVATE = 2052
const int XCMD_POINTER_GET_WINDOW = 3072

const int XCMD_EVENT_MOUSE = 3072
const int XCMD_EVENT_KEY = 3073
const int XCMD_EVENT_DRAW = 3074

const int CON_STATUS_CLEAR = 0
const int CON_STATUS_BUSY = 13
const int CON_STATUS_SERVER_SEND = 1
const int CON_STATUS_SERVER_ANSWER = 2
const int CON_STATUS_CLIENT_SEND = 3
const int CON_STATUS_CLIENT_ANSWER = 4

const int WF_TRANSPARENT = 1024
const int WF_DONT_INVALIDATE = 2048

class MouseController
	int x, y, flags
	XWindow* cursor
	XWindow* drag_win
	
	int dev
	bool sending
	
	void __init__()
	
		x = screen_width / 2
		y = screen_height / 2
		dev = open("/dev/mouse", O_RDONLY | O_NONBLOCK)
		//fcntl(dev, F_SETFL, O_RDONLY | O_NONBLOCK)
		
		drag_win = nil
		sending = false
		
	void create()

		Image *im = LoadImage("/images/cursor.tga")
	
		if im
			cursor = new XWindow(nil, x - im.width/2, y - im.height/2, im.width, im.height, WF_TRANSPARENT | 7)
			cursor.fill_image(0, 0, im)
		
			delete im
		else
			cursor = new XWindow(nil, x-16, y-16, 32, 32, WF_TRANSPARENT | 7)
			cursor.fill(0xffc0c0c0)

	bool poll_single()
		int[4] m
		if read(dev, &m, 4*4) < 16
			return false
		flags = m[0]
		x += m[1]
		y -= m[2]
		if x < 0
			x = 0
		if x >= screen_width
			x = screen_width - 1
		if y < 0
			y = 0
		if y >= screen_height
			y = screen_height - 1
	
		return true

	void poll()
		int x0 = x
		int y0 = y
		bool need_update = false
		for i in 0:8
			if !poll_single()
				break
			need_update = true
		if need_update
			if !sending
				sending = true
				for c in cmds.clients
					c.send_mouse()
				sending = false
			cursor.move(x - cursor.r.w()/2, y - cursor.r.h()/2)
			if drag_win
				drag_win.move(drag_win.r.x0 + x - x0, drag_win.r.y0 + y - y0)

MouseController* mouse

class KeyboardController
	int key
	void __init__()
		fcntl(stdin, F_SETFL, O_RDONLY | O_NONBLOCK)
	void poll()
		key = 0
		if read(stdin, &key, 1) <= 0
			return
		for c in cmds.clients
			c.send_key()

KeyboardController* keyboard

void XExit()
	BgaWriteRegister(VBE_DISPI_INDEX_ENABLE, VBE_DISPI_DISABLED)
	exit(0)

class XRect
	int x0, y0, x1, y1
	int w()
		return x1 - x0
	int h()
		return y1 - y0
	bool inside(int x, int y)
		return x >= x0 and x < x1 and y >= y0 and y < y1


class XWindow
	Client* client
	int id
	XRect r
	int shm_key
	int shm_id
	int[0]* buf
	bool transparent
	int level
	
	void __init__(Client* client, int x, int y, int w, int h, int flags)
		kprint("x: new win\n")
		self.client = client
		if x < 0
			x = randi(screen_width - w)
		if y < 0
			y = randi(screen_height - h)
		r.x0 = x
		r.y0 = y
		r.x1 = x + w
		r.y1 = y + h
		level = flags & 0xf
		transparent = ((flags & WF_TRANSPARENT) > 0)
		id = next_window_id
		next_window_id ++
		shm_key = next_window_id + 0x0f810000 // randi()
		shm_id = shmget(shm_key, w*h*4, SHM_DEST | IPC_CREAT)
		if shm_id < 0
			print("x: ERROR can't create shared memory for window\n")
			// TODO clean-up
		else
			buf = shmat(shm_id, 0)
			windows.add(self)
			sort_windows()
			if (flags & WF_DONT_INVALIDATE) == 0
				invalidated.add(r)
		
	void __delete__()
		kprint("x: del win\n")
		if buf
			invalidated.add(r)
			shmdt(buf)
		for ww,n in windows
			if ww == self
				windows_r.remove(windows.num - n - 1)
				windows.remove(n)
	
	void move(int x, int y)
		XRect r0 = r
		r.x1 += x - r.x0
		r.y1 += y - r.y0
		r.x0 = x
		r.y0 = y
		invalidated.add(r)
		invalidated.add(r0)
		if client
			client.send(XCMD_WINDOW_MOVE, id, r.x0, r.y0, 0, 0)
	
	//void draw_rect(int x, int y, int w, int h, int c)
	void fill(int c)
		int n = r.w() * r.h()
		for i in 0:n
			buf[i] = c
	void fill_image(int dx, int dy, Image *im)
		/*int x1 = dx
		if x1 < 0
			x1 = 0
			
		for y in y1:y2
			for x in x1:x2*/
		int w = r.w()
		int h = r.h()
		for y in 0:h
			for x in 0:w
				buf[x + y*w] = im.data[x + y*w]

int next_window_id
XWindow*[] windows, windows_r
XWindow* desktop
XWindow* active_window

void sort_windows()
	for i in 0:windows.num
		for j in i+1:windows.num
			if windows[i].level > windows[j].level
				XWindow *t = windows[i]
				windows[i] = windows[j]
				windows[j] = t
	windows_r.resize(windows.num)
	for w, i in windows
		windows_r[windows.num - i - 1] = w

XRect[] invalidated

XWindow* find_top_most_window(int x, int y)
	for w in windows_r
		if w.level != 2
			continue
		if w.r.inside(x, y)
			return w
	return nil

void activate_window(XWindow *win)
	if active_window == win
		return
	if active_window
		active_window.client.send(XCMD_WINDOW_ACTIVATE, -1, 0, 0, 0, 0)
	active_window = win
	if active_window
		active_window.client.send(XCMD_WINDOW_ACTIVATE, win.id, 0, 0, 0, 0)

void draw(XRect rr)
	XRect r = rr
	if r.x0 < 0
		r.x0 = 0
	if r.x1 >= screen_width
		r.x1 = screen_width-1
	if r.y0 < 0
		r.y0 = 0
	if r.y1 >= screen_height
		r.y1 = screen_height-1
	for y in r.y0:r.y1
		int xs = r.x0
		while xs < r.x1
			int xe = r.x1
			
			// find the top most window at (x1,y)
			XWindow *ww = nil
			for w,i in windows_r
				if w.r.inside(xs, y)
					ww = w
					if w.r.x1 < xe
						xe = w.r.x1
					// test for overlap in [y]*[xs:xe]
					for j in 0:i
						XWindow *v = windows_r[j]
						if y < v.r.y0 or y >= v.r.y1
							continue
						if xe <= v.r.x0 or xs >= v.r.x1
							continue
						xe = v.r.x0
					break
			if !ww
				xs = xe
				continue
			if ww.transparent
				// brute force :P
				for x in xs:xe
					for w in windows_r
						if w.r.inside(x, y)
							int dx = x-w.r.x0
							int dy = y-w.r.y0
							int c = w.buf[dx + dy*w.r.w()]
							if w.transparent
								if (c & 0xff000000) != 0
									setPixel(x, y, c)
									break
							else
								setPixel(x, y, c)
								break
			else
				int dy = y-ww.r.y0
				int dx = xs-ww.r.x0
				int index = dx + dy*ww.r.w()
				for x in xs:xe
					setPixel(x, y, ww.buf[index])
					index ++
			
			xs = xe
	

void draw_invalidated()
	for r in invalidated
		draw(r)
	invalidated.clear()


class Client
	int sock
	bool kill_me
	XWindow*[] win
	int[8] buf
	
	void __init__(int _sock)
		sock = _sock
		kill_me = false
		kprint("x: new client sock=" + sock + " \n")
	
	void __delete__()
		kprint("x: del client\n")
		for w in win
			delete w
		close(sock)
	
	void send(int cmd, int p1, int p2, int p3, int p4, int p5)
		kprint(" x:send ")
		buf[0] = cmd
		buf[1] = p1
		buf[2] = p2
		buf[3] = p3
		buf[4] = p4
		buf[5] = p5
		kprint(write(sock, &buf[0], 4*8))
		//return buf[32]
		kprint(" x:/send ")
	
	void send_mouse()
		kprint("x: send mouse\n")
		XWindow* w = find_top_most_window(mouse.x, mouse.y)
		int id = -1
		if w
			id = w.id
		send(XCMD_EVENT_MOUSE, mouse.x, mouse.y, mouse.flags, id, 0)
	
	void send_key()
		kprint("x: send key\n")
		send(XCMD_EVENT_KEY, keyboard.key, 0, 0, 0, 0)
	
	void poll()
		int n = read(sock, &buf[0], 4*8)
		if n <= 0
			return
		kprint("x: empfange\n")
		if buf[0] == XCMD_KILL
			kill_me = true
		else if buf[0] == XCMD_NEW_WINDOW
			XWindow* ww = new XWindow(self, buf[1], buf[2], buf[3], buf[4], 2 | WF_DONT_INVALIDATE)
			win.add(ww)
			send(XCMD_NEW_WINDOW, ww.id, ww.shm_key, ww.r.x0, ww.r.y0, 0)
			kprint("x: c.sock=" + sock + " w.key=" + ww.shm_key + "\n")
			activate_window(ww)
		else if buf[0] == XCMD_WINDOW_INVALIDATE
			for w in win
				if w.id == buf[1]
					invalidated.add(w.r)
		else if buf[0] == XCMD_WINDOW_MOVE
			for w in win
				if w.id == buf[1]
					w.move(buf[2], buf[3])
		else if buf[0] == XCMD_WINDOW_GET_POS
			for w in win
				if w.id == buf[1]
					send(XCMD_WINDOW_GET_POS, w.id, w.r.x0, w.r.y0, 0, 0)
					break
		else if buf[0] == XCMD_WINDOW_GET_SIZE
			for w in win
				if w.id == buf[1]
					send(XCMD_WINDOW_GET_SIZE, w.id, w.r.w(), w.r.h(), 0, 0)
					break
		else if buf[0] == XCMD_WINDOW_DRAG_START
			for w in win
				if w.id == buf[1]
					mouse.drag_win = w
					break
		else if buf[0] == XCMD_WINDOW_DRAG_STOP
			for w in win
				if w.id == buf[1]
					mouse.drag_win = nil
					break
		else if buf[0] == XCMD_WINDOW_ACTIVATE
			for w in win
				if w.id == buf[1]
					w.level = 3
					sort_windows()
					w.level = 2
					activate_window(w)
					invalidated.add(w.r)
					break
		else if buf[0] == XCMD_POINTER_GET_WINDOW
			XWindow* w = find_top_most_window(mouse.x, mouse.y)
			if w
				send(XCMD_POINTER_GET_WINDOW, w.id, 0, 0, 0, 0)
			else
				send(XCMD_POINTER_GET_WINDOW, -1, 0, 0, 0, 0)
		

class CommandController
	int sock
	//int connection
	Client*[] clients
	
	void __init__()
	
		sock = socket(0)
		if !bind(sock, 0x7bcd0123)
			print("x: Fehler bind()\n")
			exit(-1)
		if !listen(sock)
			print("x: Fehler listen()\n")
			exit(-1)
		fcntl(sock, F_SETFL, O_RDWR | O_NONBLOCK)
		
		//mkfifo("/tmp/x")
		//connection = open("/tmp/x", O_RDONLY)
	
	void update()
		int ss = accept(sock)
		if ss >= 0
			fcntl(ss, F_SETFL, O_RDWR | O_NONBLOCK)
			clients.add(new Client(ss))
			
		for c in clients
			c.poll()
		for i in 0:clients.num
			if clients[i].kill_me
				delete clients[i]
				clients.remove(i)
				i --

CommandController *cmds

void main()
	init_lib()
	string[] arg
	get_args(arg)
	
	vesa_init()

	next_window_id = 0
	windows.__init__()
	windows_r.__init__()
	invalidated.__init__()
	active_window = nil
	
	
	
	cmds = new CommandController
	mouse = new MouseController
	keyboard = new KeyboardController
	
	if arg.num == 1
		//BgaSetVideoMode(800, 600, 32)
		BgaSetVideoMode(1024, 768, 32)
		mouse.x = screen_width / 2
		mouse.y = screen_height / 2
	
	desktop = new XWindow(nil, 0, 0, screen_width, screen_height, 1)
	if vga_mem2
		desktop.fill(0xff402040)
	else
		desktop.fill(0xff000000)
	
	mouse.create()
	
	draw_invalidated()
	
	// make our debugging life easier...
	execute(["/bin/xterm"], -1, -1)
	//execute(["/bin/c"], -1, -1)
	
	print("x: running\n")
	while true
		cmds.update()
		mouse.poll()
		keyboard.poll()
		draw_invalidated()
		usleep(5000)
		
	XExit()

#define __OS__
use "prog_header.kaba"


string command

class Variable
	string name, value
class VariableSet
	Variable *var[]
	Variable *get(string name)
		for v in var
			if v.name == name
				return v
		Variable *v = new Variable
		v.name = name
		var.add(v)
		return v
	void show()
		for v in var
			print v.name + " = " + v.value + "\n"
VariableSet vars

class Job
	string cmd
	int pid, id
	bool done
	void __init__(int _pid, int _id, string _cmd)
		pid = _pid
		id = _id
		cmd = _cmd
		done = false
	void test()
		int status
		if waitpid(pid, &status, false) == -2
			return
		vars.get("QM").value = status
		if self != jobs.fg
			print "[" + id + "] Fertig: " + cmd + "\n"
		if status < -600//-652
			print("  -- Programm hat was boeses gemacht! --\n")
		//print(" status " + status)
		done = true

class JobManager
	Job *job[]
	Job *fg
	void __init__()
		fg = nil
	int get_next_id()
		int id = 1
		for j in job
			if j.id >= id
				id = j.id + 1
		return id
	Job *get(int id)
		if (id == -1) and (job.num > 0)
			return job[job.num - 1]
		for j in job
			if j.id == id
				return j
		return nil
	Job *create(string c[], string cmd)
		bool as_bg = (c[c.num - 1] == "&")
		if as_bg
			c.remove(c.num - 1)
		int id = get_next_id()
		int pid = execute(c)
		if as_bg
			print "[" + id + "]: "
			//print pid
			print "\n"
		if pid < 0
			return nil
		Job *j = new Job(pid, id, cmd)
		job.add(j)
		if !as_bg
			fg = j
		return j
	void test_all()
		for j in job
			j.test()
		for int i, 0, job.num
			if job[i].done
				if job[i] == fg
					fg = nil
					prompt()
				delete job[i]
				job.remove(i)
				i --
	void show()
		for j in job
			print "" + j.id + " - " + j.cmd + "\n"

JobManager jobs


void prompt()
	print(getcwd() + ": ")

string parse_var_name(string cmd, int pos)
	string name
	for int i, pos, cmd.num
		if cmd[i] == ' ' or cmd[i] == '"' or cmd[i] == '$' or cmd[i] == '.' or cmd[i] == ':' or cmd[i] == ','
			break
		name.add(cmd[i])
	return name

string parse_single(string cmd, int *pos)
	string t
	bool in_string = false
	for int j, *pos, cmd.num
		if cmd[j] == ' ' and !in_string
			break
		if cmd[j] == '"'
			in_string = ! in_string
		else if cmd[j] == '$'
			string var_name = parse_var_name(cmd, j+1)
			t += vars.get(var_name).value
			j += var_name.num
		else
			t.add(cmd[j])
		*pos = j
	return t

void parse(string cmd0, string c[])
	string cmd = cmd0
	for int i, 0, cmd.num
		if cmd[i] == ' '
			continue
		string t = parse_single(cmd, &i)
		if t.num > 0
			if t[0] == '#'
				break
		c.add(t)

void execute_assign(string cmd)
	string a[] = cmd.explode("=")
	if a.num == 2
		vars.get(a[0]).value = a[1]

bool execute_job(string c[], string cmd)
	Job *j = jobs.create(c, cmd)
	return j

void do_fg(string c[])
	int id = -1
	if c.num >= 2
		id = c[1].int()
	Job *j = jobs.get(id)
	if j
		kill(j.pid, 18)
		jobs.fg = j
		print j.cmd + "\n"
	else
		print "kein Job\n"

void do_bg(string c[])
	int id = -1
	if c.num >= 2
		id = c[1].int()
	Job *j = jobs.get(id)
	if j
		kill(j.pid, 18)
		print "im Hintergrund: " + j.cmd + "\n"
	else
		print "kein Job\n"

void do_cd(string c[])
	if c.num > 1
		if chdir(c[1]) != 0
			print "kein gueltiges Verzeichnis: " + c[1] + "\n"
	else
		print("Verzeichnis?\n")

void exec(string cmd)
	string cmd0 = cmd
	string c[]
	parse(cmd, c)
	if c.num == 0
		return
	//print(c.join(" - ")+"|\n")
	string cc = c[0]
	if cc.find("=", 0) > 0
		execute_assign(cc)
	else if cc == "vars"
		vars.show()
	else if cc == "jobs"
		jobs.show()
	else if cc == "fg"
		do_fg(c)
	else if cc == "bg"
		do_bg(c)
	else if cc == "cd"
		do_cd(c)
	else if cc == "exit"
		exit(0)
	else
		if cc[0] == '/' or cc[0] == '.'
			if execute_job(c, cmd0)
				return
		c[0] = vars.get("PATH").value + c[0]
		if execute_job(c, cmd0)
			return
		print("unbekannter Befehl: " + cc + "\n")

void process(int k)
	int c = k
	if jobs.fg
		if c == 0x1a // 'Z'
			kill(jobs.fg.pid, 19)
			jobs.fg = nil
			print "angehalten\n"
			prompt()
		if c == 0x03 // 'C'
			kill(jobs.fg.pid, 9)
			jobs.test_all()
			prompt()
		return
		
	if c == 0x0a // '\n'
		print("\n")
		jobs.test_all()
		exec(command)
		command.clear()
		if !jobs.fg
			prompt()
	else if c == 0x7f // BACKSPACE
		string s
		if command.num > 0
			s.add(c)
			print(s)
			command.resize(command.num - 1)
	else if c > 0
		s.add(c)
		print(s)
		command.add(c)
	//else
	//	printh(&k, 2)

void main()
	init_lib()
	command.__init__()
	vars.__init__()
	vars.get("PATH").value = "/bin/"
	jobs.__init__()
	
	close(stdin)
	int new_stdin = open("/dev/tty", O_RDONLY | O_NONBLOCK)
	
	if new_stdin < 0
		print("## kann Tastatur nicht auslesen ##\n")
	else if stdout < 0
		// ... :P
		print("## kann stdout nicht oeffnen ##\n")
	else
		prompt()
		while true
			for int i, 0, 10000
				nil
			if jobs.fg
				jobs.test_all()
			cstring buf
			int r = read(stdin, &buf, 1)
			if r <= 0
				//print "."
				continue
			process(buf[0])
	close(stdin)
	close(stdout)
	
	while true
		nil

#define __OS__
use "prog_header.kaba"


class Prompt
	string cur
	string history[]
	int history_pos
	void __init__()
		history_pos = 0
		history.add("")
	void add(int k)
		cur.add(k)
		string s
		s.add(k)
		print(s)
	void clear()
		string s
		s.add(0x7f)
		for int i, 0, cur.num
			print s
		cur.clear()
	void add_to_history()
		history[history_pos] = cur
		history.add("")
		history_pos = history.num - 1
	void history_jump(int pos)
		history[history_pos] = cur
		history_pos = pos
		clear()
		cur = history[history_pos]
		print cur
	void history_up()
		if history_pos > 0
			history_jump(history_pos - 1)
	void history_down()
		if history_pos < history.num - 1
			history_jump(history_pos + 1)
	void show()
		print(getcwd() + ": ")
		
	void process(int k)
		if k < 0
			return
		int c = k
		if jobs.fg
			if c == 0x1a // 'Z'
				kill(jobs.fg.pid, 19)
				jobs.fg = nil
				print "angehalten\n"
				show()
			if c == 0x03 // 'C'
				kill(jobs.fg.pid, 9)
				jobs.test_all()
				show()
			return
		
		if c == 0x0a // '\n'
			print("\n")
			jobs.test_all()
			exec(cur)
			add_to_history()
			cur.clear()
			if !jobs.fg
				show()
		else if c == 0x7f // BACKSPACE
			string s
			if cur.num > 0
				s.add(c)
				print(s)
				cur.resize(cur.num - 1)
		else if c == 0x1b5b41 // ^[A up
			history_up()
		else if c == 0x1b5b42 // ^[B down
			history_down()
		else if c == 0x1b5b43 // ^[C left
			nil//print "----left---"
		else if c == 0x1b5b44 // ^[D right
			nil//print "----right---"
		else if c >= 0x20 and c <= 0x7e
			s.add(c)
			print(s)
			cur.add(c)
		//else
		//	printh(&k, 2)

Prompt prompt

class Variable
	string name, value
class VariableSet
	Variable *var[]
	Variable *get(string name)
		for v in var
			if v.name == name
				return v
		Variable *v = new Variable
		v.name = name
		var.add(v)
		return v
	void show()
		for v in var
			print v.name + " = " + v.value + "\n"
VariableSet vars

class Job
	string cmd
	int pid, id
	bool done
	void __init__(int _pid, int _id, string _cmd)
		pid = _pid
		id = _id
		cmd = _cmd
		done = false
	void test()
		int status
		if waitpid(pid, &status, false) == -2
			return
		vars.get("QM").value = status
		if self != jobs.fg
			print "[" + id + "] Fertig: " + cmd + "\n"
		if status < -600//-652
			print("  -- Programm hat was boeses gemacht! --\n")
		//print(" status " + status)
		done = true

class JobManager
	Job *job[]
	Job *fg
	void __init__()
		fg = nil
	int get_next_id()
		int id = 1
		for j in job
			if j.id >= id
				id = j.id + 1
		return id
	Job *get(int id)
		if (id == -1) and (job.num > 0)
			return job[job.num - 1]
		for j in job
			if j.id == id
				return j
		return nil
	Job *create(string c[], string cmd)
		bool as_bg = (c[c.num - 1] == "&")
		if as_bg
			c.remove(c.num - 1)
		int id = get_next_id()
		int pid = execute(c, stdin, stdout)
		if as_bg
			print "[" + id + "]: "
			//print pid
			print "\n"
		if pid < 0
			return nil
		Job *j = new Job(pid, id, cmd)
		job.add(j)
		if !as_bg
			fg = j
		return j
	void test_all()
		for j in job
			j.test()
		for int i, 0, job.num
			if job[i].done
				if job[i] == fg
					fg = nil
					prompt.show()
				delete job[i]
				job.remove(i)
				i --
	void show()
		for j in job
			print "" + j.id + " - " + j.cmd + "\n"

JobManager jobs


string parse_var_name(string cmd, int pos)
	string name
	for int i, pos, cmd.num
		if cmd[i] == ' ' or cmd[i] == '"' or cmd[i] == '$' or cmd[i] == '.' or cmd[i] == ':' or cmd[i] == ','
			break
		name.add(cmd[i])
	return name

string parse_single(string cmd, int *pos)
	string t
	bool in_string = false
	for int j, *pos, cmd.num
		if cmd[j] == ' ' and !in_string
			break
		if cmd[j] == '"'
			in_string = ! in_string
		else if cmd[j] == '$'
			string var_name = parse_var_name(cmd, j+1)
			t += vars.get(var_name).value
			j += var_name.num
		else
			t.add(cmd[j])
		*pos = j
	return t

void parse(string cmd0, string c[])
	string cmd = cmd0
	for int i, 0, cmd.num
		if cmd[i] == ' '
			continue
		string t = parse_single(cmd, &i)
		if t.num > 0
			if t[0] == '#'
				break
		c.add(t)

void execute_assign(string cmd)
	string a[] = cmd.explode("=")
	if a.num == 2
		vars.get(a[0]).value = a[1]

bool execute_job(string c[], string cmd)
	Job *j = jobs.create(c, cmd)
	return j

void do_fg(string c[])
	int id = -1
	if c.num >= 2
		id = c[1].int()
	Job *j = jobs.get(id)
	if j
		kill(j.pid, 18)
		jobs.fg = j
		print j.cmd + "\n"
	else
		print "kein Job\n"

void do_bg(string c[])
	int id = -1
	if c.num >= 2
		id = c[1].int()
	Job *j = jobs.get(id)
	if j
		kill(j.pid, 18)
		print "im Hintergrund: " + j.cmd + "\n"
	else
		print "kein Job\n"

void do_cd(string c[])
	if c.num > 1
		if chdir(c[1]) != 0
			print "kein gueltiges Verzeichnis: " + c[1] + "\n"
	else
		print("Verzeichnis?\n")

void exec(string cmd)
	string cmd0 = cmd
	string c[]
	parse(cmd, c)
	if c.num == 0
		return
	//print(c.join(" - ")+"|\n")
	string cc = c[0]
	if cc.find("=", 0) > 0
		execute_assign(cc)
	else if cc == "vars"
		vars.show()
	else if cc == "jobs"
		jobs.show()
	else if cc == "fg"
		do_fg(c)
	else if cc == "bg"
		do_bg(c)
	else if cc == "cd"
		do_cd(c)
	else if cc == "exit"
		exit(0)
	else
		if cc[0] == '/' or cc[0] == '.'
			if execute_job(c, cmd0)
				return
		c[0] = vars.get("PATH").value + c[0]
		if execute_job(c, cmd0)
			return
		print("unbekannter Befehl: " + cc + "\n")


int getkey()
	int buf = 0, key = 0
	int r = read(stdin, &key, 1)
	if r <= 0
		return -1
	if key != 0x0000001b
		return key
	r = read(stdin, &buf, 1)
	if r <= 0
		return -1
	key = (key << 8) + buf
	if buf != 0x5b
		return key
	r = read(stdin, &buf, 1)
	if r <= 0
		return -1
	key = (key << 8) + buf
	return key

void main()
	init_lib()
	prompt.__init__()
	vars.__init__()
	vars.get("PATH").value = "/bin/"
	jobs.__init__()
	
	close(stdin)
	int new_stdin = open("/dev/tty", O_RDONLY | O_NONBLOCK)
	
	if new_stdin < 0
		print("## kann Tastatur nicht auslesen ##\n")
	else if stdout < 0
		// ... :P
		print("## kann stdout nicht oeffnen ##\n")
	else
		prompt.show()
		while true
			for int i, 0, 10000
				nil
			if jobs.fg
				jobs.test_all()
			int key = getkey()
			prompt.process(key)
	close(stdin)
	close(stdout)
	
	while true
		nil

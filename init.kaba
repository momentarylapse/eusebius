/*----------------------------------------------------------------------------*\
| Eusebius - Init                                                              |
| -> A20-Gate aktivieren                                                       |
| -> GDT laden                                                                 |
| -> (VESA-Grafik-Modus?)                                                      |
| -> Protected Mode starten (32 bit)                                           |
| -> Kernel-Image laden und starten                                            |
|                                                                              |
| zuletzt geaendert: 2008.09.16 (c) by MichiSoft TM                            |
\*----------------------------------------------------------------------------*/

#define __OS__
#define __NO_FUNCTION_FRAME__
#define __CODE_ORIGIN__ 0x7e00
//#disasm

void main()	//-------------------------------------------------------------	// RealMode!!!
	asm{
		bits_16
		
		// Debug
		mov al, 'k'
		mov ah, 0x0e
		mov bx, 0x0000
		int 0x10


		// mehr als 1mb Ram erlauben (Gate 20A... :~~[  )
		mov ax, 0x2401
		int 0x15
		in al, 0x92
		or al, 0x02
		out 0x92, al

		// Speicher-Menge (RAM) feststellen
		mov ax, 0xe801
		int 0x15
		mov [_var_mem_size], bx // #64kb
		shr ax, 0x06
		add [_var_mem_size], ax // #1kb

		// Kernel-Image laden
//		_reset_drive:
			mov dl, 0x00
			mov ah, 0x00
			int 0x13
			or ah, ah
		//jnz _reset_drive
		xor ax, ax
		mov es, ax
		// Ziel des Images
		mov ax, 0x1000
		mov es, ax
		mov bx, 0x0000 // 0x1000:0x0000 = 0x10000 real mode segmentation is ugly
		mov ah, 0x02 // "ReadSector"
		mov al, 0x80
		mov cx, 0x0019
		mov dx, 0x0080
		int 0x13
	//	mov al, [0x5008] // Größe: 1Sektor = 512b
	//	mov cx, [0x5004]
	//	mov dx, [0x5006]
	//	int 0x13
		or ah, ah
		//jnz _reset_drive


		// Debug
		mov al, '2'
		mov ah, 0x0e
		mov bx, 0x0000
		int 0x10		
		// Speicher-Segmente laden
		lgdt [_gdtr]

		// Debug
		mov al, '3'
		mov ah, 0x0e
		mov bx, 0x0000
		int 0x10

		// 32bit Protected-Mode aktivieren
		cli
		mov eax, cr0
		or al, 0x01
		mov cr0, eax
		
		// flush cpu prefetch
		jmp _flush
		_flush:

		// die Segment-Register vorbereiten
		mov ax, 0x0010 // Descriptor[2]
		mov ds, ax
		mov es, ax
		mov fs, ax
		mov gs, ax
		mov ss, ax

		// Stack initialisieren
		mov esp, 0x00200000

		// in den 32bit ProtectedMode springen
		db 0x66 // weil im 16:32 Format...
		jmp_far [_pmode_ptr] // 0x0008:_pmode

	//-------------------------------------------------------------
	// ProtectedMode!!!
		_pmode:
		bits_32
		
		//jmp $
		
		mov eax, 0x000b8000
		mov [eax], 'M'
		add eax, 0x00000001
		mov [eax], 0x20
		
		// für den Stack nach einem C-Aufruf!
		mov ebp, esp
		
		mov eax, 0x000b8002
		mov [eax], '1'
		add eax, 0x00000001
		mov [eax], 0x20

		// Variablen speichern
		mov eax, [_var_mem_size]
		shl eax, 0x06
		mov [0x00005100], eax
		xor eax, eax

		// -> Kernel starten
		mov eax, 0x00010000
		jmp eax



		// zur Sicherheit....
		jmp $

	//-------------------------------------------------------------
	// Daten
	
		// Variablen
		_var_mem_size:
		dd 0x00000000

		_gdt:
		// [0] 0x00 null descriptor
		dd 0x00000000
		dd 0x00000000
		// [1] 0x08 code descriptor
		dd 0x0000ffff
		dd 0x00cf9a00
		// [2] 0x10 data descriptor
		dd 0x0000ffff
		dd 0x00cf9200

		_gdtr:
		dw 0x0017 // 3 descriptors
		dd _gdt
		
		_pmode_ptr:
		dd _pmode
		dw 0x0008 // Descriptor[1] : ...
	}


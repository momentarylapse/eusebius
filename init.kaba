#----------------------------------------------------------------------------*\
#| Eusebius - Init                                                              |
#| -> A20-Gate aktivieren                                                       |
#| -> GDT laden                                                                 |
#| -> Protected Mode starten (32 bit)                                           |
#| -> Kernel-Image laden und starten                                            |
#|                                                                              |
#| zuletzt geaendert: 2008.09.16 (c) by MichiSoft TM                            |
#\*----------------------------------------------------------------------------

func main()	#-------------------------------------------------------------	# RealMode!!!
	asm{
		bits_16
		
		# Debug
		mov al, 'I'
		mov ah, 0x0e
		mov bx, 0x0000
		int 0x10


#--------------------------------------------------------------
# gate 20A -> allow more than 1mb RAM :~~[

		mov ax, 0x2401
		int 0x15
		in al, 0x92
		or al, 0x02
		out 0x92, al

		# Speicher-Menge (RAM) feststellen
		mov ax, 0xe801
		int 0x15
		mov [_var_mem_size], bx # #64kb
		shr ax, 0x06
		add [_var_mem_size], ax # #1kb
		
		
		# Debug
		mov al, 'a'
		mov ah, 0x0e
		mov bx, 0x0000
		int 0x10
		
#--------------------------------------------------------------
# read memory map

		mov si, 0x0000 # counter
		
		mov ax, 0x0000
		mov es, ax
		mov di, 0x6000 # 00:6000
		xor ebx, ebx
		mov edx, 0x534d4150
		mov eax, 0x0000e820
		mov ecx, 0x00000018
		int 0x15
		
		# failed?
		jb _read_mem_map_end
		cmp eax, 0x534d4150
		jnz _read_mem_map_end
	_read_mem_map_loop:
		inc si
	
		mov ax, 0x0000
		mov es, ax
		add di, 0x0018
		mov edx, 0x534d4150
		mov eax, 0x0000e820
		mov ecx, 0x00000018
		int 0x15
		
		# end of list?
		jb _read_mem_map_end
	
		cmp si, 0x040
		jl _read_mem_map_loop
	_read_mem_map_end:
		
		# save count
		mov [0x5104], si
		xor ax, ax
		mov [0x5106], ax

		# Debug
		mov al, 'b'
		mov ah, 0x0e
		mov bx, 0x0000
		int 0x10


#--------------------------------------------------------------
# load kernel image

#		_reset_drive:
			mov dl, 0x00
			mov ah, 0x00
			int 0x13
			or ah, ah
		#jnz _reset_drive
		xor ax, ax
		mov es, ax
		
		# target address
		mov ax, 0x1000
		mov es, ax
		mov bx, 0x0000 # 0x1000:0x0000 = 0x10000 real mode segmentation is ugly
		mov ah, 0x02 # "ReadSector"
		mov al, 0x80 # 128 sectors * 512 bytes = 64k
		mov cx, 0x001d # sector 0x1d, cylinder 0
		mov dx, 0x0080 # head 0, disc 0
		int 0x13
		
		# Debug
		mov al, '1'
		mov ah, 0x0e
		mov bx, 0x0000
		int 0x10
		
		mov ax, 0x2000
		mov es, ax
		mov bx, 0x0000 # 0x20000
		mov ah, 0x02 # "ReadSector"
		mov al, 0x80 # 128 sectors * 512 bytes = 64k
		mov cx, 0x001f # sector 0x1f, cylinder 0
		mov dx, 0x0280 # head 2, disc 0
		int 0x13
		or ah, ah
		#jnz _reset_drive
		jnz _death_16
		
		# Debug
		mov al, '2'
		mov ah, 0x0e
		mov bx, 0x0000
		int 0x10
		
		mov ax, 0x3000
		mov es, ax
		mov bx, 0x0000 # 0x30000
		mov ah, 0x02 # "ReadSector"
		mov al, 0x80 # 128 sectors * 512 bytes = 64k
		mov cx, 0x0021 # sector 0x21, cylinder 0
		mov dx, 0x0480 # head 4, disc 0
		int 0x13
		
		or ah, ah
		#jnz _reset_drive
		jnz _death_16
		
		# Debug
		mov al, '3'
		mov ah, 0x0e
		mov bx, 0x0000
		int 0x10
		
#		mov ax, 0x4000
#		mov es, ax
#		mov bx, 0x0000 # 0x40000
#		mov ah, 0x02 # "ReadSector"
#		mov al, 0x80 # 128 sectors * 512 bytes = 64k
#		mov cx, 0x0023 # sector 0x23, cylinder 0
#		mov dx, 0x0680 # head 6, disc 0
#		int 0x13
		
#		or ah, ah
#		#jnz _reset_drive
#		jnz _death
		
#		# Debug
#		mov al, '4'
#		mov ah, 0x0e
#		mov bx, 0x0000
#		int 0x10
		
		
		# Debug
		mov al, 'c'
		mov ah, 0x0e
		mov bx, 0x0000
		int 0x10



#--------------------------------------------------------------
# load memory segments

		lgdt [_gdtr]

		# Debug
		mov al, 'd'
		mov ah, 0x0e
		mov bx, 0x0000
		int 0x10

#--------------------------------------------------------------
# activate 32bit protected mode

		cli
		
		# enable paging
		mov eax, cr0
		or al, 0x01
		mov cr0, eax
		
		# flush cpu prefetch
		jmp _flush
		_flush:

		# die Segment-Register vorbereiten
		mov ax, 0x0010 # Descriptor[2]
		mov ds, ax
		mov es, ax
		mov fs, ax
		mov gs, ax
		mov ss, ax

		# Stack initialisieren
		mov esp, 0x0027fff8

		# in den 32bit ProtectedMode springen
		db 0x66 # weil im 16:32 Format...
		jmp_far [_pmode_ptr] # 0x0008:_pmode

#-------------------------------------------------------------
# protected mode!!!

		_pmode:
		bits_32
		
		#jmp $
		
		mov eax, 0x000b8000
		mov [eax], 'P'
		add eax, 0x00000001
		mov [eax], 0x20
		
		# f√ºr den Stack nach einem C-Aufruf!
		mov ebp, esp
		
		mov eax, 0x000b8002
		mov [eax], '1'
		add eax, 0x00000001
		mov [eax], 0x20

		# Variablen speichern
		mov eax, [_var_mem_size]
		shl eax, 0x06
		mov [0x00005100], eax
		xor eax, eax
		
#-------------------------------------------------------------
# prepare long mode
		
		# extended cpuid functions?
		mov eax, 0x80000000
		cpuid
		cmp eax, 0x80000001
		jb _death_32
		
		# long mode available?
		mov eax, 0x80000001
		cpuid
		test edx, 0x20000000 # 1 << 29
		jz _death_32
		
		# disable paging
		mov eax, cr0
		and eax, 0x7fffffff # clear bit 31
		mov cr0, eax
		
		
		
		
		
		# clear tables
		mov edi, 0x01001000
		mov cr3, edi
		xor eax, eax
	#	mov ecx, 0x00001000
	_clear_table_entry:
		mov [edi], eax
		add edi, 0x00000004
		cmp edi, 0x01002000
		jnz _clear_table_entry
		#rep
		#stosd
		mov edi, cr3
		
		
		# PML4T[0] -> PDPT
		mov [edi], 0x01002003
		add edi, 0x00001000
		# PDPT[0] -> PDT
		mov [edi], 0x01003003
		add edi, 0x00001000
		# PDT[0] -> PT
		mov [edi], 0x01004003
		add edi, 0x00001000
		
		# identity map first 2mb
		mov ebx, 0x00000003
		mov ecx, 0x00000200 #512
	_set_table_entry:
		mov [edi], ebx
		add ebx, 0x00001000
		add edi, 0x00000008
	#	loop _set_table_entry
		dec ecx
		cmp ecx, 0x00000000
		jnz _set_table_entry
		
		# enable PAE paging
		mov eax, cr4
		or eax, 0x00000020
		mov cr4, eax
		
		
		
		# activate 64 bit mode
		mov ecx, 0xc0000080 # EFER MSR
		rdmsr
		or eax, 0x00000100 # LM bit
		wrmsr
		
		# enable paging
		mov eax, cr0
		or eax, 0x80000000 # PG bit
		mov cr0, eax
		
		
#-------------------------------------------------------------
# enter long mode

		# prepare GDT
		mov eax, _GDT64_POINTER
		add eax, 0x00000004
		mov [eax], _GDT64
		
		lgdt [_GDT64_POINTER]
		#jmp _long_mode
		
		jmp $
		jmp_far [_lmode_ptr] # 0x0008:_long_mode
		
	_long_mode:
		jmp $
		
		
		mov ecx, 0x20412042
		db 0x4f
		shl ecx, 0x10
		db 0x4f
		shr ecx, 0x10
		#xor rax, rax
		mov eax, 0x000b8004
		mov [eax], ecx #'L'
	#	add eax, 0x00000001
	#	mov [eax], 0x20
		#int 0x10
		
		jmp $
		
		
#-------------------------------------------------------------
# start kernel...
		

		# -> Kernel starten
		mov eax, 0x00010000
		jmp eax


	_death_16:
		mov al, 'X'
		mov ah, 0x0e
		mov bx, 0x0000
		int 0x10
		jmp $

	_death_32:
		mov eax, 0x000b8000
		mov [eax], 'X'
		add eax, 0x00000001
		mov [eax], 0x20
		jmp $
		
		
		
		
		
		
	_GDT64:
		# null descriptor
		dw 0xffff
		dw 0x0000
		db 0x00
		db 0x00
		db 0x01
		db 0x00
		# code
		dw 0x0000
		dw 0x0000
		db 0x00
		db 0x9a # exec+read
		db 0xaf # 64 bit, limit 19:16
		db 0x00
		# data
		dw 0x0000
		dw 0x0000
		db 0x00
		db 0x9a
		db 0x00
		db 0x00
	_GDT64_POINTER:
		dw 0x0017 # 8*3-1
		dd 0x00000000
		dd 0x00000000
	#	dq 0x0000000000000000 #_GDT64


#--------------------------------------------------------------
# data
	
		# Variablen
		_var_mem_size:
		dd 0x00000000

		_gdt:
		# [0] 0x00 null descriptor
		dd 0x00000000
		dd 0x00000000
		# [1] 0x08 code descriptor
		dd 0x0000ffff
		dd 0x00cf9a00
		# [2] 0x10 data descriptor
		dd 0x0000ffff
		dd 0x00cf9200

		_gdtr:
		dw 0x0017 # 3 descriptors
		dd _gdt
		
		_pmode_ptr:
		dd _pmode
		dw 0x0008 # Descriptor[1] : ...
		
		_lmode_ptr:
		dd _long_mode
		dw 0x0008
	}


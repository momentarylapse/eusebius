/*----------------------------------------------------------------------------*\
| Eusebius - Init                                                              |
| -> A20-Gate aktivieren                                                       |
| -> GDT laden                                                                 |
| -> (VESA-Grafik-Modus?)                                                      |
| -> Protected Mode starten (32 bit)                                           |
| -> Kernel-Image laden und starten                                            |
|                                                                              |
| zuletzt geaendert: 2008.09.16 (c) by MichiSoft TM                            |
\*----------------------------------------------------------------------------*/

#os
#initial_realmode
#code_origin 0x7e00

void main()	//-------------------------------------------------------------	// RealMode!!!
	asm{
		bits_16
		org 0x7e00				// Debug
		mov.b al, 'k'
		mov.b ah, 0x0e
		mov bx, 0x0000
		int 0x10


	// mehr als 1mb Ram erlauben (Gate 20A... :~~[  )
		mov ax, 0x2401
		int 0x15
		in.b al, 0x92
		or.b al, 0x02
		out.b 0x92, al


	// Speicher-Menge (RAM) feststellen
		mov ax, 0xe801
		int 0x15
		mov [_var_mem_size], bx
		shr ax, 0x06
		add [_var_mem_size], ax


	// Kernel-Image laden
//		_reset_drive:
			mov.b dl, 0x00
			mov.b ah, 0x00
			int 0x13
			or.b ah, ah
		//jnz.b _reset_drive
		xor ax, ax
		mov es, ax
		// Ziel des Images
		mov dword ebx, 0x00009000
		mov.b ah, 0x02 // "ReadSector"
		mov.b al, [0x5008] // Groesse: 1Sektor = 512b
		mov cx, [0x5004]
		mov dx, [0x5006]
		int 0x13
		or.b ah, ah
		//jnz.b _reset_drive
	}

	asm{
	// Speicher-Segmente laden
		lgdt [_gdtr]

		// Debug
		mov.b al, '3'
		mov.b ah, 0x0e
		mov bx, 0x0000
		int 0x10

	// 32bit Protected-Mode aktivieren
		cli
		mov eax, cr0
		or.b al, 0x01
		mov cr0, eax

	// die Segment-Register vorbereiten
		mov ax, 0x0010 // Descriptor[2]
		mov ds, ax
		mov es, ax
		mov fs, ax
		mov gs, ax
		mov ss, ax

	// Stack initialisieren
		mov dword esp, 0x200000

	// in den 32bit ProtectedMode springen
		jmp dword 0x0008:_pmode // Descriptor[1] : ...

	//-------------------------------------------------------------
	// ProtectedMode!!!
		_pmode:
		bits_32
		
		
		mov eax, 0xb8000
		mov.b [eax], 'M'
		add eax,0x01
		mov.b [eax], 0x20
		
		// fuer den Stack nach einem C-Aufruf!
		mov ebp, esp
		
		mov eax, 0xb8002
		mov.b [eax], '1'
		add eax,0x01
		mov.b [eax], 0x20

		// Variablen speichern
		mov eax, [_var_mem_size]
		mov [0x5100], eax
		mov eax, _gdt
		mov [0x5110], eax
		mov eax, _gdtr
		mov [0x5114], eax
		xor eax, eax
	}


	asm{

	// -> Kernel starten
		mov eax, 0x9000
		jmp eax



	// zur Sicherheit....
		jmp.b $

	//-------------------------------------------------------------
	// Daten
	
		// Variablen
		_var_mem_size:
		dd 0x00000000

		_gdt:
		// [0] 0x00 null descriptor
		dd 0x00000000
		dd 0x00000000
		// [1] 0x08 code descriptor
		dd 0x0000ffff
		dd 0x00cf9a00
		// [2] 0x10 data descriptor
		dd 0x0000ffff
		dd 0x00cf9200
		// [3] 0x28 ldt base=0x6700 limit=0x17 ----nicht benutzt!----
		dd 0x67000017
		dd 0x00009200
		// [4] 0x30 realmode descriptor...?
		dd 0x0000ffff
		dd 0x00409200
		// [5] 0x18 task 0 (kernel) base=0x6000 limit=103 pl=0
		dd 0x600000ff
		dd 0x00008900  // not busy
		// [6] 0x20 task 1 (irq timer) base=0x6080 limit=103 pl=0
		dd 0x60800067
		dd 0x00008900  // not busy
		// [7] 0x20 task 2 (irq keys) base=0x6100 limit=103 pl=0
		dd 0x61000067
		dd 0x00008900  // not busy
		// [8] 0x20 task 3 (test) base=0x6180 limit=103 pl=0
		dd 0x61800067
		dd 0x00008900  // not busy

		_gdtr:
		dw 0x47 // 5 descriptors
		dd _gdt
	}

